{"ast":null,"code":"const npm = require('../npm.js');\n\nconst path = require('path');\n\nconst chownr = require('chownr');\n\nconst writeFileAtomic = require('write-file-atomic');\n\nconst mkdirp = require('mkdirp-infer-owner');\n\nconst fs = require('graceful-fs');\n\nlet cache = null;\nlet cacheUid = null;\nlet cacheGid = null;\nlet needChown = typeof process.getuid === 'function';\n\nconst getCacheOwner = () => {\n  let st;\n\n  try {\n    st = fs.lstatSync(cache);\n  } catch (er) {\n    if (er.code !== 'ENOENT') throw er;\n    st = fs.lstatSync(path.dirname(cache));\n  }\n\n  cacheUid = st.uid;\n  cacheGid = st.gid;\n  needChown = st.uid !== process.getuid() || st.gid !== process.getgid();\n};\n\nconst writeOrAppend = (method, file, data) => {\n  if (!cache) cache = npm.config.get('cache'); // redundant if already absolute, but prevents non-absolute files\n  // from being written as if they're part of the cache.\n\n  file = path.resolve(cache, file);\n  if (cacheUid === null && needChown) getCacheOwner();\n  const dir = path.dirname(file);\n  const firstMade = mkdirp.sync(dir);\n  if (!needChown) return method(file, data);\n  let methodThrew = true;\n\n  try {\n    method(file, data);\n    methodThrew = false;\n  } finally {\n    // always try to leave it in the right ownership state, even on failure\n    // let the method error fail it instead of the chownr error, though\n    if (!methodThrew) chownr.sync(firstMade || file, cacheUid, cacheGid);else {\n      try {\n        chownr.sync(firstMade || file, cacheUid, cacheGid);\n      } catch (_) {}\n    }\n  }\n};\n\nexports.append = (file, data) => writeOrAppend(fs.appendFileSync, file, data);\n\nexports.write = (file, data) => writeOrAppend(writeFileAtomic.sync, file, data);","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/lib/utils/cache-file.js"],"names":["npm","require","path","chownr","writeFileAtomic","mkdirp","fs","cache","cacheUid","cacheGid","needChown","process","getuid","getCacheOwner","st","lstatSync","er","code","dirname","uid","gid","getgid","writeOrAppend","method","file","data","config","get","resolve","dir","firstMade","sync","methodThrew","_","exports","append","appendFileSync","write"],"mappings":"AAAA,MAAMA,GAAG,GAAGC,OAAO,CAAC,WAAD,CAAnB;;AACA,MAAMC,IAAI,GAAGD,OAAO,CAAC,MAAD,CAApB;;AACA,MAAME,MAAM,GAAGF,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAMG,eAAe,GAAGH,OAAO,CAAC,mBAAD,CAA/B;;AACA,MAAMI,MAAM,GAAGJ,OAAO,CAAC,oBAAD,CAAtB;;AACA,MAAMK,EAAE,GAAGL,OAAO,CAAC,aAAD,CAAlB;;AAEA,IAAIM,KAAK,GAAG,IAAZ;AACA,IAAIC,QAAQ,GAAG,IAAf;AACA,IAAIC,QAAQ,GAAG,IAAf;AACA,IAAIC,SAAS,GAAG,OAAOC,OAAO,CAACC,MAAf,KAA0B,UAA1C;;AAEA,MAAMC,aAAa,GAAG,MAAM;AAC1B,MAAIC,EAAJ;;AACA,MAAI;AACFA,IAAAA,EAAE,GAAGR,EAAE,CAACS,SAAH,CAAaR,KAAb,CAAL;AACD,GAFD,CAEE,OAAOS,EAAP,EAAW;AACX,QAAIA,EAAE,CAACC,IAAH,KAAY,QAAhB,EACE,MAAMD,EAAN;AAEFF,IAAAA,EAAE,GAAGR,EAAE,CAACS,SAAH,CAAab,IAAI,CAACgB,OAAL,CAAaX,KAAb,CAAb,CAAL;AACD;;AAEDC,EAAAA,QAAQ,GAAGM,EAAE,CAACK,GAAd;AACAV,EAAAA,QAAQ,GAAGK,EAAE,CAACM,GAAd;AAEAV,EAAAA,SAAS,GAAGI,EAAE,CAACK,GAAH,KAAWR,OAAO,CAACC,MAAR,EAAX,IACVE,EAAE,CAACM,GAAH,KAAWT,OAAO,CAACU,MAAR,EADb;AAED,CAhBD;;AAkBA,MAAMC,aAAa,GAAG,CAACC,MAAD,EAASC,IAAT,EAAeC,IAAf,KAAwB;AAC5C,MAAI,CAAClB,KAAL,EACEA,KAAK,GAAGP,GAAG,CAAC0B,MAAJ,CAAWC,GAAX,CAAe,OAAf,CAAR,CAF0C,CAI5C;AACA;;AACAH,EAAAA,IAAI,GAAGtB,IAAI,CAAC0B,OAAL,CAAarB,KAAb,EAAoBiB,IAApB,CAAP;AAEA,MAAIhB,QAAQ,KAAK,IAAb,IAAqBE,SAAzB,EACEG,aAAa;AAEf,QAAMgB,GAAG,GAAG3B,IAAI,CAACgB,OAAL,CAAaM,IAAb,CAAZ;AACA,QAAMM,SAAS,GAAGzB,MAAM,CAAC0B,IAAP,CAAYF,GAAZ,CAAlB;AAEA,MAAI,CAACnB,SAAL,EACE,OAAOa,MAAM,CAACC,IAAD,EAAOC,IAAP,CAAb;AAEF,MAAIO,WAAW,GAAG,IAAlB;;AACA,MAAI;AACFT,IAAAA,MAAM,CAACC,IAAD,EAAOC,IAAP,CAAN;AACAO,IAAAA,WAAW,GAAG,KAAd;AACD,GAHD,SAGU;AACR;AACA;AACA,QAAI,CAACA,WAAL,EACE7B,MAAM,CAAC4B,IAAP,CAAYD,SAAS,IAAIN,IAAzB,EAA+BhB,QAA/B,EAAyCC,QAAzC,EADF,KAEK;AACH,UAAI;AACFN,QAAAA,MAAM,CAAC4B,IAAP,CAAYD,SAAS,IAAIN,IAAzB,EAA+BhB,QAA/B,EAAyCC,QAAzC;AACD,OAFD,CAEE,OAAOwB,CAAP,EAAU,CAAE;AACf;AACF;AACF,CAhCD;;AAkCAC,OAAO,CAACC,MAAR,GAAiB,CAACX,IAAD,EAAOC,IAAP,KAAgBH,aAAa,CAAChB,EAAE,CAAC8B,cAAJ,EAAoBZ,IAApB,EAA0BC,IAA1B,CAA9C;;AACAS,OAAO,CAACG,KAAR,GAAgB,CAACb,IAAD,EAAOC,IAAP,KAAgBH,aAAa,CAAClB,eAAe,CAAC2B,IAAjB,EAAuBP,IAAvB,EAA6BC,IAA7B,CAA7C","sourcesContent":["const npm = require('../npm.js')\nconst path = require('path')\nconst chownr = require('chownr')\nconst writeFileAtomic = require('write-file-atomic')\nconst mkdirp = require('mkdirp-infer-owner')\nconst fs = require('graceful-fs')\n\nlet cache = null\nlet cacheUid = null\nlet cacheGid = null\nlet needChown = typeof process.getuid === 'function'\n\nconst getCacheOwner = () => {\n  let st\n  try {\n    st = fs.lstatSync(cache)\n  } catch (er) {\n    if (er.code !== 'ENOENT')\n      throw er\n\n    st = fs.lstatSync(path.dirname(cache))\n  }\n\n  cacheUid = st.uid\n  cacheGid = st.gid\n\n  needChown = st.uid !== process.getuid() ||\n    st.gid !== process.getgid()\n}\n\nconst writeOrAppend = (method, file, data) => {\n  if (!cache)\n    cache = npm.config.get('cache')\n\n  // redundant if already absolute, but prevents non-absolute files\n  // from being written as if they're part of the cache.\n  file = path.resolve(cache, file)\n\n  if (cacheUid === null && needChown)\n    getCacheOwner()\n\n  const dir = path.dirname(file)\n  const firstMade = mkdirp.sync(dir)\n\n  if (!needChown)\n    return method(file, data)\n\n  let methodThrew = true\n  try {\n    method(file, data)\n    methodThrew = false\n  } finally {\n    // always try to leave it in the right ownership state, even on failure\n    // let the method error fail it instead of the chownr error, though\n    if (!methodThrew)\n      chownr.sync(firstMade || file, cacheUid, cacheGid)\n    else {\n      try {\n        chownr.sync(firstMade || file, cacheUid, cacheGid)\n      } catch (_) {}\n    }\n  }\n}\n\nexports.append = (file, data) => writeOrAppend(fs.appendFileSync, file, data)\nexports.write = (file, data) => writeOrAppend(writeFileAtomic.sync, file, data)\n"]},"metadata":{},"sourceType":"script"}
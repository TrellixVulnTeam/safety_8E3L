{"ast":null,"code":"const {\n  resolve\n} = require('path');\n\nconst semver = require('semver');\n\nconst libdiff = require('libnpmdiff');\n\nconst npa = require('npm-package-arg');\n\nconst Arborist = require('@npmcli/arborist');\n\nconst npmlog = require('npmlog');\n\nconst pacote = require('pacote');\n\nconst pickManifest = require('npm-pick-manifest');\n\nconst readLocalPkg = require('./utils/read-local-package.js');\n\nconst BaseCommand = require('./base-command.js');\n\nclass Diff extends BaseCommand {\n  static get description() {\n    return 'The registry diff command';\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  static get name() {\n    return 'diff';\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  static get usage() {\n    return ['[...<paths>]', '--diff=<pkg-name> [...<paths>]', '--diff=<version-a> [--diff=<version-b>] [...<paths>]', '--diff=<spec-a> [--diff=<spec-b>] [...<paths>]', '[--diff-ignore-all-space] [--diff-name-only] [...<paths>] [...<paths>]'];\n  }\n\n  get where() {\n    const globalTop = resolve(this.npm.globalDir, '..');\n    const global = this.npm.config.get('global');\n    return global ? globalTop : this.npm.prefix;\n  }\n\n  exec(args, cb) {\n    this.diff(args).then(() => cb()).catch(cb);\n  }\n\n  async diff(args) {\n    const specs = this.npm.config.get('diff').filter(d => d);\n\n    if (specs.length > 2) {\n      throw new TypeError('Can\\'t use more than two --diff arguments.\\n\\n' + `Usage:\\n${this.usage}`);\n    }\n\n    const [a, b] = await this.retrieveSpecs(specs);\n    npmlog.info('diff', {\n      src: a,\n      dst: b\n    });\n    const res = await libdiff([a, b], { ...this.npm.flatOptions,\n      diffFiles: args,\n      where: this.where\n    });\n    return this.npm.output(res);\n  }\n\n  async retrieveSpecs([a, b]) {\n    // no arguments, defaults to comparing cwd\n    // to its latest published registry version\n    if (!a) return this.defaultSpec(); // single argument, used to compare wanted versions of an\n    // installed dependency or to compare the cwd to a published version\n\n    if (!b) return this.transformSingleSpec(a);\n    const specs = await this.convertVersionsToSpecs([a, b]);\n    return this.findVersionsByPackageName(specs);\n  }\n\n  async defaultSpec() {\n    let noPackageJson;\n    let pkgName;\n\n    try {\n      pkgName = await readLocalPkg(this.npm);\n    } catch (e) {\n      npmlog.verbose('diff', 'could not read project dir package.json');\n      noPackageJson = true;\n    }\n\n    if (!pkgName || noPackageJson) {\n      throw new Error('Needs multiple arguments to compare or run from a project dir.\\n\\n' + `Usage:\\n${this.usage}`);\n    }\n\n    return [`${pkgName}@${this.npm.config.get('tag')}`, `file:${this.npm.prefix}`];\n  }\n\n  async transformSingleSpec(a) {\n    let noPackageJson;\n    let pkgName;\n\n    try {\n      pkgName = await readLocalPkg(this.npm);\n    } catch (e) {\n      npmlog.verbose('diff', 'could not read project dir package.json');\n      noPackageJson = true;\n    }\n\n    const missingPackageJson = new Error('Needs multiple arguments to compare or run from a project dir.\\n\\n' + `Usage:\\n${this.usage}`);\n\n    const specSelf = () => {\n      if (noPackageJson) throw missingPackageJson;\n      return `file:${this.npm.prefix}`;\n    }; // using a valid semver range, that means it should just diff\n    // the cwd against a published version to the registry using the\n    // same project name and the provided semver range\n\n\n    if (semver.validRange(a)) {\n      if (!pkgName) throw missingPackageJson;\n      return [`${pkgName}@${a}`, specSelf()];\n    } // when using a single package name as arg and it's part of the current\n    // install tree, then retrieve the current installed version and compare\n    // it against the same value `npm outdated` would suggest you to update to\n\n\n    const spec = npa(a);\n\n    if (spec.registry) {\n      let actualTree;\n      let node;\n\n      try {\n        const opts = { ...this.npm.flatOptions,\n          path: this.where\n        };\n        const arb = new Arborist(opts);\n        actualTree = await arb.loadActual(opts);\n        node = actualTree && actualTree.inventory.query('name', spec.name).values().next().value;\n      } catch (e) {\n        npmlog.verbose('diff', 'failed to load actual install tree');\n      }\n\n      if (!node || !node.name || !node.package || !node.package.version) {\n        return [`${spec.name}@${spec.fetchSpec}`, specSelf()];\n      }\n\n      const tryRootNodeSpec = () => (actualTree && actualTree.edgesOut.get(spec.name) || {}).spec;\n\n      const tryAnySpec = () => {\n        for (const edge of node.edgesIn) return edge.spec;\n      };\n\n      const aSpec = `file:${node.realpath}`; // finds what version of the package to compare against, if a exact\n      // version or tag was passed than it should use that, otherwise\n      // work from the top of the arborist tree to find the original semver\n      // range declared in the package that depends on the package.\n\n      let bSpec;\n      if (spec.rawSpec) bSpec = spec.rawSpec;else {\n        const bTargetVersion = tryRootNodeSpec() || tryAnySpec(); // figure out what to compare against,\n        // follows same logic to npm outdated \"Wanted\" results\n\n        const packument = await pacote.packument(spec, { ...this.npm.flatOptions,\n          preferOnline: true\n        });\n        bSpec = pickManifest(packument, bTargetVersion, { ...this.npm.flatOptions\n        }).version;\n      }\n      return [`${spec.name}@${aSpec}`, `${spec.name}@${bSpec}`];\n    } else if (spec.type === 'directory') {\n      return [`file:${spec.fetchSpec}`, specSelf()];\n    } else {\n      throw new Error('Spec type not supported.\\n\\n' + `Usage:\\n${this.usage}`);\n    }\n  }\n\n  async convertVersionsToSpecs([a, b]) {\n    const semverA = semver.validRange(a);\n    const semverB = semver.validRange(b); // both specs are semver versions, assume current project dir name\n\n    if (semverA && semverB) {\n      let pkgName;\n\n      try {\n        pkgName = await readLocalPkg(this.npm);\n      } catch (e) {\n        npmlog.verbose('diff', 'could not read project dir package.json');\n      }\n\n      if (!pkgName) {\n        throw new Error('Needs to be run from a project dir in order to diff two versions.\\n\\n' + `Usage:\\n${this.usage}`);\n      }\n\n      return [`${pkgName}@${a}`, `${pkgName}@${b}`];\n    } // otherwise uses the name from the other arg to\n    // figure out the spec.name of what to compare\n\n\n    if (!semverA && semverB) return [a, `${npa(a).name}@${b}`];\n    if (semverA && !semverB) return [`${npa(b).name}@${a}`, b]; // no valid semver ranges used\n\n    return [a, b];\n  }\n\n  async findVersionsByPackageName(specs) {\n    let actualTree;\n\n    try {\n      const opts = { ...this.npm.flatOptions,\n        path: this.where\n      };\n      const arb = new Arborist(opts);\n      actualTree = await arb.loadActual(opts);\n    } catch (e) {\n      npmlog.verbose('diff', 'failed to load actual install tree');\n    }\n\n    return specs.map(i => {\n      const spec = npa(i);\n      if (spec.rawSpec) return i;\n      const node = actualTree && actualTree.inventory.query('name', spec.name).values().next().value;\n      const res = !node || !node.package || !node.package.version ? spec.fetchSpec : `file:${node.realpath}`;\n      return `${spec.name}@${res}`;\n    });\n  }\n\n}\n\nmodule.exports = Diff;","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/lib/diff.js"],"names":["resolve","require","semver","libdiff","npa","Arborist","npmlog","pacote","pickManifest","readLocalPkg","BaseCommand","Diff","description","name","usage","where","globalTop","npm","globalDir","global","config","get","prefix","exec","args","cb","diff","then","catch","specs","filter","d","length","TypeError","a","b","retrieveSpecs","info","src","dst","res","flatOptions","diffFiles","output","defaultSpec","transformSingleSpec","convertVersionsToSpecs","findVersionsByPackageName","noPackageJson","pkgName","e","verbose","Error","missingPackageJson","specSelf","validRange","spec","registry","actualTree","node","opts","path","arb","loadActual","inventory","query","values","next","value","package","version","fetchSpec","tryRootNodeSpec","edgesOut","tryAnySpec","edge","edgesIn","aSpec","realpath","bSpec","rawSpec","bTargetVersion","packument","preferOnline","type","semverA","semverB","map","i","module","exports"],"mappings":"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","sourcesContent":["const { resolve } = require('path')\n\nconst semver = require('semver')\nconst libdiff = require('libnpmdiff')\nconst npa = require('npm-package-arg')\nconst Arborist = require('@npmcli/arborist')\nconst npmlog = require('npmlog')\nconst pacote = require('pacote')\nconst pickManifest = require('npm-pick-manifest')\n\nconst readLocalPkg = require('./utils/read-local-package.js')\nconst BaseCommand = require('./base-command.js')\n\nclass Diff extends BaseCommand {\n  static get description () {\n    return 'The registry diff command'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get name () {\n    return 'diff'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get usage () {\n    return [\n      '[...<paths>]',\n      '--diff=<pkg-name> [...<paths>]',\n      '--diff=<version-a> [--diff=<version-b>] [...<paths>]',\n      '--diff=<spec-a> [--diff=<spec-b>] [...<paths>]',\n      '[--diff-ignore-all-space] [--diff-name-only] [...<paths>] [...<paths>]',\n    ]\n  }\n\n  get where () {\n    const globalTop = resolve(this.npm.globalDir, '..')\n    const global = this.npm.config.get('global')\n    return global ? globalTop : this.npm.prefix\n  }\n\n  exec (args, cb) {\n    this.diff(args).then(() => cb()).catch(cb)\n  }\n\n  async diff (args) {\n    const specs = this.npm.config.get('diff').filter(d => d)\n    if (specs.length > 2) {\n      throw new TypeError(\n        'Can\\'t use more than two --diff arguments.\\n\\n' +\n        `Usage:\\n${this.usage}`\n      )\n    }\n\n    const [a, b] = await this.retrieveSpecs(specs)\n    npmlog.info('diff', { src: a, dst: b })\n\n    const res = await libdiff([a, b], {\n      ...this.npm.flatOptions,\n      diffFiles: args,\n      where: this.where,\n    })\n    return this.npm.output(res)\n  }\n\n  async retrieveSpecs ([a, b]) {\n    // no arguments, defaults to comparing cwd\n    // to its latest published registry version\n    if (!a)\n      return this.defaultSpec()\n\n    // single argument, used to compare wanted versions of an\n    // installed dependency or to compare the cwd to a published version\n    if (!b)\n      return this.transformSingleSpec(a)\n\n    const specs = await this.convertVersionsToSpecs([a, b])\n    return this.findVersionsByPackageName(specs)\n  }\n\n  async defaultSpec () {\n    let noPackageJson\n    let pkgName\n    try {\n      pkgName = await readLocalPkg(this.npm)\n    } catch (e) {\n      npmlog.verbose('diff', 'could not read project dir package.json')\n      noPackageJson = true\n    }\n\n    if (!pkgName || noPackageJson) {\n      throw new Error(\n        'Needs multiple arguments to compare or run from a project dir.\\n\\n' +\n        `Usage:\\n${this.usage}`\n      )\n    }\n\n    return [\n      `${pkgName}@${this.npm.config.get('tag')}`,\n      `file:${this.npm.prefix}`,\n    ]\n  }\n\n  async transformSingleSpec (a) {\n    let noPackageJson\n    let pkgName\n    try {\n      pkgName = await readLocalPkg(this.npm)\n    } catch (e) {\n      npmlog.verbose('diff', 'could not read project dir package.json')\n      noPackageJson = true\n    }\n    const missingPackageJson = new Error(\n      'Needs multiple arguments to compare or run from a project dir.\\n\\n' +\n      `Usage:\\n${this.usage}`\n    )\n\n    const specSelf = () => {\n      if (noPackageJson)\n        throw missingPackageJson\n\n      return `file:${this.npm.prefix}`\n    }\n\n    // using a valid semver range, that means it should just diff\n    // the cwd against a published version to the registry using the\n    // same project name and the provided semver range\n    if (semver.validRange(a)) {\n      if (!pkgName)\n        throw missingPackageJson\n\n      return [\n        `${pkgName}@${a}`,\n        specSelf(),\n      ]\n    }\n\n    // when using a single package name as arg and it's part of the current\n    // install tree, then retrieve the current installed version and compare\n    // it against the same value `npm outdated` would suggest you to update to\n    const spec = npa(a)\n    if (spec.registry) {\n      let actualTree\n      let node\n      try {\n        const opts = {\n          ...this.npm.flatOptions,\n          path: this.where,\n        }\n        const arb = new Arborist(opts)\n        actualTree = await arb.loadActual(opts)\n        node = actualTree &&\n          actualTree.inventory.query('name', spec.name)\n            .values().next().value\n      } catch (e) {\n        npmlog.verbose('diff', 'failed to load actual install tree')\n      }\n\n      if (!node || !node.name || !node.package || !node.package.version) {\n        return [\n          `${spec.name}@${spec.fetchSpec}`,\n          specSelf(),\n        ]\n      }\n\n      const tryRootNodeSpec = () =>\n        (actualTree && actualTree.edgesOut.get(spec.name) || {}).spec\n\n      const tryAnySpec = () => {\n        for (const edge of node.edgesIn)\n          return edge.spec\n      }\n\n      const aSpec = `file:${node.realpath}`\n\n      // finds what version of the package to compare against, if a exact\n      // version or tag was passed than it should use that, otherwise\n      // work from the top of the arborist tree to find the original semver\n      // range declared in the package that depends on the package.\n      let bSpec\n      if (spec.rawSpec)\n        bSpec = spec.rawSpec\n      else {\n        const bTargetVersion =\n          tryRootNodeSpec()\n          || tryAnySpec()\n\n        // figure out what to compare against,\n        // follows same logic to npm outdated \"Wanted\" results\n        const packument = await pacote.packument(spec, {\n          ...this.npm.flatOptions,\n          preferOnline: true,\n        })\n        bSpec = pickManifest(\n          packument,\n          bTargetVersion,\n          { ...this.npm.flatOptions }\n        ).version\n      }\n\n      return [\n        `${spec.name}@${aSpec}`,\n        `${spec.name}@${bSpec}`,\n      ]\n    } else if (spec.type === 'directory') {\n      return [\n        `file:${spec.fetchSpec}`,\n        specSelf(),\n      ]\n    } else {\n      throw new Error(\n        'Spec type not supported.\\n\\n' +\n        `Usage:\\n${this.usage}`\n      )\n    }\n  }\n\n  async convertVersionsToSpecs ([a, b]) {\n    const semverA = semver.validRange(a)\n    const semverB = semver.validRange(b)\n\n    // both specs are semver versions, assume current project dir name\n    if (semverA && semverB) {\n      let pkgName\n      try {\n        pkgName = await readLocalPkg(this.npm)\n      } catch (e) {\n        npmlog.verbose('diff', 'could not read project dir package.json')\n      }\n\n      if (!pkgName) {\n        throw new Error(\n          'Needs to be run from a project dir in order to diff two versions.\\n\\n' +\n          `Usage:\\n${this.usage}`\n        )\n      }\n      return [`${pkgName}@${a}`, `${pkgName}@${b}`]\n    }\n\n    // otherwise uses the name from the other arg to\n    // figure out the spec.name of what to compare\n    if (!semverA && semverB)\n      return [a, `${npa(a).name}@${b}`]\n\n    if (semverA && !semverB)\n      return [`${npa(b).name}@${a}`, b]\n\n    // no valid semver ranges used\n    return [a, b]\n  }\n\n  async findVersionsByPackageName (specs) {\n    let actualTree\n    try {\n      const opts = {\n        ...this.npm.flatOptions,\n        path: this.where,\n      }\n      const arb = new Arborist(opts)\n      actualTree = await arb.loadActual(opts)\n    } catch (e) {\n      npmlog.verbose('diff', 'failed to load actual install tree')\n    }\n\n    return specs.map(i => {\n      const spec = npa(i)\n      if (spec.rawSpec)\n        return i\n\n      const node = actualTree\n        && actualTree.inventory.query('name', spec.name)\n          .values().next().value\n\n      const res = !node || !node.package || !node.package.version\n        ? spec.fetchSpec\n        : `file:${node.realpath}`\n\n      return `${spec.name}@${res}`\n    })\n  }\n}\n\nmodule.exports = Diff\n"]},"metadata":{},"sourceType":"script"}
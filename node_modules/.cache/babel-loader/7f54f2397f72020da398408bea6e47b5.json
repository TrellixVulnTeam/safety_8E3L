{"ast":null,"code":"const {\n  resolve\n} = require('path');\n\nconst {\n  EOL\n} = require('os');\n\nconst archy = require('archy');\n\nconst chalk = require('chalk');\n\nconst Arborist = require('@npmcli/arborist');\n\nconst {\n  breadth\n} = require('treeverse');\n\nconst npa = require('npm-package-arg');\n\nconst completion = require('./utils/completion/installed-deep.js');\n\nconst _depth = Symbol('depth');\n\nconst _dedupe = Symbol('dedupe');\n\nconst _filteredBy = Symbol('filteredBy');\n\nconst _include = Symbol('include');\n\nconst _invalid = Symbol('invalid');\n\nconst _name = Symbol('name');\n\nconst _missing = Symbol('missing');\n\nconst _parent = Symbol('parent');\n\nconst _problems = Symbol('problems');\n\nconst _required = Symbol('required');\n\nconst _type = Symbol('type');\n\nconst BaseCommand = require('./base-command.js');\n\nclass LS extends BaseCommand {\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get description() {\n    return 'List installed packages';\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  static get name() {\n    return 'ls';\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  static get usage() {\n    return ['npm ls [[<@scope>/]<pkg> ...]'];\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  async completion(opts) {\n    return completion(this.npm, opts);\n  }\n\n  exec(args, cb) {\n    this.ls(args).then(() => cb()).catch(cb);\n  }\n\n  async ls(args) {\n    const all = this.npm.config.get('all');\n    const color = !!this.npm.color;\n    const depth = this.npm.config.get('depth');\n    const dev = this.npm.config.get('dev');\n    const development = this.npm.config.get('development');\n    const global = this.npm.config.get('global');\n    const json = this.npm.config.get('json');\n    const link = this.npm.config.get('link');\n    const long = this.npm.config.get('long');\n    const only = this.npm.config.get('only');\n    const parseable = this.npm.config.get('parseable');\n    const prod = this.npm.config.get('prod');\n    const production = this.npm.config.get('production');\n    const unicode = this.npm.config.get('unicode');\n    const path = global ? resolve(this.npm.globalDir, '..') : this.npm.prefix;\n    const arb = new Arborist({\n      global,\n      ...this.npm.flatOptions,\n      legacyPeerDeps: false,\n      path\n    });\n    const tree = await this.initTree({\n      arb,\n      args\n    });\n    const seenItems = new Set();\n    const seenNodes = new Map();\n    const problems = new Set(); // defines special handling of printed depth when filtering with args\n\n    const filterDefaultDepth = depth === null ? Infinity : depth;\n    const depthToPrint = all || args.length ? filterDefaultDepth : depth || 0; // add root node of tree to list of seenNodes\n\n    seenNodes.set(tree.path, tree); // tree traversal happens here, using treeverse.breadth\n\n    const result = await breadth({\n      tree,\n\n      // recursive method, `node` is going to be the current elem (starting from\n      // the `tree` obj) that was just visited in the `visit` method below\n      // `nodeResult` is going to be the returned `item` from `visit`\n      getChildren(node, nodeResult) {\n        const seenPaths = new Set();\n        const shouldSkipChildren = !(node instanceof Arborist.Node) || node[_depth] > depthToPrint;\n        return shouldSkipChildren ? [] : [...(node.target || node).edgesOut.values()].filter(filterByEdgesTypes({\n          dev,\n          development,\n          link,\n          node,\n          prod,\n          production,\n          only,\n          tree\n        })).map(mapEdgesToNodes({\n          seenPaths\n        })).concat(appendExtraneousChildren({\n          node,\n          seenPaths\n        })).sort(sortAlphabetically).map(augmentNodesWithMetadata({\n          args,\n          currentDepth: node[_depth],\n          nodeResult,\n          seenNodes\n        }));\n      },\n\n      // visit each `node` of the `tree`, returning an `item` - these are\n      // the elements that will be used to build the final output\n      visit(node) {\n        node[_problems] = getProblems(node, {\n          global\n        });\n        const item = json ? getJsonOutputItem(node, {\n          global,\n          long\n        }) : parseable ? null : getHumanOutputItem(node, {\n          args,\n          color,\n          global,\n          long\n        }); // loop through list of node problems to add them to global list\n\n        if (node[_include]) {\n          for (const problem of node[_problems]) problems.add(problem);\n        }\n\n        seenItems.add(item); // return a promise so we don't blow the stack\n\n        return Promise.resolve(item);\n      }\n\n    }); // handle the special case of a broken package.json in the root folder\n\n    const [rootError] = tree.errors.filter(e => e.code === 'EJSONPARSE' && e.path === resolve(path, 'package.json'));\n    this.npm.output(json ? jsonOutput({\n      path,\n      problems,\n      result,\n      rootError,\n      seenItems\n    }) : parseable ? parseableOutput({\n      seenNodes,\n      global,\n      long\n    }) : humanOutput({\n      color,\n      result,\n      seenItems,\n      unicode\n    })); // if filtering items, should exit with error code on no results\n\n    if (result && !result[_include] && args.length) process.exitCode = 1;\n\n    if (rootError) {\n      throw Object.assign(new Error('Failed to parse root package.json'), {\n        code: 'EJSONPARSE'\n      });\n    }\n\n    if (problems.size) {\n      throw Object.assign(new Error([...problems].join(EOL)), {\n        code: 'ELSPROBLEMS'\n      });\n    }\n  }\n\n  async initTree({\n    arb,\n    args\n  }) {\n    const tree = await arb.loadActual();\n    tree[_include] = args.length === 0;\n    tree[_depth] = 0;\n    return tree;\n  }\n\n}\n\nmodule.exports = LS;\n\nconst isGitNode = node => {\n  if (!node.resolved) return;\n\n  try {\n    const {\n      type\n    } = npa(node.resolved);\n    return type === 'git' || type === 'hosted';\n  } catch (err) {\n    return false;\n  }\n};\n\nconst isOptional = node => node[_type] === 'optional' || node[_type] === 'peerOptional';\n\nconst isExtraneous = (node, {\n  global\n}) => node.extraneous && !global;\n\nconst getProblems = (node, {\n  global\n}) => {\n  const problems = new Set();\n  if (node[_missing] && !isOptional(node)) problems.add(`missing: ${node.pkgid}, required by ${node[_missing]}`);\n  if (node[_invalid]) problems.add(`invalid: ${node.pkgid} ${node.path}`);\n  if (isExtraneous(node, {\n    global\n  })) problems.add(`extraneous: ${node.pkgid} ${node.path}`);\n  return problems;\n}; // annotates _parent and _include metadata into the resulting\n// item obj allowing for filtering out results during output\n\n\nconst augmentItemWithIncludeMetadata = (node, item) => {\n  item[_parent] = node[_parent];\n  item[_include] = node[_include]; // append current item to its parent.nodes which is the\n  // structure expected by archy in order to print tree\n\n  if (node[_include]) {\n    // includes all ancestors of included node\n    let p = node[_parent];\n\n    while (p) {\n      p[_include] = true;\n      p = p[_parent];\n    }\n  }\n\n  return item;\n};\n\nconst getHumanOutputItem = (node, {\n  args,\n  color,\n  global,\n  long\n}) => {\n  const {\n    pkgid,\n    path\n  } = node;\n  let printable = pkgid; // special formatting for top-level package name\n\n  if (node.isRoot) {\n    const hasNoPackageJson = !Object.keys(node.package).length;\n    if (hasNoPackageJson || global) printable = path;else printable += `${long ? EOL : ' '}${path}`;\n  }\n\n  const highlightDepName = color && args.length && node[_filteredBy];\n  const missingColor = isOptional(node) ? chalk.yellow.bgBlack : chalk.red.bgBlack;\n  const missingMsg = `UNMET ${isOptional(node) ? 'OPTIONAL ' : ''}DEPENDENCY`;\n  const label = (node[_missing] ? (color ? missingColor(missingMsg) : missingMsg) + ' ' : '') + `${highlightDepName ? chalk.yellow.bgBlack(printable) : printable}` + (node[_dedupe] ? ' ' + (color ? chalk.gray('deduped') : 'deduped') : '') + (node[_invalid] ? ' ' + (color ? chalk.red.bgBlack('invalid') : 'invalid') : '') + (isExtraneous(node, {\n    global\n  }) ? ' ' + (color ? chalk.green.bgBlack('extraneous') : 'extraneous') : '') + (isGitNode(node) ? ` (${node.resolved})` : '') + (node.isLink ? ` -> ${node.realpath}` : '') + (long ? `${EOL}${node.package.description || ''}` : '');\n  return augmentItemWithIncludeMetadata(node, {\n    label,\n    nodes: []\n  });\n};\n\nconst getJsonOutputItem = (node, {\n  global,\n  long\n}) => {\n  const item = {};\n  if (node.version) item.version = node.version;\n  if (node.resolved) item.resolved = node.resolved;\n  item[_name] = node.name; // special formatting for top-level package name\n\n  const hasPackageJson = node && node.package && Object.keys(node.package).length;\n  if (node.isRoot && hasPackageJson) item.name = node.package.name || node.name;\n\n  if (long) {\n    item.name = item[_name];\n    const {\n      dependencies,\n      ...packageInfo\n    } = node.package;\n    Object.assign(item, packageInfo);\n    item.extraneous = false;\n    item.path = node.path;\n    item._dependencies = { ...node.package.dependencies,\n      ...node.package.optionalDependencies\n    };\n    item.devDependencies = node.package.devDependencies || {};\n    item.peerDependencies = node.package.peerDependencies || {};\n  } // augment json output items with extra metadata\n\n\n  if (isExtraneous(node, {\n    global\n  })) item.extraneous = true;\n  if (node[_invalid]) item.invalid = true;\n\n  if (node[_missing] && !isOptional(node)) {\n    item.required = node[_required];\n    item.missing = true;\n  }\n\n  if (node[_include] && node[_problems] && node[_problems].size) item.problems = [...node[_problems]];\n  return augmentItemWithIncludeMetadata(node, item);\n};\n\nconst filterByEdgesTypes = ({\n  dev,\n  development,\n  link,\n  node,\n  prod,\n  production,\n  only,\n  tree\n}) => {\n  // filter deps by type, allows for: `npm ls --dev`, `npm ls --prod`,\n  // `npm ls --link`, `npm ls --only=dev`, etc\n  const filterDev = node === tree && (dev || development || /^dev(elopment)?$/.test(only));\n  const filterProd = node === tree && (prod || production || /^prod(uction)?$/.test(only));\n  const filterLink = node === tree && link;\n  return edge => (filterDev ? edge.dev : true) && (filterProd ? !edge.dev && !edge.peer && !edge.peerOptional : true) && (filterLink ? edge.to && edge.to.isLink : true);\n};\n\nconst appendExtraneousChildren = ({\n  node,\n  seenPaths\n}) => // extraneous children are not represented\n// in edges out, so here we add them to the list:\n[...node.children.values()].filter(i => !seenPaths.has(i.path) && i.extraneous);\n\nconst mapEdgesToNodes = ({\n  seenPaths\n}) => edge => {\n  let node = edge.to; // if the edge is linking to a missing node, we go ahead\n  // and create a new obj that will represent the missing node\n\n  if (edge.missing || edge.optional && !node) {\n    const {\n      name,\n      spec\n    } = edge;\n    const pkgid = `${name}@${spec}`;\n    node = {\n      name,\n      pkgid,\n      [_missing]: edge.from.pkgid\n    };\n  } // keeps track of a set of seen paths to avoid the edge case in which a tree\n  // item would appear twice given that it's a children of an extraneous item,\n  // so it's marked extraneous but it will ALSO show up in edgesOuts of\n  // its parent so it ends up as two diff nodes if we don't track it\n\n\n  if (node.path) seenPaths.add(node.path);\n  node[_required] = edge.spec;\n  node[_type] = edge.type;\n  node[_invalid] = edge.invalid;\n  return node;\n};\n\nconst filterByPositionalArgs = (args, {\n  node\n}) => args.length > 0 ? args.some(spec => node.satisfies && node.satisfies(spec)) : true;\n\nconst augmentNodesWithMetadata = ({\n  args,\n  currentDepth,\n  nodeResult,\n  seenNodes\n}) => node => {\n  // if the original edge was a deduped dep, treeverse will fail to\n  // revisit that node in tree traversal logic, so we make it so that\n  // we have a diff obj for deduped nodes:\n  if (seenNodes.has(node.path)) {\n    node = {\n      name: node.name,\n      version: node.version,\n      pkgid: node.pkgid,\n      package: node.package,\n      path: node.path,\n      isLink: node.isLink,\n      realpath: node.realpath,\n      [_invalid]: node[_invalid],\n      [_missing]: node[_missing],\n      [_dedupe]: true\n    };\n  } else {\n    // keeps track of already seen nodes in order to check for dedupes\n    seenNodes.set(node.path, node);\n  } // _parent is going to be a ref to a treeverse-visited node (returned from\n  // getHumanOutputItem, getJsonOutputItem, etc) so that we have an easy\n  // shortcut to place new nodes in their right place during tree traversal\n\n\n  node[_parent] = nodeResult; // _include is the property that allow us to filter based on position args\n  // e.g: `npm ls foo`, `npm ls simple-output@2`\n  // _filteredBy is used to apply extra color info to the item that\n  // was used in args in order to filter\n\n  node[_filteredBy] = node[_include] = filterByPositionalArgs(args, {\n    node: seenNodes.get(node.path)\n  }); // _depth keeps track of how many levels deep tree traversal currently is\n  // so that we can `npm ls --depth=1`\n\n  node[_depth] = currentDepth + 1;\n  return node;\n};\n\nconst sortAlphabetically = (a, b) => a.pkgid.localeCompare(b.pkgid);\n\nconst humanOutput = ({\n  color,\n  result,\n  seenItems,\n  unicode\n}) => {\n  // we need to traverse the entire tree in order to determine which items\n  // should be included (since a nested transitive included dep will make it\n  // so that all its ancestors should be displayed)\n  // here is where we put items in their expected place for archy output\n  for (const item of seenItems) {\n    if (item[_include] && item[_parent]) item[_parent].nodes.push(item);\n  }\n\n  if (!result.nodes.length) result.nodes = ['(empty)'];\n  const archyOutput = archy(result, '', {\n    unicode\n  });\n  return color ? chalk.reset(archyOutput) : archyOutput;\n};\n\nconst jsonOutput = ({\n  path,\n  problems,\n  result,\n  rootError,\n  seenItems\n}) => {\n  if (problems.size) result.problems = [...problems];\n\n  if (rootError) {\n    result.problems = [...(result.problems || []), ...[`error in ${path}: Failed to parse root package.json`]];\n    result.invalid = true;\n  } // we need to traverse the entire tree in order to determine which items\n  // should be included (since a nested transitive included dep will make it\n  // so that all its ancestors should be displayed)\n  // here is where we put items in their expected place for json output\n\n\n  for (const item of seenItems) {\n    // append current item to its parent item.dependencies obj in order\n    // to provide a json object structure that represents the installed tree\n    if (item[_include] && item[_parent]) {\n      if (!item[_parent].dependencies) item[_parent].dependencies = {};\n      item[_parent].dependencies[item[_name]] = item;\n    }\n  }\n\n  return JSON.stringify(result, null, 2);\n};\n\nconst parseableOutput = ({\n  global,\n  long,\n  seenNodes\n}) => {\n  let out = '';\n\n  for (const node of seenNodes.values()) {\n    if (node.path && node[_include]) {\n      out += node.path;\n\n      if (long) {\n        out += `:${node.pkgid}`;\n        out += node.path !== node.realpath ? `:${node.realpath}` : '';\n        out += isExtraneous(node, {\n          global\n        }) ? ':EXTRANEOUS' : '';\n        out += node[_invalid] ? ':INVALID' : '';\n      }\n\n      out += EOL;\n    }\n  }\n\n  return out.trim();\n};","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/lib/ls.js"],"names":["resolve","require","EOL","archy","chalk","Arborist","breadth","npa","completion","_depth","Symbol","_dedupe","_filteredBy","_include","_invalid","_name","_missing","_parent","_problems","_required","_type","BaseCommand","LS","description","name","usage","opts","npm","exec","args","cb","ls","then","catch","all","config","get","color","depth","dev","development","global","json","link","long","only","parseable","prod","production","unicode","path","globalDir","prefix","arb","flatOptions","legacyPeerDeps","tree","initTree","seenItems","Set","seenNodes","Map","problems","filterDefaultDepth","Infinity","depthToPrint","length","set","result","getChildren","node","nodeResult","seenPaths","shouldSkipChildren","Node","target","edgesOut","values","filter","filterByEdgesTypes","map","mapEdgesToNodes","concat","appendExtraneousChildren","sort","sortAlphabetically","augmentNodesWithMetadata","currentDepth","visit","getProblems","item","getJsonOutputItem","getHumanOutputItem","problem","add","Promise","rootError","errors","e","code","output","jsonOutput","parseableOutput","humanOutput","process","exitCode","Object","assign","Error","size","join","loadActual","module","exports","isGitNode","resolved","type","err","isOptional","isExtraneous","extraneous","pkgid","augmentItemWithIncludeMetadata","p","printable","isRoot","hasNoPackageJson","keys","package","highlightDepName","missingColor","yellow","bgBlack","red","missingMsg","label","gray","green","isLink","realpath","nodes","version","hasPackageJson","dependencies","packageInfo","_dependencies","optionalDependencies","devDependencies","peerDependencies","invalid","required","missing","filterDev","test","filterProd","filterLink","edge","peer","peerOptional","to","children","i","has","optional","spec","from","filterByPositionalArgs","some","satisfies","a","b","localeCompare","push","archyOutput","reset","JSON","stringify","out","trim"],"mappings":"AAAA,MAAM;AAAEA,EAAAA;AAAF,IAAcC,OAAO,CAAC,MAAD,CAA3B;;AACA,MAAM;AAAEC,EAAAA;AAAF,IAAUD,OAAO,CAAC,IAAD,CAAvB;;AAEA,MAAME,KAAK,GAAGF,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMG,KAAK,GAAGH,OAAO,CAAC,OAAD,CAArB;;AACA,MAAMI,QAAQ,GAAGJ,OAAO,CAAC,kBAAD,CAAxB;;AACA,MAAM;AAAEK,EAAAA;AAAF,IAAcL,OAAO,CAAC,WAAD,CAA3B;;AACA,MAAMM,GAAG,GAAGN,OAAO,CAAC,iBAAD,CAAnB;;AAEA,MAAMO,UAAU,GAAGP,OAAO,CAAC,sCAAD,CAA1B;;AAEA,MAAMQ,MAAM,GAAGC,MAAM,CAAC,OAAD,CAArB;;AACA,MAAMC,OAAO,GAAGD,MAAM,CAAC,QAAD,CAAtB;;AACA,MAAME,WAAW,GAAGF,MAAM,CAAC,YAAD,CAA1B;;AACA,MAAMG,QAAQ,GAAGH,MAAM,CAAC,SAAD,CAAvB;;AACA,MAAMI,QAAQ,GAAGJ,MAAM,CAAC,SAAD,CAAvB;;AACA,MAAMK,KAAK,GAAGL,MAAM,CAAC,MAAD,CAApB;;AACA,MAAMM,QAAQ,GAAGN,MAAM,CAAC,SAAD,CAAvB;;AACA,MAAMO,OAAO,GAAGP,MAAM,CAAC,QAAD,CAAtB;;AACA,MAAMQ,SAAS,GAAGR,MAAM,CAAC,UAAD,CAAxB;;AACA,MAAMS,SAAS,GAAGT,MAAM,CAAC,UAAD,CAAxB;;AACA,MAAMU,KAAK,GAAGV,MAAM,CAAC,MAAD,CAApB;;AACA,MAAMW,WAAW,GAAGpB,OAAO,CAAC,mBAAD,CAA3B;;AAEA,MAAMqB,EAAN,SAAiBD,WAAjB,CAA6B;AAC3B;AACsB,aAAXE,WAAW,GAAI;AACxB,WAAO,yBAAP;AACD;AAED;;;AACe,aAAJC,IAAI,GAAI;AACjB,WAAO,IAAP;AACD;AAED;;;AACgB,aAALC,KAAK,GAAI;AAClB,WAAO,CAAC,+BAAD,CAAP;AACD;AAED;;;AACgB,QAAVjB,UAAU,CAAEkB,IAAF,EAAQ;AACtB,WAAOlB,UAAU,CAAC,KAAKmB,GAAN,EAAWD,IAAX,CAAjB;AACD;;AAEDE,EAAAA,IAAI,CAAEC,IAAF,EAAQC,EAAR,EAAY;AACd,SAAKC,EAAL,CAAQF,IAAR,EAAcG,IAAd,CAAmB,MAAMF,EAAE,EAA3B,EAA+BG,KAA/B,CAAqCH,EAArC;AACD;;AAEO,QAAFC,EAAE,CAAEF,IAAF,EAAQ;AACd,UAAMK,GAAG,GAAG,KAAKP,GAAL,CAASQ,MAAT,CAAgBC,GAAhB,CAAoB,KAApB,CAAZ;AACA,UAAMC,KAAK,GAAG,CAAC,CAAC,KAAKV,GAAL,CAASU,KAAzB;AACA,UAAMC,KAAK,GAAG,KAAKX,GAAL,CAASQ,MAAT,CAAgBC,GAAhB,CAAoB,OAApB,CAAd;AACA,UAAMG,GAAG,GAAG,KAAKZ,GAAL,CAASQ,MAAT,CAAgBC,GAAhB,CAAoB,KAApB,CAAZ;AACA,UAAMI,WAAW,GAAG,KAAKb,GAAL,CAASQ,MAAT,CAAgBC,GAAhB,CAAoB,aAApB,CAApB;AACA,UAAMK,MAAM,GAAG,KAAKd,GAAL,CAASQ,MAAT,CAAgBC,GAAhB,CAAoB,QAApB,CAAf;AACA,UAAMM,IAAI,GAAG,KAAKf,GAAL,CAASQ,MAAT,CAAgBC,GAAhB,CAAoB,MAApB,CAAb;AACA,UAAMO,IAAI,GAAG,KAAKhB,GAAL,CAASQ,MAAT,CAAgBC,GAAhB,CAAoB,MAApB,CAAb;AACA,UAAMQ,IAAI,GAAG,KAAKjB,GAAL,CAASQ,MAAT,CAAgBC,GAAhB,CAAoB,MAApB,CAAb;AACA,UAAMS,IAAI,GAAG,KAAKlB,GAAL,CAASQ,MAAT,CAAgBC,GAAhB,CAAoB,MAApB,CAAb;AACA,UAAMU,SAAS,GAAG,KAAKnB,GAAL,CAASQ,MAAT,CAAgBC,GAAhB,CAAoB,WAApB,CAAlB;AACA,UAAMW,IAAI,GAAG,KAAKpB,GAAL,CAASQ,MAAT,CAAgBC,GAAhB,CAAoB,MAApB,CAAb;AACA,UAAMY,UAAU,GAAG,KAAKrB,GAAL,CAASQ,MAAT,CAAgBC,GAAhB,CAAoB,YAApB,CAAnB;AACA,UAAMa,OAAO,GAAG,KAAKtB,GAAL,CAASQ,MAAT,CAAgBC,GAAhB,CAAoB,SAApB,CAAhB;AAEA,UAAMc,IAAI,GAAGT,MAAM,GAAGzC,OAAO,CAAC,KAAK2B,GAAL,CAASwB,SAAV,EAAqB,IAArB,CAAV,GAAuC,KAAKxB,GAAL,CAASyB,MAAnE;AAEA,UAAMC,GAAG,GAAG,IAAIhD,QAAJ,CAAa;AACvBoC,MAAAA,MADuB;AAEvB,SAAG,KAAKd,GAAL,CAAS2B,WAFW;AAGvBC,MAAAA,cAAc,EAAE,KAHO;AAIvBL,MAAAA;AAJuB,KAAb,CAAZ;AAMA,UAAMM,IAAI,GAAG,MAAM,KAAKC,QAAL,CAAc;AAACJ,MAAAA,GAAD;AAAMxB,MAAAA;AAAN,KAAd,CAAnB;AAEA,UAAM6B,SAAS,GAAG,IAAIC,GAAJ,EAAlB;AACA,UAAMC,SAAS,GAAG,IAAIC,GAAJ,EAAlB;AACA,UAAMC,QAAQ,GAAG,IAAIH,GAAJ,EAAjB,CA5Bc,CA8Bd;;AACA,UAAMI,kBAAkB,GAAGzB,KAAK,KAAK,IAAV,GAAiB0B,QAAjB,GAA4B1B,KAAvD;AACA,UAAM2B,YAAY,GAAI/B,GAAG,IAAIL,IAAI,CAACqC,MAAb,GACjBH,kBADiB,GAEhBzB,KAAK,IAAI,CAFd,CAhCc,CAoCd;;AACAsB,IAAAA,SAAS,CAACO,GAAV,CAAcX,IAAI,CAACN,IAAnB,EAAyBM,IAAzB,EArCc,CAuCd;;AACA,UAAMY,MAAM,GAAG,MAAM9D,OAAO,CAAC;AAC3BkD,MAAAA,IAD2B;;AAE3B;AACA;AACA;AACAa,MAAAA,WAAW,CAAEC,IAAF,EAAQC,UAAR,EAAoB;AAC7B,cAAMC,SAAS,GAAG,IAAIb,GAAJ,EAAlB;AACA,cAAMc,kBAAkB,GACtB,EAAEH,IAAI,YAAYjE,QAAQ,CAACqE,IAA3B,KAAqCJ,IAAI,CAAC7D,MAAD,CAAJ,GAAewD,YADtD;AAEA,eAAQQ,kBAAD,GACH,EADG,GAEH,CAAC,GAAG,CAACH,IAAI,CAACK,MAAL,IAAeL,IAAhB,EAAsBM,QAAtB,CAA+BC,MAA/B,EAAJ,EACCC,MADD,CACQC,kBAAkB,CAAC;AACzBxC,UAAAA,GADyB;AAEzBC,UAAAA,WAFyB;AAGzBG,UAAAA,IAHyB;AAIzB2B,UAAAA,IAJyB;AAKzBvB,UAAAA,IALyB;AAMzBC,UAAAA,UANyB;AAOzBH,UAAAA,IAPyB;AAQzBW,UAAAA;AARyB,SAAD,CAD1B,EAWCwB,GAXD,CAWKC,eAAe,CAAC;AAAET,UAAAA;AAAF,SAAD,CAXpB,EAYCU,MAZD,CAYQC,wBAAwB,CAAC;AAAEb,UAAAA,IAAF;AAAQE,UAAAA;AAAR,SAAD,CAZhC,EAaCY,IAbD,CAaMC,kBAbN,EAcCL,GAdD,CAcKM,wBAAwB,CAAC;AAC5BzD,UAAAA,IAD4B;AAE5B0D,UAAAA,YAAY,EAAEjB,IAAI,CAAC7D,MAAD,CAFU;AAG5B8D,UAAAA,UAH4B;AAI5BX,UAAAA;AAJ4B,SAAD,CAd7B,CAFJ;AAsBD,OA/B0B;;AAgC3B;AACA;AACA4B,MAAAA,KAAK,CAAElB,IAAF,EAAQ;AACXA,QAAAA,IAAI,CAACpD,SAAD,CAAJ,GAAkBuE,WAAW,CAACnB,IAAD,EAAO;AAAE7B,UAAAA;AAAF,SAAP,CAA7B;AAEA,cAAMiD,IAAI,GAAGhD,IAAI,GACbiD,iBAAiB,CAACrB,IAAD,EAAO;AAAE7B,UAAAA,MAAF;AAAUG,UAAAA;AAAV,SAAP,CADJ,GAEbE,SAAS,GACP,IADO,GAEP8C,kBAAkB,CAACtB,IAAD,EAAO;AAAEzC,UAAAA,IAAF;AAAQQ,UAAAA,KAAR;AAAeI,UAAAA,MAAf;AAAuBG,UAAAA;AAAvB,SAAP,CAJxB,CAHW,CASX;;AACA,YAAI0B,IAAI,CAACzD,QAAD,CAAR,EAAoB;AAClB,eAAK,MAAMgF,OAAX,IAAsBvB,IAAI,CAACpD,SAAD,CAA1B,EACE4C,QAAQ,CAACgC,GAAT,CAAaD,OAAb;AACH;;AAEDnC,QAAAA,SAAS,CAACoC,GAAV,CAAcJ,IAAd,EAfW,CAiBX;;AACA,eAAOK,OAAO,CAAC/F,OAAR,CAAgB0F,IAAhB,CAAP;AACD;;AArD0B,KAAD,CAA5B,CAxCc,CAgGd;;AACA,UAAM,CAACM,SAAD,IAAcxC,IAAI,CAACyC,MAAL,CAAYnB,MAAZ,CAAmBoB,CAAC,IACtCA,CAAC,CAACC,IAAF,KAAW,YAAX,IAA2BD,CAAC,CAAChD,IAAF,KAAWlD,OAAO,CAACkD,IAAD,EAAO,cAAP,CAD3B,CAApB;AAGA,SAAKvB,GAAL,CAASyE,MAAT,CACE1D,IAAI,GACA2D,UAAU,CAAC;AAAEnD,MAAAA,IAAF;AAAQY,MAAAA,QAAR;AAAkBM,MAAAA,MAAlB;AAA0B4B,MAAAA,SAA1B;AAAqCtC,MAAAA;AAArC,KAAD,CADV,GAEAZ,SAAS,GACPwD,eAAe,CAAC;AAAE1C,MAAAA,SAAF;AAAanB,MAAAA,MAAb;AAAqBG,MAAAA;AAArB,KAAD,CADR,GAEP2D,WAAW,CAAC;AAAElE,MAAAA,KAAF;AAAS+B,MAAAA,MAAT;AAAiBV,MAAAA,SAAjB;AAA4BT,MAAAA;AAA5B,KAAD,CALnB,EApGc,CA4Gd;;AACA,QAAImB,MAAM,IAAI,CAACA,MAAM,CAACvD,QAAD,CAAjB,IAA+BgB,IAAI,CAACqC,MAAxC,EACEsC,OAAO,CAACC,QAAR,GAAmB,CAAnB;;AAEF,QAAIT,SAAJ,EAAe;AACb,YAAMU,MAAM,CAACC,MAAP,CACJ,IAAIC,KAAJ,CAAU,mCAAV,CADI,EAEJ;AAAET,QAAAA,IAAI,EAAE;AAAR,OAFI,CAAN;AAID;;AAED,QAAIrC,QAAQ,CAAC+C,IAAb,EAAmB;AACjB,YAAMH,MAAM,CAACC,MAAP,CACJ,IAAIC,KAAJ,CAAU,CAAC,GAAG9C,QAAJ,EAAcgD,IAAd,CAAmB5G,GAAnB,CAAV,CADI,EAEJ;AAAEiG,QAAAA,IAAI,EAAE;AAAR,OAFI,CAAN;AAID;AACF;;AAEa,QAAR1C,QAAQ,CAAE;AAAEJ,IAAAA,GAAF;AAAOxB,IAAAA;AAAP,GAAF,EAAiB;AAC7B,UAAM2B,IAAI,GAAG,MAAMH,GAAG,CAAC0D,UAAJ,EAAnB;AACAvD,IAAAA,IAAI,CAAC3C,QAAD,CAAJ,GAAiBgB,IAAI,CAACqC,MAAL,KAAgB,CAAjC;AACAV,IAAAA,IAAI,CAAC/C,MAAD,CAAJ,GAAe,CAAf;AAEA,WAAO+C,IAAP;AACD;;AA9J0B;;AAgK7BwD,MAAM,CAACC,OAAP,GAAiB3F,EAAjB;;AAEA,MAAM4F,SAAS,GAAI5C,IAAD,IAAU;AAC1B,MAAI,CAACA,IAAI,CAAC6C,QAAV,EACE;;AAEF,MAAI;AACF,UAAM;AAAEC,MAAAA;AAAF,QAAW7G,GAAG,CAAC+D,IAAI,CAAC6C,QAAN,CAApB;AACA,WAAOC,IAAI,KAAK,KAAT,IAAkBA,IAAI,KAAK,QAAlC;AACD,GAHD,CAGE,OAAOC,GAAP,EAAY;AACZ,WAAO,KAAP;AACD;AACF,CAVD;;AAYA,MAAMC,UAAU,GAAIhD,IAAD,IACjBA,IAAI,CAAClD,KAAD,CAAJ,KAAgB,UAAhB,IAA8BkD,IAAI,CAAClD,KAAD,CAAJ,KAAgB,cADhD;;AAGA,MAAMmG,YAAY,GAAG,CAACjD,IAAD,EAAO;AAAE7B,EAAAA;AAAF,CAAP,KACnB6B,IAAI,CAACkD,UAAL,IAAmB,CAAC/E,MADtB;;AAGA,MAAMgD,WAAW,GAAG,CAACnB,IAAD,EAAO;AAAE7B,EAAAA;AAAF,CAAP,KAAsB;AACxC,QAAMqB,QAAQ,GAAG,IAAIH,GAAJ,EAAjB;AAEA,MAAIW,IAAI,CAACtD,QAAD,CAAJ,IAAkB,CAACsG,UAAU,CAAChD,IAAD,CAAjC,EACER,QAAQ,CAACgC,GAAT,CAAc,YAAWxB,IAAI,CAACmD,KAAM,iBAAgBnD,IAAI,CAACtD,QAAD,CAAW,EAAnE;AAEF,MAAIsD,IAAI,CAACxD,QAAD,CAAR,EACEgD,QAAQ,CAACgC,GAAT,CAAc,YAAWxB,IAAI,CAACmD,KAAM,IAAGnD,IAAI,CAACpB,IAAK,EAAjD;AAEF,MAAIqE,YAAY,CAACjD,IAAD,EAAO;AAAE7B,IAAAA;AAAF,GAAP,CAAhB,EACEqB,QAAQ,CAACgC,GAAT,CAAc,eAAcxB,IAAI,CAACmD,KAAM,IAAGnD,IAAI,CAACpB,IAAK,EAApD;AAEF,SAAOY,QAAP;AACD,CAbD,C,CAeA;AACA;;;AACA,MAAM4D,8BAA8B,GAAG,CAACpD,IAAD,EAAOoB,IAAP,KAAgB;AACrDA,EAAAA,IAAI,CAACzE,OAAD,CAAJ,GAAgBqD,IAAI,CAACrD,OAAD,CAApB;AACAyE,EAAAA,IAAI,CAAC7E,QAAD,CAAJ,GAAiByD,IAAI,CAACzD,QAAD,CAArB,CAFqD,CAIrD;AACA;;AACA,MAAIyD,IAAI,CAACzD,QAAD,CAAR,EAAoB;AAClB;AACA,QAAI8G,CAAC,GAAGrD,IAAI,CAACrD,OAAD,CAAZ;;AACA,WAAO0G,CAAP,EAAU;AACRA,MAAAA,CAAC,CAAC9G,QAAD,CAAD,GAAc,IAAd;AACA8G,MAAAA,CAAC,GAAGA,CAAC,CAAC1G,OAAD,CAAL;AACD;AACF;;AAED,SAAOyE,IAAP;AACD,CAhBD;;AAkBA,MAAME,kBAAkB,GAAG,CAACtB,IAAD,EAAO;AAAEzC,EAAAA,IAAF;AAAQQ,EAAAA,KAAR;AAAeI,EAAAA,MAAf;AAAuBG,EAAAA;AAAvB,CAAP,KAAyC;AAClE,QAAM;AAAE6E,IAAAA,KAAF;AAASvE,IAAAA;AAAT,MAAkBoB,IAAxB;AACA,MAAIsD,SAAS,GAAGH,KAAhB,CAFkE,CAIlE;;AACA,MAAInD,IAAI,CAACuD,MAAT,EAAiB;AACf,UAAMC,gBAAgB,GAAG,CAACpB,MAAM,CAACqB,IAAP,CAAYzD,IAAI,CAAC0D,OAAjB,EAA0B9D,MAApD;AACA,QAAI4D,gBAAgB,IAAIrF,MAAxB,EACEmF,SAAS,GAAG1E,IAAZ,CADF,KAGE0E,SAAS,IAAK,GAAEhF,IAAI,GAAG1C,GAAH,GAAS,GAAI,GAAEgD,IAAK,EAAxC;AACH;;AAED,QAAM+E,gBAAgB,GACpB5F,KAAK,IAAIR,IAAI,CAACqC,MAAd,IAAwBI,IAAI,CAAC1D,WAAD,CAD9B;AAEA,QAAMsH,YAAY,GAAGZ,UAAU,CAAChD,IAAD,CAAV,GACjBlE,KAAK,CAAC+H,MAAN,CAAaC,OADI,GAEjBhI,KAAK,CAACiI,GAAN,CAAUD,OAFd;AAGA,QAAME,UAAU,GAAI,SAAQhB,UAAU,CAAChD,IAAD,CAAV,GAAmB,WAAnB,GAAiC,EAAG,YAAhE;AACA,QAAMiE,KAAK,GACT,CACEjE,IAAI,CAACtD,QAAD,CAAJ,GACI,CAACqB,KAAK,GAAG6F,YAAY,CAACI,UAAD,CAAf,GAA8BA,UAApC,IAAkD,GADtD,GAEI,EAHN,IAKC,GAAEL,gBAAgB,GAAG7H,KAAK,CAAC+H,MAAN,CAAaC,OAAb,CAAqBR,SAArB,CAAH,GAAqCA,SAAU,EALlE,IAOEtD,IAAI,CAAC3D,OAAD,CAAJ,GACI,OAAO0B,KAAK,GAAGjC,KAAK,CAACoI,IAAN,CAAW,SAAX,CAAH,GAA2B,SAAvC,CADJ,GAEI,EATN,KAYElE,IAAI,CAACxD,QAAD,CAAJ,GACI,OAAOuB,KAAK,GAAGjC,KAAK,CAACiI,GAAN,CAAUD,OAAV,CAAkB,SAAlB,CAAH,GAAkC,SAA9C,CADJ,GAEI,EAdN,KAiBEb,YAAY,CAACjD,IAAD,EAAO;AAAE7B,IAAAA;AAAF,GAAP,CAAZ,GACI,OAAOJ,KAAK,GAAGjC,KAAK,CAACqI,KAAN,CAAYL,OAAZ,CAAoB,YAApB,CAAH,GAAuC,YAAnD,CADJ,GAEI,EAnBN,KAqBClB,SAAS,CAAC5C,IAAD,CAAT,GAAmB,KAAIA,IAAI,CAAC6C,QAAS,GAArC,GAA0C,EArB3C,KAsBC7C,IAAI,CAACoE,MAAL,GAAe,OAAMpE,IAAI,CAACqE,QAAS,EAAnC,GAAuC,EAtBxC,KAuBC/F,IAAI,GAAI,GAAE1C,GAAI,GAAEoE,IAAI,CAAC0D,OAAL,CAAazG,WAAb,IAA4B,EAAG,EAA3C,GAA+C,EAvBpD,CADF;AA0BA,SAAOmG,8BAA8B,CAACpD,IAAD,EAAO;AAAEiE,IAAAA,KAAF;AAASK,IAAAA,KAAK,EAAE;AAAhB,GAAP,CAArC;AACD,CA9CD;;AAgDA,MAAMjD,iBAAiB,GAAG,CAACrB,IAAD,EAAO;AAAE7B,EAAAA,MAAF;AAAUG,EAAAA;AAAV,CAAP,KAA4B;AACpD,QAAM8C,IAAI,GAAG,EAAb;AAEA,MAAIpB,IAAI,CAACuE,OAAT,EACEnD,IAAI,CAACmD,OAAL,GAAevE,IAAI,CAACuE,OAApB;AAEF,MAAIvE,IAAI,CAAC6C,QAAT,EACEzB,IAAI,CAACyB,QAAL,GAAgB7C,IAAI,CAAC6C,QAArB;AAEFzB,EAAAA,IAAI,CAAC3E,KAAD,CAAJ,GAAcuD,IAAI,CAAC9C,IAAnB,CAToD,CAWpD;;AACA,QAAMsH,cAAc,GAClBxE,IAAI,IAAIA,IAAI,CAAC0D,OAAb,IAAwBtB,MAAM,CAACqB,IAAP,CAAYzD,IAAI,CAAC0D,OAAjB,EAA0B9D,MADpD;AAEA,MAAII,IAAI,CAACuD,MAAL,IAAeiB,cAAnB,EACEpD,IAAI,CAAClE,IAAL,GAAY8C,IAAI,CAAC0D,OAAL,CAAaxG,IAAb,IAAqB8C,IAAI,CAAC9C,IAAtC;;AAEF,MAAIoB,IAAJ,EAAU;AACR8C,IAAAA,IAAI,CAAClE,IAAL,GAAYkE,IAAI,CAAC3E,KAAD,CAAhB;AACA,UAAM;AAAEgI,MAAAA,YAAF;AAAgB,SAAGC;AAAnB,QAAmC1E,IAAI,CAAC0D,OAA9C;AACAtB,IAAAA,MAAM,CAACC,MAAP,CAAcjB,IAAd,EAAoBsD,WAApB;AACAtD,IAAAA,IAAI,CAAC8B,UAAL,GAAkB,KAAlB;AACA9B,IAAAA,IAAI,CAACxC,IAAL,GAAYoB,IAAI,CAACpB,IAAjB;AACAwC,IAAAA,IAAI,CAACuD,aAAL,GAAqB,EACnB,GAAG3E,IAAI,CAAC0D,OAAL,CAAae,YADG;AAEnB,SAAGzE,IAAI,CAAC0D,OAAL,CAAakB;AAFG,KAArB;AAIAxD,IAAAA,IAAI,CAACyD,eAAL,GAAuB7E,IAAI,CAAC0D,OAAL,CAAamB,eAAb,IAAgC,EAAvD;AACAzD,IAAAA,IAAI,CAAC0D,gBAAL,GAAwB9E,IAAI,CAAC0D,OAAL,CAAaoB,gBAAb,IAAiC,EAAzD;AACD,GA7BmD,CA+BpD;;;AACA,MAAI7B,YAAY,CAACjD,IAAD,EAAO;AAAE7B,IAAAA;AAAF,GAAP,CAAhB,EACEiD,IAAI,CAAC8B,UAAL,GAAkB,IAAlB;AAEF,MAAIlD,IAAI,CAACxD,QAAD,CAAR,EACE4E,IAAI,CAAC2D,OAAL,GAAe,IAAf;;AAEF,MAAI/E,IAAI,CAACtD,QAAD,CAAJ,IAAkB,CAACsG,UAAU,CAAChD,IAAD,CAAjC,EAAyC;AACvCoB,IAAAA,IAAI,CAAC4D,QAAL,GAAgBhF,IAAI,CAACnD,SAAD,CAApB;AACAuE,IAAAA,IAAI,CAAC6D,OAAL,GAAe,IAAf;AACD;;AACD,MAAIjF,IAAI,CAACzD,QAAD,CAAJ,IAAkByD,IAAI,CAACpD,SAAD,CAAtB,IAAqCoD,IAAI,CAACpD,SAAD,CAAJ,CAAgB2F,IAAzD,EACEnB,IAAI,CAAC5B,QAAL,GAAgB,CAAC,GAAGQ,IAAI,CAACpD,SAAD,CAAR,CAAhB;AAEF,SAAOwG,8BAA8B,CAACpD,IAAD,EAAOoB,IAAP,CAArC;AACD,CA9CD;;AAgDA,MAAMX,kBAAkB,GAAG,CAAC;AAC1BxC,EAAAA,GAD0B;AAE1BC,EAAAA,WAF0B;AAG1BG,EAAAA,IAH0B;AAI1B2B,EAAAA,IAJ0B;AAK1BvB,EAAAA,IAL0B;AAM1BC,EAAAA,UAN0B;AAO1BH,EAAAA,IAP0B;AAQ1BW,EAAAA;AAR0B,CAAD,KASrB;AACJ;AACA;AACA,QAAMgG,SAAS,GAAGlF,IAAI,KAAKd,IAAT,KACfjB,GAAG,IAAIC,WAAP,IAAsB,mBAAmBiH,IAAnB,CAAwB5G,IAAxB,CADP,CAAlB;AAEA,QAAM6G,UAAU,GAAGpF,IAAI,KAAKd,IAAT,KAChBT,IAAI,IAAIC,UAAR,IAAsB,kBAAkByG,IAAlB,CAAuB5G,IAAvB,CADN,CAAnB;AAEA,QAAM8G,UAAU,GAAGrF,IAAI,KAAKd,IAAT,IAAiBb,IAApC;AAEA,SAAQiH,IAAD,IACL,CAACJ,SAAS,GAAGI,IAAI,CAACrH,GAAR,GAAc,IAAxB,MACCmH,UAAU,GAAI,CAACE,IAAI,CAACrH,GAAN,IAAa,CAACqH,IAAI,CAACC,IAAnB,IAA2B,CAACD,IAAI,CAACE,YAArC,GAAqD,IADhE,MAECH,UAAU,GAAIC,IAAI,CAACG,EAAL,IAAWH,IAAI,CAACG,EAAL,CAAQrB,MAAvB,GAAiC,IAF5C,CADF;AAID,CAtBD;;AAwBA,MAAMvD,wBAAwB,GAAG,CAAC;AAAEb,EAAAA,IAAF;AAAQE,EAAAA;AAAR,CAAD,KAC/B;AACA;AACA,CAAC,GAAGF,IAAI,CAAC0F,QAAL,CAAcnF,MAAd,EAAJ,EACGC,MADH,CACUmF,CAAC,IAAI,CAACzF,SAAS,CAAC0F,GAAV,CAAcD,CAAC,CAAC/G,IAAhB,CAAD,IAA0B+G,CAAC,CAACzC,UAD3C,CAHF;;AAMA,MAAMvC,eAAe,GAAG,CAAC;AAAET,EAAAA;AAAF,CAAD,KAAoBoF,IAAD,IAAU;AACnD,MAAItF,IAAI,GAAGsF,IAAI,CAACG,EAAhB,CADmD,CAGnD;AACA;;AACA,MAAIH,IAAI,CAACL,OAAL,IAAiBK,IAAI,CAACO,QAAL,IAAiB,CAAC7F,IAAvC,EAA8C;AAC5C,UAAM;AAAE9C,MAAAA,IAAF;AAAQ4I,MAAAA;AAAR,QAAiBR,IAAvB;AACA,UAAMnC,KAAK,GAAI,GAAEjG,IAAK,IAAG4I,IAAK,EAA9B;AACA9F,IAAAA,IAAI,GAAG;AAAE9C,MAAAA,IAAF;AAAQiG,MAAAA,KAAR;AAAe,OAACzG,QAAD,GAAY4I,IAAI,CAACS,IAAL,CAAU5C;AAArC,KAAP;AACD,GATkD,CAWnD;AACA;AACA;AACA;;;AACA,MAAInD,IAAI,CAACpB,IAAT,EACEsB,SAAS,CAACsB,GAAV,CAAcxB,IAAI,CAACpB,IAAnB;AAEFoB,EAAAA,IAAI,CAACnD,SAAD,CAAJ,GAAkByI,IAAI,CAACQ,IAAvB;AACA9F,EAAAA,IAAI,CAAClD,KAAD,CAAJ,GAAcwI,IAAI,CAACxC,IAAnB;AACA9C,EAAAA,IAAI,CAACxD,QAAD,CAAJ,GAAiB8I,IAAI,CAACP,OAAtB;AAEA,SAAO/E,IAAP;AACD,CAvBD;;AAyBA,MAAMgG,sBAAsB,GAAG,CAACzI,IAAD,EAAO;AAAEyC,EAAAA;AAAF,CAAP,KAC7BzC,IAAI,CAACqC,MAAL,GAAc,CAAd,GAAkBrC,IAAI,CAAC0I,IAAL,CACfH,IAAD,IAAW9F,IAAI,CAACkG,SAAL,IAAkBlG,IAAI,CAACkG,SAAL,CAAeJ,IAAf,CADb,CAAlB,GAEI,IAHN;;AAKA,MAAM9E,wBAAwB,GAAG,CAAC;AAChCzD,EAAAA,IADgC;AAEhC0D,EAAAA,YAFgC;AAGhChB,EAAAA,UAHgC;AAIhCX,EAAAA;AAJgC,CAAD,KAK1BU,IAAD,IAAU;AACd;AACA;AACA;AACA,MAAIV,SAAS,CAACsG,GAAV,CAAc5F,IAAI,CAACpB,IAAnB,CAAJ,EAA8B;AAC5BoB,IAAAA,IAAI,GAAG;AACL9C,MAAAA,IAAI,EAAE8C,IAAI,CAAC9C,IADN;AAELqH,MAAAA,OAAO,EAAEvE,IAAI,CAACuE,OAFT;AAGLpB,MAAAA,KAAK,EAAEnD,IAAI,CAACmD,KAHP;AAILO,MAAAA,OAAO,EAAE1D,IAAI,CAAC0D,OAJT;AAKL9E,MAAAA,IAAI,EAAEoB,IAAI,CAACpB,IALN;AAMLwF,MAAAA,MAAM,EAAEpE,IAAI,CAACoE,MANR;AAOLC,MAAAA,QAAQ,EAAErE,IAAI,CAACqE,QAPV;AAQL,OAAC7H,QAAD,GAAYwD,IAAI,CAACxD,QAAD,CARX;AASL,OAACE,QAAD,GAAYsD,IAAI,CAACtD,QAAD,CATX;AAUL,OAACL,OAAD,GAAW;AAVN,KAAP;AAYD,GAbD,MAaO;AACL;AACAiD,IAAAA,SAAS,CAACO,GAAV,CAAcG,IAAI,CAACpB,IAAnB,EAAyBoB,IAAzB;AACD,GApBa,CAsBd;AACA;AACA;;;AACAA,EAAAA,IAAI,CAACrD,OAAD,CAAJ,GAAgBsD,UAAhB,CAzBc,CA0Bd;AACA;AACA;AACA;;AACAD,EAAAA,IAAI,CAAC1D,WAAD,CAAJ,GAAoB0D,IAAI,CAACzD,QAAD,CAAJ,GAClByJ,sBAAsB,CAACzI,IAAD,EAAO;AAAEyC,IAAAA,IAAI,EAAEV,SAAS,CAACxB,GAAV,CAAckC,IAAI,CAACpB,IAAnB;AAAR,GAAP,CADxB,CA9Bc,CAgCd;AACA;;AACAoB,EAAAA,IAAI,CAAC7D,MAAD,CAAJ,GAAe8E,YAAY,GAAG,CAA9B;AAEA,SAAOjB,IAAP;AACD,CA1CD;;AA4CA,MAAMe,kBAAkB,GAAG,CAACoF,CAAD,EAAIC,CAAJ,KACzBD,CAAC,CAAChD,KAAF,CAAQkD,aAAR,CAAsBD,CAAC,CAACjD,KAAxB,CADF;;AAGA,MAAMlB,WAAW,GAAG,CAAC;AAAElE,EAAAA,KAAF;AAAS+B,EAAAA,MAAT;AAAiBV,EAAAA,SAAjB;AAA4BT,EAAAA;AAA5B,CAAD,KAA2C;AAC7D;AACA;AACA;AACA;AACA,OAAK,MAAMyC,IAAX,IAAmBhC,SAAnB,EAA8B;AAC5B,QAAIgC,IAAI,CAAC7E,QAAD,CAAJ,IAAkB6E,IAAI,CAACzE,OAAD,CAA1B,EACEyE,IAAI,CAACzE,OAAD,CAAJ,CAAc2H,KAAd,CAAoBgC,IAApB,CAAyBlF,IAAzB;AACH;;AAED,MAAI,CAACtB,MAAM,CAACwE,KAAP,CAAa1E,MAAlB,EACEE,MAAM,CAACwE,KAAP,GAAe,CAAC,SAAD,CAAf;AAEF,QAAMiC,WAAW,GAAG1K,KAAK,CAACiE,MAAD,EAAS,EAAT,EAAa;AAAEnB,IAAAA;AAAF,GAAb,CAAzB;AACA,SAAOZ,KAAK,GAAGjC,KAAK,CAAC0K,KAAN,CAAYD,WAAZ,CAAH,GAA8BA,WAA1C;AACD,CAfD;;AAiBA,MAAMxE,UAAU,GAAG,CAAC;AAAEnD,EAAAA,IAAF;AAAQY,EAAAA,QAAR;AAAkBM,EAAAA,MAAlB;AAA0B4B,EAAAA,SAA1B;AAAqCtC,EAAAA;AAArC,CAAD,KAAsD;AACvE,MAAII,QAAQ,CAAC+C,IAAb,EACEzC,MAAM,CAACN,QAAP,GAAkB,CAAC,GAAGA,QAAJ,CAAlB;;AAEF,MAAIkC,SAAJ,EAAe;AACb5B,IAAAA,MAAM,CAACN,QAAP,GAAkB,CAChB,IAAIM,MAAM,CAACN,QAAP,IAAmB,EAAvB,CADgB,EAEhB,GAAG,CAAE,YAAWZ,IAAK,qCAAlB,CAFa,CAAlB;AAIAkB,IAAAA,MAAM,CAACiF,OAAP,GAAiB,IAAjB;AACD,GAVsE,CAYvE;AACA;AACA;AACA;;;AACA,OAAK,MAAM3D,IAAX,IAAmBhC,SAAnB,EAA8B;AAC5B;AACA;AACA,QAAIgC,IAAI,CAAC7E,QAAD,CAAJ,IAAkB6E,IAAI,CAACzE,OAAD,CAA1B,EAAqC;AACnC,UAAI,CAACyE,IAAI,CAACzE,OAAD,CAAJ,CAAc8H,YAAnB,EACErD,IAAI,CAACzE,OAAD,CAAJ,CAAc8H,YAAd,GAA6B,EAA7B;AAEFrD,MAAAA,IAAI,CAACzE,OAAD,CAAJ,CAAc8H,YAAd,CAA2BrD,IAAI,CAAC3E,KAAD,CAA/B,IAA0C2E,IAA1C;AACD;AACF;;AAED,SAAOqF,IAAI,CAACC,SAAL,CAAe5G,MAAf,EAAuB,IAAvB,EAA6B,CAA7B,CAAP;AACD,CA5BD;;AA8BA,MAAMkC,eAAe,GAAG,CAAC;AAAE7D,EAAAA,MAAF;AAAUG,EAAAA,IAAV;AAAgBgB,EAAAA;AAAhB,CAAD,KAAiC;AACvD,MAAIqH,GAAG,GAAG,EAAV;;AACA,OAAK,MAAM3G,IAAX,IAAmBV,SAAS,CAACiB,MAAV,EAAnB,EAAuC;AACrC,QAAIP,IAAI,CAACpB,IAAL,IAAaoB,IAAI,CAACzD,QAAD,CAArB,EAAiC;AAC/BoK,MAAAA,GAAG,IAAI3G,IAAI,CAACpB,IAAZ;;AACA,UAAIN,IAAJ,EAAU;AACRqI,QAAAA,GAAG,IAAK,IAAG3G,IAAI,CAACmD,KAAM,EAAtB;AACAwD,QAAAA,GAAG,IAAI3G,IAAI,CAACpB,IAAL,KAAcoB,IAAI,CAACqE,QAAnB,GAA+B,IAAGrE,IAAI,CAACqE,QAAS,EAAhD,GAAoD,EAA3D;AACAsC,QAAAA,GAAG,IAAI1D,YAAY,CAACjD,IAAD,EAAO;AAAE7B,UAAAA;AAAF,SAAP,CAAZ,GAAiC,aAAjC,GAAiD,EAAxD;AACAwI,QAAAA,GAAG,IAAI3G,IAAI,CAACxD,QAAD,CAAJ,GAAiB,UAAjB,GAA8B,EAArC;AACD;;AACDmK,MAAAA,GAAG,IAAI/K,GAAP;AACD;AACF;;AACD,SAAO+K,GAAG,CAACC,IAAJ,EAAP;AACD,CAfD","sourcesContent":["const { resolve } = require('path')\nconst { EOL } = require('os')\n\nconst archy = require('archy')\nconst chalk = require('chalk')\nconst Arborist = require('@npmcli/arborist')\nconst { breadth } = require('treeverse')\nconst npa = require('npm-package-arg')\n\nconst completion = require('./utils/completion/installed-deep.js')\n\nconst _depth = Symbol('depth')\nconst _dedupe = Symbol('dedupe')\nconst _filteredBy = Symbol('filteredBy')\nconst _include = Symbol('include')\nconst _invalid = Symbol('invalid')\nconst _name = Symbol('name')\nconst _missing = Symbol('missing')\nconst _parent = Symbol('parent')\nconst _problems = Symbol('problems')\nconst _required = Symbol('required')\nconst _type = Symbol('type')\nconst BaseCommand = require('./base-command.js')\n\nclass LS extends BaseCommand {\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get description () {\n    return 'List installed packages'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get name () {\n    return 'ls'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get usage () {\n    return ['npm ls [[<@scope>/]<pkg> ...]']\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  async completion (opts) {\n    return completion(this.npm, opts)\n  }\n\n  exec (args, cb) {\n    this.ls(args).then(() => cb()).catch(cb)\n  }\n\n  async ls (args) {\n    const all = this.npm.config.get('all')\n    const color = !!this.npm.color\n    const depth = this.npm.config.get('depth')\n    const dev = this.npm.config.get('dev')\n    const development = this.npm.config.get('development')\n    const global = this.npm.config.get('global')\n    const json = this.npm.config.get('json')\n    const link = this.npm.config.get('link')\n    const long = this.npm.config.get('long')\n    const only = this.npm.config.get('only')\n    const parseable = this.npm.config.get('parseable')\n    const prod = this.npm.config.get('prod')\n    const production = this.npm.config.get('production')\n    const unicode = this.npm.config.get('unicode')\n\n    const path = global ? resolve(this.npm.globalDir, '..') : this.npm.prefix\n\n    const arb = new Arborist({\n      global,\n      ...this.npm.flatOptions,\n      legacyPeerDeps: false,\n      path,\n    })\n    const tree = await this.initTree({arb, args })\n\n    const seenItems = new Set()\n    const seenNodes = new Map()\n    const problems = new Set()\n\n    // defines special handling of printed depth when filtering with args\n    const filterDefaultDepth = depth === null ? Infinity : depth\n    const depthToPrint = (all || args.length)\n      ? filterDefaultDepth\n      : (depth || 0)\n\n    // add root node of tree to list of seenNodes\n    seenNodes.set(tree.path, tree)\n\n    // tree traversal happens here, using treeverse.breadth\n    const result = await breadth({\n      tree,\n      // recursive method, `node` is going to be the current elem (starting from\n      // the `tree` obj) that was just visited in the `visit` method below\n      // `nodeResult` is going to be the returned `item` from `visit`\n      getChildren (node, nodeResult) {\n        const seenPaths = new Set()\n        const shouldSkipChildren =\n          !(node instanceof Arborist.Node) || (node[_depth] > depthToPrint)\n        return (shouldSkipChildren)\n          ? []\n          : [...(node.target || node).edgesOut.values()]\n            .filter(filterByEdgesTypes({\n              dev,\n              development,\n              link,\n              node,\n              prod,\n              production,\n              only,\n              tree,\n            }))\n            .map(mapEdgesToNodes({ seenPaths }))\n            .concat(appendExtraneousChildren({ node, seenPaths }))\n            .sort(sortAlphabetically)\n            .map(augmentNodesWithMetadata({\n              args,\n              currentDepth: node[_depth],\n              nodeResult,\n              seenNodes,\n            }))\n      },\n      // visit each `node` of the `tree`, returning an `item` - these are\n      // the elements that will be used to build the final output\n      visit (node) {\n        node[_problems] = getProblems(node, { global })\n\n        const item = json\n          ? getJsonOutputItem(node, { global, long })\n          : parseable\n            ? null\n            : getHumanOutputItem(node, { args, color, global, long })\n\n        // loop through list of node problems to add them to global list\n        if (node[_include]) {\n          for (const problem of node[_problems])\n            problems.add(problem)\n        }\n\n        seenItems.add(item)\n\n        // return a promise so we don't blow the stack\n        return Promise.resolve(item)\n      },\n    })\n\n    // handle the special case of a broken package.json in the root folder\n    const [rootError] = tree.errors.filter(e =>\n      e.code === 'EJSONPARSE' && e.path === resolve(path, 'package.json'))\n\n    this.npm.output(\n      json\n        ? jsonOutput({ path, problems, result, rootError, seenItems })\n        : parseable\n          ? parseableOutput({ seenNodes, global, long })\n          : humanOutput({ color, result, seenItems, unicode })\n    )\n\n    // if filtering items, should exit with error code on no results\n    if (result && !result[_include] && args.length)\n      process.exitCode = 1\n\n    if (rootError) {\n      throw Object.assign(\n        new Error('Failed to parse root package.json'),\n        { code: 'EJSONPARSE' }\n      )\n    }\n\n    if (problems.size) {\n      throw Object.assign(\n        new Error([...problems].join(EOL)),\n        { code: 'ELSPROBLEMS' }\n      )\n    }\n  }\n\n  async initTree ({ arb, args }) {\n    const tree = await arb.loadActual()\n    tree[_include] = args.length === 0\n    tree[_depth] = 0\n\n    return tree\n  }\n}\nmodule.exports = LS\n\nconst isGitNode = (node) => {\n  if (!node.resolved)\n    return\n\n  try {\n    const { type } = npa(node.resolved)\n    return type === 'git' || type === 'hosted'\n  } catch (err) {\n    return false\n  }\n}\n\nconst isOptional = (node) =>\n  node[_type] === 'optional' || node[_type] === 'peerOptional'\n\nconst isExtraneous = (node, { global }) =>\n  node.extraneous && !global\n\nconst getProblems = (node, { global }) => {\n  const problems = new Set()\n\n  if (node[_missing] && !isOptional(node))\n    problems.add(`missing: ${node.pkgid}, required by ${node[_missing]}`)\n\n  if (node[_invalid])\n    problems.add(`invalid: ${node.pkgid} ${node.path}`)\n\n  if (isExtraneous(node, { global }))\n    problems.add(`extraneous: ${node.pkgid} ${node.path}`)\n\n  return problems\n}\n\n// annotates _parent and _include metadata into the resulting\n// item obj allowing for filtering out results during output\nconst augmentItemWithIncludeMetadata = (node, item) => {\n  item[_parent] = node[_parent]\n  item[_include] = node[_include]\n\n  // append current item to its parent.nodes which is the\n  // structure expected by archy in order to print tree\n  if (node[_include]) {\n    // includes all ancestors of included node\n    let p = node[_parent]\n    while (p) {\n      p[_include] = true\n      p = p[_parent]\n    }\n  }\n\n  return item\n}\n\nconst getHumanOutputItem = (node, { args, color, global, long }) => {\n  const { pkgid, path } = node\n  let printable = pkgid\n\n  // special formatting for top-level package name\n  if (node.isRoot) {\n    const hasNoPackageJson = !Object.keys(node.package).length\n    if (hasNoPackageJson || global)\n      printable = path\n    else\n      printable += `${long ? EOL : ' '}${path}`\n  }\n\n  const highlightDepName =\n    color && args.length && node[_filteredBy]\n  const missingColor = isOptional(node)\n    ? chalk.yellow.bgBlack\n    : chalk.red.bgBlack\n  const missingMsg = `UNMET ${isOptional(node) ? 'OPTIONAL ' : ''}DEPENDENCY`\n  const label =\n    (\n      node[_missing]\n        ? (color ? missingColor(missingMsg) : missingMsg) + ' '\n        : ''\n    ) +\n    `${highlightDepName ? chalk.yellow.bgBlack(printable) : printable}` +\n    (\n      node[_dedupe]\n        ? ' ' + (color ? chalk.gray('deduped') : 'deduped')\n        : ''\n    ) +\n    (\n      node[_invalid]\n        ? ' ' + (color ? chalk.red.bgBlack('invalid') : 'invalid')\n        : ''\n    ) +\n    (\n      isExtraneous(node, { global })\n        ? ' ' + (color ? chalk.green.bgBlack('extraneous') : 'extraneous')\n        : ''\n    ) +\n    (isGitNode(node) ? ` (${node.resolved})` : '') +\n    (node.isLink ? ` -> ${node.realpath}` : '') +\n    (long ? `${EOL}${node.package.description || ''}` : '')\n\n  return augmentItemWithIncludeMetadata(node, { label, nodes: [] })\n}\n\nconst getJsonOutputItem = (node, { global, long }) => {\n  const item = {}\n\n  if (node.version)\n    item.version = node.version\n\n  if (node.resolved)\n    item.resolved = node.resolved\n\n  item[_name] = node.name\n\n  // special formatting for top-level package name\n  const hasPackageJson =\n    node && node.package && Object.keys(node.package).length\n  if (node.isRoot && hasPackageJson)\n    item.name = node.package.name || node.name\n\n  if (long) {\n    item.name = item[_name]\n    const { dependencies, ...packageInfo } = node.package\n    Object.assign(item, packageInfo)\n    item.extraneous = false\n    item.path = node.path\n    item._dependencies = {\n      ...node.package.dependencies,\n      ...node.package.optionalDependencies,\n    }\n    item.devDependencies = node.package.devDependencies || {}\n    item.peerDependencies = node.package.peerDependencies || {}\n  }\n\n  // augment json output items with extra metadata\n  if (isExtraneous(node, { global }))\n    item.extraneous = true\n\n  if (node[_invalid])\n    item.invalid = true\n\n  if (node[_missing] && !isOptional(node)) {\n    item.required = node[_required]\n    item.missing = true\n  }\n  if (node[_include] && node[_problems] && node[_problems].size)\n    item.problems = [...node[_problems]]\n\n  return augmentItemWithIncludeMetadata(node, item)\n}\n\nconst filterByEdgesTypes = ({\n  dev,\n  development,\n  link,\n  node,\n  prod,\n  production,\n  only,\n  tree,\n}) => {\n  // filter deps by type, allows for: `npm ls --dev`, `npm ls --prod`,\n  // `npm ls --link`, `npm ls --only=dev`, etc\n  const filterDev = node === tree &&\n    (dev || development || /^dev(elopment)?$/.test(only))\n  const filterProd = node === tree &&\n    (prod || production || /^prod(uction)?$/.test(only))\n  const filterLink = node === tree && link\n\n  return (edge) =>\n    (filterDev ? edge.dev : true) &&\n    (filterProd ? (!edge.dev && !edge.peer && !edge.peerOptional) : true) &&\n    (filterLink ? (edge.to && edge.to.isLink) : true)\n}\n\nconst appendExtraneousChildren = ({ node, seenPaths }) =>\n  // extraneous children are not represented\n  // in edges out, so here we add them to the list:\n  [...node.children.values()]\n    .filter(i => !seenPaths.has(i.path) && i.extraneous)\n\nconst mapEdgesToNodes = ({ seenPaths }) => (edge) => {\n  let node = edge.to\n\n  // if the edge is linking to a missing node, we go ahead\n  // and create a new obj that will represent the missing node\n  if (edge.missing || (edge.optional && !node)) {\n    const { name, spec } = edge\n    const pkgid = `${name}@${spec}`\n    node = { name, pkgid, [_missing]: edge.from.pkgid }\n  }\n\n  // keeps track of a set of seen paths to avoid the edge case in which a tree\n  // item would appear twice given that it's a children of an extraneous item,\n  // so it's marked extraneous but it will ALSO show up in edgesOuts of\n  // its parent so it ends up as two diff nodes if we don't track it\n  if (node.path)\n    seenPaths.add(node.path)\n\n  node[_required] = edge.spec\n  node[_type] = edge.type\n  node[_invalid] = edge.invalid\n\n  return node\n}\n\nconst filterByPositionalArgs = (args, { node }) =>\n  args.length > 0 ? args.some(\n    (spec) => (node.satisfies && node.satisfies(spec))\n  ) : true\n\nconst augmentNodesWithMetadata = ({\n  args,\n  currentDepth,\n  nodeResult,\n  seenNodes,\n}) => (node) => {\n  // if the original edge was a deduped dep, treeverse will fail to\n  // revisit that node in tree traversal logic, so we make it so that\n  // we have a diff obj for deduped nodes:\n  if (seenNodes.has(node.path)) {\n    node = {\n      name: node.name,\n      version: node.version,\n      pkgid: node.pkgid,\n      package: node.package,\n      path: node.path,\n      isLink: node.isLink,\n      realpath: node.realpath,\n      [_invalid]: node[_invalid],\n      [_missing]: node[_missing],\n      [_dedupe]: true,\n    }\n  } else {\n    // keeps track of already seen nodes in order to check for dedupes\n    seenNodes.set(node.path, node)\n  }\n\n  // _parent is going to be a ref to a treeverse-visited node (returned from\n  // getHumanOutputItem, getJsonOutputItem, etc) so that we have an easy\n  // shortcut to place new nodes in their right place during tree traversal\n  node[_parent] = nodeResult\n  // _include is the property that allow us to filter based on position args\n  // e.g: `npm ls foo`, `npm ls simple-output@2`\n  // _filteredBy is used to apply extra color info to the item that\n  // was used in args in order to filter\n  node[_filteredBy] = node[_include] =\n    filterByPositionalArgs(args, { node: seenNodes.get(node.path) })\n  // _depth keeps track of how many levels deep tree traversal currently is\n  // so that we can `npm ls --depth=1`\n  node[_depth] = currentDepth + 1\n\n  return node\n}\n\nconst sortAlphabetically = (a, b) =>\n  a.pkgid.localeCompare(b.pkgid)\n\nconst humanOutput = ({ color, result, seenItems, unicode }) => {\n  // we need to traverse the entire tree in order to determine which items\n  // should be included (since a nested transitive included dep will make it\n  // so that all its ancestors should be displayed)\n  // here is where we put items in their expected place for archy output\n  for (const item of seenItems) {\n    if (item[_include] && item[_parent])\n      item[_parent].nodes.push(item)\n  }\n\n  if (!result.nodes.length)\n    result.nodes = ['(empty)']\n\n  const archyOutput = archy(result, '', { unicode })\n  return color ? chalk.reset(archyOutput) : archyOutput\n}\n\nconst jsonOutput = ({ path, problems, result, rootError, seenItems }) => {\n  if (problems.size)\n    result.problems = [...problems]\n\n  if (rootError) {\n    result.problems = [\n      ...(result.problems || []),\n      ...[`error in ${path}: Failed to parse root package.json`],\n    ]\n    result.invalid = true\n  }\n\n  // we need to traverse the entire tree in order to determine which items\n  // should be included (since a nested transitive included dep will make it\n  // so that all its ancestors should be displayed)\n  // here is where we put items in their expected place for json output\n  for (const item of seenItems) {\n    // append current item to its parent item.dependencies obj in order\n    // to provide a json object structure that represents the installed tree\n    if (item[_include] && item[_parent]) {\n      if (!item[_parent].dependencies)\n        item[_parent].dependencies = {}\n\n      item[_parent].dependencies[item[_name]] = item\n    }\n  }\n\n  return JSON.stringify(result, null, 2)\n}\n\nconst parseableOutput = ({ global, long, seenNodes }) => {\n  let out = ''\n  for (const node of seenNodes.values()) {\n    if (node.path && node[_include]) {\n      out += node.path\n      if (long) {\n        out += `:${node.pkgid}`\n        out += node.path !== node.realpath ? `:${node.realpath}` : ''\n        out += isExtraneous(node, { global }) ? ':EXTRANEOUS' : ''\n        out += node[_invalid] ? ':INVALID' : ''\n      }\n      out += EOL\n    }\n  }\n  return out.trim()\n}\n"]},"metadata":{},"sourceType":"script"}
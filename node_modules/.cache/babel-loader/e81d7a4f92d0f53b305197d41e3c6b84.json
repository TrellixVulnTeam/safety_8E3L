{"ast":null,"code":"// mixin implementing the buildIdealTree method\nconst rpj = require('read-package-json-fast');\n\nconst npa = require('npm-package-arg');\n\nconst pacote = require('pacote');\n\nconst cacache = require('cacache');\n\nconst semver = require('semver');\n\nconst promiseCallLimit = require('promise-call-limit');\n\nconst getPeerSet = require('../peer-set.js');\n\nconst realpath = require('../../lib/realpath.js');\n\nconst {\n  resolve\n} = require('path');\n\nconst {\n  promisify\n} = require('util');\n\nconst treeCheck = require('../tree-check.js');\n\nconst readdir = promisify(require('readdir-scoped-modules'));\n\nconst debug = require('../debug.js');\n\nconst fromPath = require('../from-path.js');\n\nconst calcDepFlags = require('../calc-dep-flags.js');\n\nconst Shrinkwrap = require('../shrinkwrap.js');\n\nconst Node = require('../node.js');\n\nconst Link = require('../link.js');\n\nconst addRmPkgDeps = require('../add-rm-pkg-deps.js');\n\nconst gatherDepSet = require('../gather-dep-set.js');\n\nconst optionalSet = require('../optional-set.js');\n\nconst {\n  checkEngine,\n  checkPlatform\n} = require('npm-install-checks'); // enum of return values for canPlaceDep.\n// No, this is a conflict, you may not put that package here\n\n\nconst CONFLICT = Symbol('CONFLICT'); // Yes, this is fine, and should not be a problem\n\nconst OK = Symbol('OK'); // No need, because the package already here is fine\n\nconst KEEP = Symbol('KEEP'); // Yes, clobber the package that is already here\n\nconst REPLACE = Symbol('REPLACE');\n\nconst relpath = require('../relpath.js'); // note: some of these symbols are shared so we can hit\n// them with unit tests and reuse them across mixins\n\n\nconst _complete = Symbol('complete');\n\nconst _depsSeen = Symbol('depsSeen');\n\nconst _depsQueue = Symbol('depsQueue');\n\nconst _currentDep = Symbol('currentDep');\n\nconst _updateAll = Symbol('updateAll');\n\nconst _mutateTree = Symbol('mutateTree');\n\nconst _flagsSuspect = Symbol.for('flagsSuspect');\n\nconst _workspaces = Symbol.for('workspaces');\n\nconst _prune = Symbol('prune');\n\nconst _preferDedupe = Symbol('preferDedupe');\n\nconst _legacyBundling = Symbol('legacyBundling');\n\nconst _parseSettings = Symbol('parseSettings');\n\nconst _initTree = Symbol('initTree');\n\nconst _applyUserRequests = Symbol('applyUserRequests');\n\nconst _applyUserRequestsToNode = Symbol('applyUserRequestsToNode');\n\nconst _inflateAncientLockfile = Symbol('inflateAncientLockfile');\n\nconst _buildDeps = Symbol('buildDeps');\n\nconst _buildDepStep = Symbol('buildDepStep');\n\nconst _nodeFromEdge = Symbol('nodeFromEdge');\n\nconst _nodeFromSpec = Symbol('nodeFromSpec');\n\nconst _fetchManifest = Symbol('fetchManifest');\n\nconst _problemEdges = Symbol('problemEdges');\n\nconst _manifests = Symbol('manifests');\n\nconst _loadWorkspaces = Symbol.for('loadWorkspaces');\n\nconst _linkFromSpec = Symbol('linkFromSpec');\n\nconst _loadPeerSet = Symbol('loadPeerSet');\n\nconst _updateNames = Symbol.for('updateNames');\n\nconst _placeDep = Symbol.for('placeDep');\n\nconst _canPlaceDep = Symbol.for('canPlaceDep');\n\nconst _canPlacePeers = Symbol('canPlacePeers');\n\nconst _pruneForReplacement = Symbol('pruneForReplacement');\n\nconst _fixDepFlags = Symbol('fixDepFlags');\n\nconst _resolveLinks = Symbol('resolveLinks');\n\nconst _rootNodeFromPackage = Symbol('rootNodeFromPackage');\n\nconst _add = Symbol('add');\n\nconst _resolvedAdd = Symbol.for('resolvedAdd');\n\nconst _queueNamedUpdates = Symbol('queueNamedUpdates');\n\nconst _queueVulnDependents = Symbol('queueVulnDependents');\n\nconst _avoidRange = Symbol('avoidRange');\n\nconst _shouldUpdateNode = Symbol('shouldUpdateNode');\n\nconst resetDepFlags = require('../reset-dep-flags.js');\n\nconst _loadFailures = Symbol('loadFailures');\n\nconst _pruneFailedOptional = Symbol('pruneFailedOptional');\n\nconst _linkNodes = Symbol('linkNodes');\n\nconst _follow = Symbol('follow');\n\nconst _globalStyle = Symbol('globalStyle');\n\nconst _globalRootNode = Symbol('globalRootNode');\n\nconst _isVulnerable = Symbol.for('isVulnerable');\n\nconst _usePackageLock = Symbol.for('usePackageLock');\n\nconst _rpcache = Symbol.for('realpathCache');\n\nconst _stcache = Symbol.for('statCache');\n\nconst _updateFilePath = Symbol('updateFilePath');\n\nconst _followSymlinkPath = Symbol('followSymlinkPath');\n\nconst _getRelpathSpec = Symbol('getRelpathSpec');\n\nconst _retrieveSpecName = Symbol('retrieveSpecName');\n\nconst _strictPeerDeps = Symbol('strictPeerDeps');\n\nconst _checkEngineAndPlatform = Symbol('checkEngineAndPlatform');\n\nconst _checkEngine = Symbol('checkEngine');\n\nconst _checkPlatform = Symbol('checkPlatform');\n\nconst _virtualRoots = Symbol('virtualRoots');\n\nconst _virtualRoot = Symbol('virtualRoot'); // used for the ERESOLVE error to show the last peer conflict encountered\n\n\nconst _peerConflict = Symbol('peerConflict');\n\nconst _failPeerConflict = Symbol('failPeerConflict');\n\nconst _explainPeerConflict = Symbol('explainPeerConflict');\n\nconst _warnPeerConflict = Symbol('warnPeerConflict');\n\nconst _edgesOverridden = Symbol('edgesOverridden'); // exposed symbol for unit testing the placeDep method directly\n\n\nconst _peerSetSource = Symbol.for('peerSetSource'); // used by Reify mixin\n\n\nconst _force = Symbol.for('force');\n\nconst _explicitRequests = Symbol('explicitRequests');\n\nconst _global = Symbol.for('global');\n\nconst _idealTreePrune = Symbol.for('idealTreePrune');\n\nmodule.exports = cls => class IdealTreeBuilder extends cls {\n  constructor(options) {\n    super(options); // normalize trailing slash\n\n    const registry = options.registry || 'https://registry.npmjs.org';\n    options.registry = this.registry = registry.replace(/\\/+$/, '') + '/';\n    const {\n      idealTree = null,\n      global = false,\n      follow = false,\n      globalStyle = false,\n      legacyPeerDeps = false,\n      force = false,\n      packageLock = true,\n      strictPeerDeps = false,\n      workspaces = []\n    } = options;\n    this[_workspaces] = workspaces || [];\n    this[_force] = !!force;\n    this[_strictPeerDeps] = !!strictPeerDeps;\n    this.idealTree = idealTree;\n    this.legacyPeerDeps = legacyPeerDeps;\n    this[_usePackageLock] = packageLock;\n    this[_global] = !!global;\n    this[_globalStyle] = this[_global] || globalStyle;\n    this[_follow] = !!follow;\n    if (this[_workspaces].length && this[_global]) throw new Error('Cannot operate on workspaces in global mode');\n    this[_explicitRequests] = new Set();\n    this[_preferDedupe] = false;\n    this[_legacyBundling] = false;\n    this[_depsSeen] = new Set();\n    this[_depsQueue] = [];\n    this[_currentDep] = null;\n    this[_updateNames] = [];\n    this[_updateAll] = false;\n    this[_mutateTree] = false;\n    this[_loadFailures] = new Set();\n    this[_linkNodes] = new Set();\n    this[_manifests] = new Map();\n    this[_peerConflict] = null;\n    this[_edgesOverridden] = new Set();\n    this[_resolvedAdd] = []; // a map of each module in a peer set to the thing that depended on\n    // that set of peers in the first place.  Use a WeakMap so that we\n    // don't hold onto references for nodes that are garbage collected.\n\n    this[_peerSetSource] = new WeakMap();\n    this[_virtualRoots] = new Map();\n  }\n\n  get explicitRequests() {\n    return new Set(this[_explicitRequests]);\n  } // public method\n\n\n  async buildIdealTree(options = {}) {\n    if (this.idealTree) return Promise.resolve(this.idealTree); // allow the user to set reify options on the ctor as well.\n    // XXX: deprecate separate reify() options object.\n\n    options = { ...this.options,\n      ...options\n    }; // an empty array or any falsey value is the same as null\n\n    if (!options.add || options.add.length === 0) options.add = null;\n    if (!options.rm || options.rm.length === 0) options.rm = null;\n    process.emit('time', 'idealTree');\n\n    if (!options.add && !options.rm && !options.update && this[_global]) {\n      const er = new Error('global requires add, rm, or update option');\n      return Promise.reject(er);\n    } // first get the virtual tree, if possible.  If there's a lockfile, then\n    // that defines the ideal tree, unless the root package.json is not\n    // satisfied by what the ideal tree provides.\n    // from there, we start adding nodes to it to satisfy the deps requested\n    // by the package.json in the root.\n\n\n    this[_parseSettings](options); // start tracker block\n\n\n    this.addTracker('idealTree');\n\n    try {\n      await this[_initTree]();\n      await this[_inflateAncientLockfile]();\n      await this[_applyUserRequests](options);\n      await this[_buildDeps]();\n      await this[_fixDepFlags]();\n      await this[_pruneFailedOptional]();\n      await this[_checkEngineAndPlatform]();\n    } finally {\n      process.emit('timeEnd', 'idealTree');\n      this.finishTracker('idealTree');\n    }\n\n    return treeCheck(this.idealTree);\n  }\n\n  [_checkEngineAndPlatform]() {\n    // engine/platform checks throw, so start the promise chain off first\n    return Promise.resolve().then(() => {\n      for (const node of this.idealTree.inventory.values()) {\n        if (!node.optional) {\n          this[_checkEngine](node);\n\n          this[_checkPlatform](node);\n        }\n      }\n    });\n  }\n\n  [_checkPlatform](node) {\n    checkPlatform(node.package, this[_force]);\n  }\n\n  [_checkEngine](node) {\n    const {\n      engineStrict,\n      npmVersion,\n      nodeVersion\n    } = this.options;\n\n    const c = () => checkEngine(node.package, npmVersion, nodeVersion, this[_force]);\n\n    if (engineStrict) c();else {\n      try {\n        c();\n      } catch (er) {\n        this.log.warn(er.code, er.message, {\n          package: er.pkgid,\n          required: er.required,\n          current: er.current\n        });\n      }\n    }\n  }\n\n  [_parseSettings](options) {\n    const update = options.update === true ? {\n      all: true\n    } : Array.isArray(options.update) ? {\n      names: options.update\n    } : options.update || {};\n    if (update.all || !Array.isArray(update.names)) update.names = [];\n    this[_complete] = !!options.complete;\n    this[_preferDedupe] = !!options.preferDedupe;\n    this[_legacyBundling] = !!options.legacyBundling;\n    this[_updateNames] = update.names;\n    this[_updateAll] = update.all; // we prune by default unless explicitly set to boolean false\n\n    this[_prune] = options.prune !== false; // set if we add anything, but also set here if we know we'll make\n    // changes and thus have to maybe prune later.\n\n    this[_mutateTree] = !!(options.add || options.rm || update.all || update.names.length);\n  } // load the initial tree, either the virtualTree from a shrinkwrap,\n  // or just the root node from a package.json\n\n\n  [_initTree]() {\n    process.emit('time', 'idealTree:init');\n    return (this[_global] ? this[_globalRootNode]() : rpj(this.path + '/package.json').then(pkg => this[_rootNodeFromPackage](pkg), er => {\n      if (er.code === 'EJSONPARSE') throw er;\n      return this[_rootNodeFromPackage]({});\n    })).then(root => this[_loadWorkspaces](root)) // ok to not have a virtual tree.  probably initial install.\n    // When updating all, we load the shrinkwrap, but don't bother\n    // to build out the full virtual tree from it, since we'll be\n    // reconstructing it anyway.\n    .then(root => this[_global] ? root : !this[_usePackageLock] || this[_updateAll] ? Shrinkwrap.reset({\n      path: this.path\n    }).then(meta => Object.assign(root, {\n      meta\n    })) : this.loadVirtual({\n      root\n    })) // if we don't have a lockfile to go from, then start with the\n    // actual tree, so we only make the minimum required changes.\n    // don't do this for global installs or updates, because in those\n    // cases we don't use a lockfile anyway.\n    // Load on a new Arborist object, so the Nodes aren't the same,\n    // or else it'll get super confusing when we change them!\n    .then(async root => {\n      if (!this[_updateAll] && !this[_global] && !root.meta.loadedFromDisk) {\n        await new this.constructor(this.options).loadActual({\n          root\n        });\n        const tree = root.target || root; // even though we didn't load it from a package-lock.json FILE,\n        // we still loaded it \"from disk\", meaning we have to reset\n        // dep flags before assuming that any mutations were reflected.\n\n        if (tree.children.size) root.meta.loadedFromDisk = true;\n      }\n\n      return root;\n    }).then(tree => {\n      // null the virtual tree, because we're about to hack away at it\n      // if you want another one, load another copy.\n      this.idealTree = tree;\n      this.virtualTree = null;\n      process.emit('timeEnd', 'idealTree:init');\n    });\n  }\n\n  async [_globalRootNode]() {\n    const root = await this[_rootNodeFromPackage]({\n      dependencies: {}\n    }); // this is a gross kludge to handle the fact that we don't save\n    // metadata on the root node in global installs, because the \"root\"\n    // node is something like /usr/local/lib.\n\n    const meta = new Shrinkwrap({\n      path: this.path\n    });\n    meta.reset();\n    root.meta = meta;\n    return root;\n  }\n\n  async [_rootNodeFromPackage](pkg) {\n    // if the path doesn't exist, then we explode at this point. Note that\n    // this is not a problem for reify(), since it creates the root path\n    // before ever loading trees.\n    // TODO: make buildIdealTree() and loadActual handle a missing root path,\n    // or a symlink to a missing target, and let reify() create it as needed.\n    const real = await realpath(this.path, this[_rpcache], this[_stcache]);\n    const Cls = real === this.path ? Node : Link;\n    const root = new Cls({\n      path: this.path,\n      realpath: real,\n      pkg,\n      extraneous: false,\n      dev: false,\n      devOptional: false,\n      peer: false,\n      optional: false,\n      global: this[_global],\n      legacyPeerDeps: this.legacyPeerDeps\n    });\n\n    if (root.isLink) {\n      root.target = new Node({\n        path: real,\n        realpath: real,\n        pkg,\n        extraneous: false,\n        dev: false,\n        devOptional: false,\n        peer: false,\n        optional: false,\n        global: this[_global],\n        legacyPeerDeps: this.legacyPeerDeps,\n        root\n      });\n    }\n\n    return root;\n  } // process the add/rm requests by modifying the root node, and the\n  // update.names request by queueing nodes dependent on those named.\n\n\n  async [_applyUserRequests](options) {\n    process.emit('time', 'idealTree:userRequests');\n    const tree = this.idealTree.target || this.idealTree;\n\n    if (!this[_workspaces].length) {\n      return this[_applyUserRequestsToNode](tree, options).then(() => process.emit('timeEnd', 'idealTree:userRequests'));\n    }\n\n    const wsMap = tree.workspaces;\n\n    if (!wsMap) {\n      this.log.warn('idealTree', 'Workspace filter set, but no workspaces present');\n      return;\n    }\n\n    const promises = [];\n\n    for (const name of this[_workspaces]) {\n      const path = wsMap.get(name);\n\n      if (!path) {\n        this.log.warn('idealTree', `Workspace ${name} in filter set, but not in workspaces`);\n        continue;\n      }\n\n      const loc = relpath(tree.realpath, path);\n      const node = tree.inventory.get(loc);\n      /* istanbul ignore if - should be impossible */\n\n      if (!node) {\n        this.log.warn('idealTree', `Workspace ${name} in filter set, but no workspace folder present`);\n        continue;\n      }\n\n      promises.push(this[_applyUserRequestsToNode](node, options));\n    }\n\n    return Promise.all(promises).then(() => process.emit('timeEnd', 'idealTree:userRequests'));\n  }\n\n  async [_applyUserRequestsToNode](tree, options) {\n    // If we have a list of package names to update, and we know it's\n    // going to update them wherever they are, add any paths into those\n    // named nodes to the buildIdealTree queue.\n    if (!this[_global] && this[_updateNames].length) this[_queueNamedUpdates](); // global updates only update the globalTop nodes, but we need to know\n    // that they're there, and not reinstall the world unnecessarily.\n\n    const globalExplicitUpdateNames = [];\n\n    if (this[_global] && (this[_updateAll] || this[_updateNames].length)) {\n      const nm = resolve(this.path, 'node_modules');\n\n      for (const name of await readdir(nm).catch(() => [])) {\n        tree.package.dependencies = tree.package.dependencies || {};\n\n        const updateName = this[_updateNames].includes(name);\n\n        if (this[_updateAll] || updateName) {\n          if (updateName) globalExplicitUpdateNames.push(name);\n          tree.package.dependencies[name] = '*';\n        }\n      }\n    }\n\n    if (this.auditReport && this.auditReport.size > 0) this[_queueVulnDependents](options);\n    const {\n      add,\n      rm\n    } = options;\n\n    if (rm && rm.length) {\n      addRmPkgDeps.rm(tree.package, rm);\n\n      for (const name of rm) this[_explicitRequests].add({\n        from: tree,\n        name,\n        action: 'DELETE'\n      });\n    }\n\n    if (add && add.length) await this[_add](tree, options); // triggers a refresh of all edgesOut.  this has to be done BEFORE\n    // adding the edges to explicitRequests, because the package setter\n    // resets all edgesOut.\n\n    if (add && add.length || rm && rm.length || this[_global]) tree.package = tree.package;\n\n    for (const spec of this[_resolvedAdd]) this[_explicitRequests].add(tree.edgesOut.get(spec.name));\n\n    for (const name of globalExplicitUpdateNames) this[_explicitRequests].add(tree.edgesOut.get(name));\n  } // This returns a promise because we might not have the name yet,\n  // and need to call pacote.manifest to find the name.\n\n\n  [_add](tree, {\n    add,\n    saveType = null,\n    saveBundle = false\n  }) {\n    // get the name for each of the specs in the list.\n    // ie, doing `foo@bar` we just return foo\n    // but if it's a url or git, we don't know the name until we\n    // fetch it and look in its manifest.\n    return Promise.all(add.map(rawSpec => {\n      // We do NOT provide the path here, because user-additions need\n      // to be resolved relative to the CWD the user is in.\n      return this[_retrieveSpecName](npa(rawSpec)).then(add => this[_updateFilePath](add)).then(add => this[_followSymlinkPath](add));\n    })).then(add => {\n      this[_resolvedAdd].push(...add); // now add is a list of spec objects with names.\n      // find a home for each of them!\n\n\n      addRmPkgDeps.add({\n        pkg: tree.package,\n        add,\n        saveBundle,\n        saveType,\n        path: this.path\n      });\n    });\n  }\n\n  async [_retrieveSpecName](spec) {\n    // if it's just @'' then we reload whatever's there, or get latest\n    // if it's an explicit tag, we need to install that specific tag version\n    const isTag = spec.rawSpec && spec.type === 'tag';\n    if (spec.name && !isTag) return spec;\n    const mani = await pacote.manifest(spec, { ...this.options\n    }); // if it's a tag type, then we need to run it down to an actual version\n\n    if (isTag) return npa(`${mani.name}@${mani.version}`);\n    spec.name = mani.name;\n    return spec;\n  }\n\n  async [_updateFilePath](spec) {\n    if (spec.type === 'file') spec = this[_getRelpathSpec](spec, spec.fetchSpec);\n    return spec;\n  }\n\n  async [_followSymlinkPath](spec) {\n    if (spec.type === 'directory') {\n      const real = await realpath(spec.fetchSpec, this[_rpcache], this[_stcache]) // TODO: create synthetic test case to simulate realpath failure\n      .catch(\n      /* istanbul ignore next */\n      () => null);\n      spec = this[_getRelpathSpec](spec, real);\n    }\n\n    return spec;\n  }\n\n  [_getRelpathSpec](spec, filepath) {\n    /* istanbul ignore else - should also be covered by realpath failure */\n    if (filepath) {\n      const {\n        name\n      } = spec;\n      const tree = this.idealTree.target || this.idealTree;\n      spec = npa(`file:${relpath(tree.path, filepath)}`, tree.path);\n      spec.name = name;\n    }\n\n    return spec;\n  } // TODO: provide a way to fix bundled deps by exposing metadata about\n  // what's in the bundle at each published manifest.  Without that, we\n  // can't possibly fix bundled deps without breaking a ton of other stuff,\n  // and leaving the user subject to getting it overwritten later anyway.\n\n\n  [_queueVulnDependents](options) {\n    for (const {\n      nodes\n    } of this.auditReport.values()) {\n      for (const node of nodes) {\n        const bundler = node.getBundler(); // XXX this belongs in the audit report itself, not here.\n        // We shouldn't even get these things here, and they shouldn't\n        // be printed by npm-audit-report as if they can be fixed, because\n        // they can't.\n\n        if (bundler) {\n          this.log.warn(`audit fix ${node.name}@${node.version}`, `${node.location}\\nis a bundled dependency of\\n${bundler.name}@${bundler.version} at ${bundler.location}\\n` + 'It cannot be fixed automatically.\\n' + `Check for updates to the ${bundler.name} package.`);\n          continue;\n        }\n\n        for (const edge of node.edgesIn) {\n          this.addTracker('idealTree', edge.from.name, edge.from.location);\n\n          this[_depsQueue].push(edge.from);\n        }\n      }\n    } // note any that can't be fixed at the root level without --force\n    // if there's a fix, we use that.  otherwise, the user has to remove it,\n    // find a different thing, fix the upstream, etc.\n    //\n    // XXX: how to handle top nodes that aren't the root?  Maybe the report\n    // just tells the user to cd into that directory and fix it?\n\n\n    if (this[_force] && this.auditReport && this.auditReport.topVulns.size) {\n      options.add = options.add || [];\n      options.rm = options.rm || [];\n\n      for (const [name, topVuln] of this.auditReport.topVulns.entries()) {\n        const {\n          simpleRange,\n          topNodes,\n          fixAvailable\n        } = topVuln;\n\n        for (const node of topNodes) {\n          if (node !== this.idealTree && node !== this.idealTree.target) {\n            // not something we're going to fix, sorry.  have to cd into\n            // that directory and fix it yourself.\n            this.log.warn('audit', 'Manual fix required in linked project ' + `at ./${node.location} for ${name}@${simpleRange}.\\n` + `'cd ./${node.location}' and run 'npm audit' for details.`);\n            continue;\n          }\n\n          if (!fixAvailable) {\n            this.log.warn('audit', `No fix available for ${name}@${simpleRange}`);\n            continue;\n          }\n\n          const {\n            isSemVerMajor,\n            version\n          } = fixAvailable;\n          const breakingMessage = isSemVerMajor ? 'a SemVer major change' : 'outside your stated dependency range';\n          this.log.warn('audit', `Updating ${name} to ${version},` + `which is ${breakingMessage}.`);\n          options.add.push(`${name}@${version}`);\n        }\n      }\n    }\n  }\n\n  [_isVulnerable](node) {\n    return this.auditReport && this.auditReport.isVulnerable(node);\n  }\n\n  [_avoidRange](name) {\n    if (!this.auditReport) return null;\n    const vuln = this.auditReport.get(name);\n    if (!vuln) return null;\n    return vuln.range;\n  }\n\n  [_queueNamedUpdates]() {\n    // ignore top nodes, since they are not loaded the same way, and\n    // probably have their own project associated with them.\n    // for every node with one of the names on the list, we add its\n    // dependents to the queue to be evaluated.  in buildDepStem,\n    // anything on the update names list will get refreshed, even if\n    // it isn't a problem.\n    // XXX this could be faster by doing a series of inventory.query('name')\n    // calls rather than walking over everything in the tree.\n    const set = this.idealTree.inventory.filter(n => this[_shouldUpdateNode](n));\n\n    for (const node of set) {\n      for (const edge of node.edgesIn) {\n        this.addTracker('idealTree', edge.from.name, edge.from.location);\n\n        this[_depsQueue].push(edge.from);\n      }\n    }\n  }\n\n  [_shouldUpdateNode](node) {\n    return this[_updateNames].includes(node.name) && !node.isTop && !node.inDepBundle && !node.inShrinkwrap;\n  }\n\n  async [_inflateAncientLockfile]() {\n    const {\n      meta,\n      inventory\n    } = this.idealTree;\n    const ancient = meta.ancientLockfile;\n    const old = meta.loadedFromDisk && !(meta.originalLockfileVersion >= 2);\n    if (inventory.size === 0 || !ancient && !(old && this[_complete])) return; // if the lockfile is from node v5 or earlier, then we'll have to reload\n    // all the manifests of everything we encounter.  this is costly, but at\n    // least it's just a one-time hit.\n\n    process.emit('time', 'idealTree:inflate');\n    const heading = ancient ? 'ancient lockfile' : 'old lockfile';\n    this.log.warn(heading, `\nThe ${meta.type} file was created with an old version of npm,\nso supplemental metadata must be fetched from the registry.\n\nThis is a one-time fix-up, please be patient...\n`);\n    this.addTracker('idealTree:inflate');\n    const queue = [];\n\n    for (const node of inventory.values()) {\n      if (node.isProjectRoot) continue;\n      queue.push(async () => {\n        this.log.silly('inflate', node.location);\n        const {\n          resolved,\n          version,\n          path,\n          name,\n          location,\n          integrity\n        } = node; // don't try to hit the registry for linked deps\n\n        const useResolved = !version || resolved && resolved.startsWith('file:');\n        const id = useResolved ? resolved : version;\n        const spec = npa.resolve(name, id, path);\n        const sloc = location.substr('node_modules/'.length);\n        const t = `idealTree:inflate:${sloc}`;\n        this.addTracker(t);\n        await pacote.manifest(spec, { ...this.options,\n          resolved: resolved,\n          integrity: integrity,\n          fullMetadata: false\n        }).then(mani => {\n          node.package = { ...mani,\n            _id: `${mani.name}@${mani.version}`\n          };\n        }).catch(er => {\n          const warning = `Could not fetch metadata for ${name}@${id}`;\n          this.log.warn(heading, warning, er);\n        });\n        this.finishTracker(t);\n      });\n    }\n\n    await promiseCallLimit(queue); // have to re-calc dep flags, because the nodes don't have edges\n    // until their packages get assigned, so everything looks extraneous\n\n    calcDepFlags(this.idealTree); // yes, yes, this isn't the \"original\" version, but now that it's been\n    // upgraded, we need to make sure we don't do the work to upgrade it\n    // again, since it's now as new as can be.\n\n    meta.originalLockfileVersion = 2;\n    this.finishTracker('idealTree:inflate');\n    process.emit('timeEnd', 'idealTree:inflate');\n  } // at this point we have a virtual tree with the actual root node's\n  // package deps, which may be partly or entirely incomplete, invalid\n  // or extraneous.\n\n\n  [_buildDeps]() {\n    process.emit('time', 'idealTree:buildDeps');\n    const tree = this.idealTree.target || this.idealTree;\n\n    this[_depsQueue].push(tree);\n\n    this.log.silly('idealTree', 'buildDeps');\n    this.addTracker('idealTree', tree.name, '');\n    return this[_buildDepStep]().then(() => process.emit('timeEnd', 'idealTree:buildDeps'));\n  }\n\n  async [_buildDepStep]() {\n    // removes tracker of previous dependency in the queue\n    if (this[_currentDep]) {\n      const {\n        location,\n        name\n      } = this[_currentDep];\n      process.emit('timeEnd', `idealTree:${location || '#root'}`);\n      this.finishTracker('idealTree', name, location);\n      this[_currentDep] = null;\n    }\n\n    if (!this[_depsQueue].length) return this[_resolveLinks](); // sort physically shallower deps up to the front of the queue,\n    // because they'll affect things deeper in, then alphabetical\n\n    this[_depsQueue].sort((a, b) => a.depth - b.depth || a.path.localeCompare(b.path));\n\n    const node = this[_depsQueue].shift();\n\n    const bd = node.package.bundleDependencies;\n    const hasBundle = bd && Array.isArray(bd) && bd.length;\n    const {\n      hasShrinkwrap\n    } = node; // if the node was already visited, or has since been removed from the\n    // tree, skip over it and process the rest of the queue.  If a node has\n    // a shrinkwrap, also skip it, because it's going to get its deps\n    // satisfied by whatever's in that file anyway.\n\n    if (this[_depsSeen].has(node) || node.root !== this.idealTree || hasShrinkwrap && !this[_complete]) return this[_buildDepStep]();\n\n    this[_depsSeen].add(node);\n\n    this[_currentDep] = node;\n    process.emit('time', `idealTree:${node.location || '#root'}`); // if we're loading a _complete_ ideal tree, for a --package-lock-only\n    // installation for example, we have to crack open the tarball and\n    // look inside if it has bundle deps or shrinkwraps.  note that this is\n    // not necessary during a reification, because we just update the\n    // ideal tree by reading bundles/shrinkwraps in place.\n    // Don't bother if the node is from the actual tree and hasn't\n    // been resolved, because we can't fetch it anyway, could be anything!\n\n    const crackOpen = this[_complete] && node !== this.idealTree && node.resolved && (hasBundle || hasShrinkwrap);\n\n    if (crackOpen) {\n      const Arborist = this.constructor;\n      const opt = { ...this.options\n      };\n      await cacache.tmp.withTmp(this.cache, opt, async path => {\n        await pacote.extract(node.resolved, path, opt);\n\n        if (hasShrinkwrap) {\n          await new Arborist({ ...this.options,\n            path\n          }).loadVirtual({\n            root: node\n          });\n        }\n\n        if (hasBundle) {\n          await new Arborist({ ...this.options,\n            path\n          }).loadActual({\n            root: node,\n            ignoreMissing: true\n          });\n        }\n      });\n    } // if any deps are missing or invalid, then we fetch the manifest for\n    // the thing we want, and build a new dep node from that.\n    // Then, find the ideal placement for that node.  The ideal placement\n    // searches from the node's deps (or parent deps in the case of non-root\n    // peer deps), and walks up the tree until it finds the highest spot\n    // where it doesn't cause any conflicts.\n    //\n    // A conflict can be:\n    // - A node by that name already exists at that location.\n    // - The parent has a peer dep on that name\n    // - One of the node's peer deps conflicts at that location, unless the\n    //   peer dep is met by a node at that location, which is fine.\n    //\n    // If we create a new node, then build its ideal deps as well.\n    //\n    // Note: this is the same \"maximally naive\" deduping tree-building\n    // algorithm that npm has used since v3.  In a case like this:\n    //\n    // root -> (a@1, b@1||2)\n    // a -> (b@1)\n    //\n    // You'll end up with a tree like this:\n    //\n    // root\n    // +-- a@1\n    // |   +-- b@1\n    // +-- b@2\n    //\n    // rather than this, more deduped, but just as correct tree:\n    //\n    // root\n    // +-- a@1\n    // +-- b@1\n    //\n    // Another way to look at it is that this algorithm favors getting higher\n    // version deps at higher levels in the tree, even if that reduces\n    // potential deduplication.\n    //\n    // Set `preferDedupe: true` in the options to replace the shallower\n    // dep if allowed.\n\n\n    const tasks = [];\n    const peerSource = this[_peerSetSource].get(node) || node;\n\n    for (const edge of this[_problemEdges](node)) {\n      if (this[_edgesOverridden].has(edge)) continue; // peerSetSource is only relevant when we have a peerEntryEdge\n      // otherwise we're setting regular non-peer deps as if they have\n      // a virtual root of whatever brought in THIS node.\n      // so we VR the node itself if the edge is not a peer\n\n      const source = edge.peer ? peerSource : node;\n\n      const virtualRoot = this[_virtualRoot](source, true); // reuse virtual root if we already have one, but don't\n      // try to do the override ahead of time, since we MAY be able\n      // to create a more correct tree than the virtual root could.\n\n\n      const vrEdge = virtualRoot && virtualRoot.edgesOut.get(edge.name);\n      const vrDep = vrEdge && vrEdge.valid && vrEdge.to; // only re-use the virtualRoot if it's a peer edge we're placing.\n      // otherwise, we end up in situations where we override peer deps that\n      // we could have otherwise found homes for.  Eg:\n      // xy -> (x, y)\n      // x -> PEER(z@1)\n      // y -> PEER(z@2)\n      // If xy is a dependency, we can resolve this like:\n      // project\n      // +-- xy\n      // |   +-- y\n      // |   +-- z@2\n      // +-- x\n      // +-- z@1\n      // But if x and y are loaded in the same virtual root, then they will\n      // be forced to agree on a version of z.\n\n      const required = new Set([edge.from]);\n      const parent = edge.peer ? virtualRoot : null;\n      const dep = vrDep && vrDep.satisfies(edge) ? vrDep : await this[_nodeFromEdge](edge, parent, null, required);\n      /* istanbul ignore next */\n\n      debug(() => {\n        if (!dep) throw new Error('no dep??');\n      });\n      tasks.push({\n        edge,\n        dep\n      });\n    }\n\n    const placed = tasks.sort((a, b) => a.edge.name.localeCompare(b.edge.name)).map(({\n      edge,\n      dep\n    }) => this[_placeDep](dep, node, edge));\n    const promises = [];\n\n    for (const set of placed) {\n      for (const node of set) {\n        this[_mutateTree] = true;\n        this.addTracker('idealTree', node.name, node.location);\n\n        this[_depsQueue].push(node); // we're certainly going to need these soon, fetch them asap\n        // if it fails at this point, though, dont' worry because it\n        // may well be an optional dep that has gone missing.  it'll\n        // fail later anyway.\n\n\n        const from = fromPath(node);\n        promises.push(...this[_problemEdges](node).map(e => this[_fetchManifest](npa.resolve(e.name, e.spec, from)).catch(er => null)));\n      }\n    }\n\n    await Promise.all(promises);\n\n    for (const {\n      to\n    } of node.edgesOut.values()) {\n      if (to && to.isLink) this[_linkNodes].add(to);\n    }\n\n    return this[_buildDepStep]();\n  } // loads a node from an edge, and then loads its peer deps (and their\n  // peer deps, on down the line) into a virtual root parent.\n\n\n  async [_nodeFromEdge](edge, parent_, secondEdge, required) {\n    // create a virtual root node with the same deps as the node that\n    // is requesting this one, so that we can get all the peer deps in\n    // a context where they're likely to be resolvable.\n    // Note that the virtual root will also have virtual copies of the\n    // targets of any child Links, so that they resolve appropriately.\n    const parent = parent_ || this[_virtualRoot](edge.from);\n\n    const realParent = edge.peer ? edge.from.resolveParent : edge.from;\n    const spec = npa.resolve(edge.name, edge.spec, edge.from.path);\n    const first = await this[_nodeFromSpec](edge.name, spec, parent, edge); // we might have a case where the parent has a peer dependency on\n    // `foo@*` which resolves to v2, but another dep in the set has a\n    // peerDependency on `foo@1`.  In that case, if we force it to be v2,\n    // we're unnecessarily triggering an ERESOLVE.\n    // If we have a second edge to worry about, and it's not satisfied\n    // by the first node, try a second and see if that satisfies the\n    // original edge here.\n\n    const spec2 = secondEdge && npa.resolve(edge.name, secondEdge.spec, secondEdge.from.path);\n    const second = secondEdge && !secondEdge.valid ? await this[_nodeFromSpec](edge.name, spec2, parent, secondEdge) : null; // pick the second one if they're both happy with that, otherwise first\n\n    const node = second && edge.valid ? second : first; // ensure the one we want is the one that's placed\n\n    node.parent = parent;\n    if (required.has(edge.from) && edge.type !== 'peerOptional' || secondEdge && required.has(secondEdge.from) && secondEdge.type !== 'peerOptional') required.add(node); // handle otherwise unresolvable dependency nesting loops by\n    // creating a symbolic link\n    // a1 -> b1 -> a2 -> b2 -> a1 -> ...\n    // instead of nesting forever, when the loop occurs, create\n    // a symbolic link to the earlier instance\n\n    for (let p = edge.from.resolveParent; p; p = p.resolveParent) {\n      if (p.matches(node) && !p.isTop) return new Link({\n        parent: realParent,\n        target: p\n      });\n    } // keep track of the thing that caused this node to be included.\n\n\n    const src = parent.sourceReference;\n\n    this[_peerSetSource].set(node, src);\n\n    return this[_loadPeerSet](node, required);\n  }\n\n  [_virtualRoot](node, reuse = false) {\n    if (reuse && this[_virtualRoots].has(node)) return this[_virtualRoots].get(node);\n    const vr = new Node({\n      path: node.realpath,\n      sourceReference: node,\n      legacyPeerDeps: this.legacyPeerDeps\n    }); // also need to set up any targets from any link deps, so that\n    // they are properly reflected in the virtual environment\n\n    for (const child of node.children.values()) {\n      if (child.isLink) {\n        new Node({\n          path: child.realpath,\n          sourceReference: child.target,\n          root: vr\n        });\n      }\n    }\n\n    this[_virtualRoots].set(node, vr);\n\n    return vr;\n  }\n\n  [_problemEdges](node) {\n    // skip over any bundled deps, they're not our problem.\n    // Note that this WILL fetch bundled meta-deps which are also dependencies\n    // but not listed as bundled deps.  When reifying, we first unpack any\n    // nodes that have bundleDependencies, then do a loadActual on them, move\n    // the nodes into the ideal tree, and then prune.  So, fetching those\n    // possibly-bundled meta-deps at this point doesn't cause any worse\n    // problems than a few unnecessary packument fetches.\n    // also skip over any nodes in the tree that failed to load, since those\n    // will crash the install later on anyway.\n    const bd = node.isProjectRoot ? null : node.package.bundleDependencies;\n    const bundled = new Set(bd || []);\n    return [...node.edgesOut.values()].filter(edge => {\n      // If it's included in a bundle, we take whatever is specified.\n      if (bundled.has(edge.name)) return false; // If it's already been logged as a load failure, skip it.\n\n      if (edge.to && this[_loadFailures].has(edge.to)) return false; // If it's shrinkwrapped, we use what the shrinkwap wants.\n\n      if (edge.to && edge.to.inShrinkwrap) return false; // If the edge has no destination, that's a problem, unless\n      // if it's peerOptional and not explicitly requested.\n\n      if (!edge.to) {\n        return edge.type !== 'peerOptional' || this[_explicitRequests].has(edge);\n      } // If the edge has an error, there's a problem.\n\n\n      if (!edge.valid) return true; // If user has explicitly asked to update this package by name, it's a problem.\n\n      if (this[_updateNames].includes(edge.name)) return true; // If we're fixing a security vulnerability with this package, it's a problem.\n\n      if (this[_isVulnerable](edge.to)) return true; // If the user has explicitly asked to install this package, it's a problem.\n\n      if (node.isProjectRoot && this[_explicitRequests].has(edge)) return true; // No problems!\n\n      return false;\n    });\n  }\n\n  async [_fetchManifest](spec) {\n    const options = { ...this.options,\n      avoid: this[_avoidRange](spec.name)\n    }; // get the intended spec and stored metadata from yarn.lock file,\n    // if available and valid.\n\n    spec = this.idealTree.meta.checkYarnLock(spec, options);\n    if (this[_manifests].has(spec.raw)) return this[_manifests].get(spec.raw);else {\n      this.log.silly('fetch manifest', spec.raw);\n      const p = pacote.manifest(spec, options).then(mani => {\n        this[_manifests].set(spec.raw, mani);\n\n        return mani;\n      });\n\n      this[_manifests].set(spec.raw, p);\n\n      return p;\n    }\n  }\n\n  [_nodeFromSpec](name, spec, parent, edge) {\n    // pacote will slap integrity on its options, so we have to clone\n    // the object so it doesn't get mutated.\n    // Don't bother to load the manifest for link deps, because the target\n    // might be within another package that doesn't exist yet.\n    const {\n      legacyPeerDeps\n    } = this;\n    return spec.type === 'directory' ? this[_linkFromSpec](name, spec, parent, edge) : this[_fetchManifest](spec).then(pkg => new Node({\n      name,\n      pkg,\n      parent,\n      legacyPeerDeps\n    }), error => {\n      error.requiredBy = edge.from.location || '.'; // failed to load the spec, either because of enotarget or\n      // fetch failure of some other sort.  save it so we can verify\n      // later that it's optional, otherwise the error is fatal.\n\n      const n = new Node({\n        name,\n        parent,\n        error,\n        legacyPeerDeps\n      });\n\n      this[_loadFailures].add(n);\n\n      return n;\n    });\n  }\n\n  [_linkFromSpec](name, spec, parent, edge) {\n    const realpath = spec.fetchSpec;\n    const {\n      legacyPeerDeps\n    } = this;\n    return rpj(realpath + '/package.json').catch(() => ({})).then(pkg => {\n      const link = new Link({\n        name,\n        parent,\n        realpath,\n        pkg,\n        legacyPeerDeps\n      });\n\n      this[_linkNodes].add(link);\n\n      return link;\n    });\n  } // load all peer deps and meta-peer deps into the node's parent\n  // At the end of this, the node's peer-type outward edges are all\n  // resolved, and so are all of theirs, but other dep types are not.\n  // We prefer to get peer deps that meet the requiring node's dependency,\n  // if possible, since that almost certainly works (since that package was\n  // developed with this set of deps) and will typically be more restrictive.\n  // Note that the peers in the set can conflict either with each other,\n  // or with a direct dependency from the virtual root parent!  In strict\n  // mode, this is always an error.  In force mode, it never is, and we\n  // prefer the parent's non-peer dep over a peer dep, or the version that\n  // gets placed first.  In non-strict mode, we behave strictly if the\n  // virtual root is based on the root project, and allow non-peer parent\n  // deps to override, but throw if no preference can be determined.\n\n\n  async [_loadPeerSet](node, required) {\n    const peerEdges = [...node.edgesOut.values()] // we typically only install non-optional peers, but we have to\n    // factor them into the peerSet so that we can avoid conflicts\n    .filter(e => e.peer && !(e.valid && e.to)).sort(({\n      name: a\n    }, {\n      name: b\n    }) => a.localeCompare(b));\n\n    for (const edge of peerEdges) {\n      // already placed this one, and we're happy with it.\n      if (edge.valid && edge.to) continue;\n      const parentEdge = node.parent.edgesOut.get(edge.name);\n      const {\n        isProjectRoot,\n        isWorkspace\n      } = node.parent.sourceReference;\n      const isMine = isProjectRoot || isWorkspace;\n      const conflictOK = this[_force] || !isMine && !this[_strictPeerDeps];\n\n      if (!edge.to) {\n        if (!parentEdge) {\n          // easy, just put the thing there\n          await this[_nodeFromEdge](edge, node.parent, null, required);\n          continue;\n        } else {\n          // if the parent's edge is very broad like >=1, and the edge in\n          // question is something like 1.x, then we want to get a 1.x, not\n          // a 2.x.  pass along the child edge as an advisory guideline.\n          // if the parent edge doesn't satisfy the child edge, and the\n          // child edge doesn't satisfy the parent edge, then we have\n          // a conflict.  this is always a problem in strict mode, never\n          // in force mode, and a problem in non-strict mode if this isn't\n          // on behalf of our project.  in all such cases, we warn at least.\n          const dep = await this[_nodeFromEdge](parentEdge, node.parent, edge, required); // hooray! that worked!\n\n          if (edge.valid) continue; // allow it.  either we're overriding, or it's not something\n          // that will be installed by default anyway, and we'll fail when\n          // we get to the point where we need to, if we need to.\n\n          if (conflictOK || !required.has(dep)) continue; // problem\n\n          this[_failPeerConflict](edge, parentEdge);\n        }\n      } // at this point we know that there is a dep there, and\n      // we don't like it.  always fail strictly, always allow forcibly or\n      // in non-strict mode if it's not our fault.  don't warn here, because\n      // we are going to warn again when we place the deps, if we end up\n      // overriding for something else.  If the thing that has this dep\n      // isn't also required, then there's a good chance we won't need it,\n      // so allow it for now and let it conflict if it turns out to actually\n      // be necessary for the installation.\n\n\n      if (conflictOK || !required.has(edge.from)) continue; // ok, it's the root, or we're in unforced strict mode, so this is bad\n\n      this[_failPeerConflict](edge, parentEdge);\n    }\n\n    return node;\n  }\n\n  [_failPeerConflict](edge, currentEdge) {\n    const expl = this[_explainPeerConflict](edge, currentEdge);\n\n    throw Object.assign(new Error('unable to resolve dependency tree'), expl);\n  }\n\n  [_explainPeerConflict](edge, currentEdge) {\n    const node = edge.from;\n    const curNode = node.resolve(edge.name);\n    const pc = this[_peerConflict] || {\n      peer: null,\n      current: null\n    };\n    const current = curNode ? curNode.explain() : pc.current;\n    const peerConflict = pc.peer;\n    return {\n      code: 'ERESOLVE',\n      current,\n      // it SHOULD be impossible to get here without a current node in place,\n      // but this at least gives us something report on when bugs creep into\n      // the tree handling logic.\n      currentEdge: currentEdge ? currentEdge.explain() : null,\n      edge: edge.explain(),\n      peerConflict,\n      strictPeerDeps: this[_strictPeerDeps],\n      force: this[_force]\n    };\n  }\n\n  [_warnPeerConflict](edge) {\n    // track that we've overridden this edge, so that we don't keep trying\n    // to re-resolve it in an infinite loop.\n    this[_edgesOverridden].add(edge);\n\n    const expl = this[_explainPeerConflict](edge);\n\n    this.log.warn('ERESOLVE', 'overriding peer dependency', expl);\n  } // starting from either node, or in the case of non-root peer deps,\n  // the node's parent, walk up the tree until we find the first spot\n  // where this dep cannot be placed, and use the one right before that.\n  // place dep, requested by node, to satisfy edge\n  // XXX split this out into a separate method or mixin?  It's quite a lot\n  // of functionality that ought to have its own unit tests more conveniently.\n\n\n  [_placeDep](dep, node, edge, peerEntryEdge = null, peerPath = []) {\n    if (edge.to && !edge.error && !this[_explicitRequests].has(edge) && !this[_updateNames].includes(edge.name) && !this[_isVulnerable](edge.to)) return []; // top nodes should still get peer deps from their fsParent if possible,\n    // and only install locally if there's no other option, eg for a link\n    // outside of the project root, or for a conflicted dep.\n\n    const start = edge.peer && !node.isProjectRoot ? node.resolveParent || node : node;\n    let target;\n    let canPlace = null;\n    let isSource = false;\n\n    const source = this[_peerSetSource].get(dep);\n\n    for (let check = start; check; check = check.resolveParent) {\n      // we always give the FIRST place we possibly *can* put this a little\n      // extra prioritization with peer dep overrides and deduping\n      if (check === source) isSource = true; // if the current location has a peerDep on it, then we can't place here\n      // this is pretty rare to hit, since we always prefer deduping peers.\n\n      const checkEdge = check.edgesOut.get(edge.name);\n      if (!check.isTop && checkEdge && checkEdge.peer) continue;\n\n      const cp = this[_canPlaceDep](dep, check, edge, peerEntryEdge, peerPath, isSource);\n\n      isSource = false; // anything other than a conflict is fine to proceed with\n\n      if (cp !== CONFLICT) {\n        canPlace = cp;\n        target = check;\n      } else break; // nest packages like npm v1 and v2\n      // very disk-inefficient\n\n\n      if (this[_legacyBundling]) break; // when installing globally, or just in global style, we never place\n      // deps above the first level.\n\n      const tree = this.idealTree && this.idealTree.target || this.idealTree;\n      if (this[_globalStyle] && check.resolveParent === tree) break;\n    } // if we can't find a target, that means that the last placed checked\n    // (and all the places before it) had a copy already.  if we're in\n    // --force mode, then the user has explicitly said that they're ok\n    // with conflicts.  This can only occur in --force mode in the case\n    // when a node was added to the tree with a peerOptional dep that we\n    // ignored, and then later, that edge became invalid, and we fail to\n    // resolve it.  We will warn about it in a moment.\n\n\n    if (!target) {\n      if (this[_force]) {\n        // we know that there is a dep (not the root) which is the target\n        // of this edge, or else it wouldn't have been a conflict.\n        target = edge.to.resolveParent;\n        canPlace = KEEP;\n      } else this[_failPeerConflict](edge);\n    } else {\n      // it worked, so we clearly have no peer conflicts at this point.\n      this[_peerConflict] = null;\n    }\n\n    this.log.silly('placeDep', target.location || 'ROOT', `${dep.name}@${dep.version}`, canPlace.description ||\n    /* istanbul ignore next */\n    canPlace, `for: ${node.package._id || node.location}`, `want: ${edge.spec || '*'}`); // Can only get KEEP here if the original edge was valid,\n    // and we're checking for an update but it's already up to date.\n\n    if (canPlace === KEEP) {\n      if (edge.peer && !target.children.get(edge.name).satisfies(edge)) {\n        // this is an overridden peer dep\n        this[_warnPeerConflict](edge);\n      }\n\n      return [];\n    } // figure out which of this node's peer deps will get placed as well\n\n\n    const virtualRoot = dep.parent;\n    const newDep = new dep.constructor({\n      name: dep.name,\n      pkg: dep.package,\n      resolved: dep.resolved,\n      integrity: dep.integrity,\n      legacyPeerDeps: this.legacyPeerDeps,\n      error: dep.errors[0],\n      ...(dep.target ? {\n        target: dep.target,\n        realpath: dep.target.path\n      } : {})\n    });\n    if (this[_loadFailures].has(dep)) this[_loadFailures].add(newDep);\n    const placed = [newDep];\n    const oldChild = target.children.get(edge.name);\n\n    if (oldChild) {\n      // if we're replacing, we should also remove any nodes for edges that\n      // are now invalid, and where this (or its deps) is the only dependent,\n      // and also recurse on that pruning.  Otherwise leaving that dep node\n      // around can result in spurious conflicts pushing nodes deeper into\n      // the tree than needed in the case of cycles that will be removed\n      // later anyway.\n      const oldDeps = [];\n\n      for (const [name, edge] of oldChild.edgesOut.entries()) {\n        if (!newDep.edgesOut.has(name) && edge.to) oldDeps.push(...gatherDepSet([edge.to], e => e.to !== edge.to));\n      }\n\n      newDep.replace(oldChild);\n\n      this[_pruneForReplacement](newDep, oldDeps); // this may also create some invalid edges, for example if we're\n      // intentionally causing something to get nested which was previously\n      // placed in this location.\n\n\n      for (const edgeIn of newDep.edgesIn) {\n        if (edgeIn.invalid && edgeIn !== edge) {\n          this[_depsQueue].push(edgeIn.from);\n\n          this[_depsSeen].delete(edgeIn.from);\n        }\n      }\n    } else newDep.parent = target;\n\n    if (edge.peer && !newDep.satisfies(edge)) {\n      // this is an overridden peer dep\n      this[_warnPeerConflict](edge);\n    } // If the edge is not an error, then we're updating something, and\n    // MAY end up putting a better/identical node further up the tree in\n    // a way that causes an unnecessary duplication.  If so, remove the\n    // now-unnecessary node.\n\n\n    if (edge.valid && edge.to.parent !== target && newDep.canReplace(edge.to)) edge.to.parent = null; // visit any dependents who are upset by this change\n    // if it's an angry overridden peer edge, however, make sure we\n    // skip over it!\n\n    for (const edgeIn of newDep.edgesIn) {\n      if (edgeIn !== edge && !edgeIn.valid && !this[_depsSeen].has(edge.from)) {\n        this.addTracker('idealTree', edgeIn.from.name, edgeIn.from.location);\n\n        this[_depsQueue].push(edgeIn.from);\n      }\n    } // in case we just made some duplicates that can be removed,\n    // prune anything deeper in the tree that can be replaced by this\n\n\n    if (this.idealTree) {\n      for (const node of this.idealTree.inventory.query('name', newDep.name)) {\n        if (node !== newDep && node.isDescendantOf(target) && !node.inShrinkwrap && !node.inBundle && node.canReplaceWith(newDep)) {\n          // don't prune if the dupe is necessary!\n          // root (a, d)\n          // +-- a (b, c2)\n          // |   +-- b (c2) <-- place c2 for b, lands at root\n          // +-- d (e)\n          //     +-- e (c1, d)\n          //         +-- c1\n          //         +-- f (c2)\n          //             +-- c2 <-- pruning this would be bad\n          const mask = node.parent !== target && node.parent && node.parent.parent && node.parent.parent !== target && node.parent.parent.resolve(newDep.name);\n          if (!mask || mask === newDep || node.canReplaceWith(mask)) node.parent = null;\n        }\n      }\n    } // also place its unmet or invalid peer deps at this location\n    // note that newDep has now been removed from the virtualRoot set\n    // by virtue of being placed in the target's node_modules.\n    // loop through any peer deps from the thing we just placed, and place\n    // those ones as well.  it's safe to do this with the virtual nodes,\n    // because we're copying rather than moving them out of the virtual root,\n    // otherwise they'd be gone and the peer set would change throughout\n    // this loop.\n\n\n    for (const peerEdge of newDep.edgesOut.values()) {\n      const peer = virtualRoot.children.get(peerEdge.name); // Note: if the virtualRoot *doesn't* have the peer, then that means\n      // it's an optional peer dep.  If it's not being properly met (ie,\n      // peerEdge.valid is false), that this is likely heading for an\n      // ERESOLVE error, unless it can walk further up the tree.\n\n      if (!peerEdge.peer || peerEdge.valid || !peer) continue;\n\n      const peerPlaced = this[_placeDep](peer, newDep, peerEdge, peerEntryEdge || edge, peerPath);\n\n      placed.push(...peerPlaced);\n    } // we're done with this now, clean it up.\n\n\n    this[_virtualRoots].delete(virtualRoot.sourceReference);\n\n    return placed;\n  }\n\n  [_pruneForReplacement](node, oldDeps) {\n    // gather up all the invalid edgesOut, and any now-extraneous\n    // deps that the new node doesn't depend on but the old one did.\n    const invalidDeps = new Set([...node.edgesOut.values()].filter(e => e.to && !e.valid).map(e => e.to));\n\n    for (const dep of oldDeps) {\n      const set = gatherDepSet([dep], e => e.to !== dep && e.valid);\n\n      for (const dep of set) invalidDeps.add(dep);\n    } // ignore dependency edges from the node being replaced, but\n    // otherwise filter the set down to just the set with no\n    // dependencies from outside the set, except the node in question.\n\n\n    const deps = gatherDepSet(invalidDeps, edge => edge.from !== node && edge.to !== node && edge.valid); // now just delete whatever's left, because it's junk\n\n    for (const dep of deps) dep.parent = null;\n  } // check if we can place DEP in TARGET to satisfy EDGE\n  // Need to verify:\n  // - no child by that name there already\n  // - target does not have a peer dep on name\n  // - no higher-level pkg by that name and incompatible spec is depended on\n  //   by anything lower in the tree.\n  // - node's peer deps and meta-peer deps are siblings in a virtual root at\n  //   this point.  make sure that the whole family can come along, so apply\n  //   the same checks to each of them.  They may land higher up in the tree,\n  //   but we need to know that they CAN live here.\n  // Responses:\n  // - OK - Yes, because there is nothing there and no conflicts caused\n  // - REPLACE - Yes, and you can clobber what's there\n  // - KEEP - No, but what's there is fine\n  // - CONFLICT - You may not put that there\n  //\n  // Check peers on OK or REPLACE.  KEEP and CONFLICT do not require peer\n  // checking, because either we're leaving it alone, or it won't work anyway.\n  // When we check peers, we pass along the peerEntryEdge to track the\n  // original edge that caused us to load the family of peer dependencies.\n\n\n  [_canPlaceDep](dep, target, edge, peerEntryEdge = null, peerPath = [], isSource = false) {\n    /* istanbul ignore next */\n    debug(() => {\n      if (!dep) throw new Error('no dep??');\n    });\n    const entryEdge = peerEntryEdge || edge;\n\n    const source = this[_peerSetSource].get(dep);\n\n    isSource = isSource || target === source; // if we're overriding the source, then we care if the *target* is\n    // ours, even if it wasn't actually the original source, since we\n    // are depending on something that has a dep that can't go in its own\n    // folder.  for example, a -> b, b -> PEER(a).  Even though a is the\n    // source, b has to be installed up a level, and if the root package\n    // depends on a, and it has a conflict, it's our problem.  So, the root\n    // (or whatever is bringing in a) becomes the \"effective source\" for\n    // the purposes of this calculation.\n\n    const {\n      isProjectRoot,\n      isWorkspace\n    } = isSource ? target : source || {};\n    const isMine = isProjectRoot || isWorkspace; // Useful testing thingie right here.\n    // peerEntryEdge should *always* be a non-peer dependency, or a peer\n    // dependency from the root node.  When we get spurious ERESOLVE errors,\n    // or *don't* get ERESOLVE errors when we should, check to see if this\n    // fails, because it MAY mean we got off track somehow.\n\n    /* istanbul ignore next - debug check, should be impossible */\n\n    debug(() => {\n      if (peerEntryEdge && peerEntryEdge.peer && !peerEntryEdge.from.isTop) throw new Error('lost original peerEntryEdge somehow?');\n    });\n\n    if (target.children.has(edge.name)) {\n      const current = target.children.get(edge.name); // same thing = keep, UNLESS the current doesn't satisfy and new\n      // one does satisfy.  This can happen if it's a link to a matching target\n      // at a different location, which satisfies a version dep, but not a\n      // file: dep.  If neither of them satisfy, then we can replace it,\n      // because presumably it's better for a peer or something.\n\n      if (dep.matches(current)) {\n        if (current.satisfies(edge) || !dep.satisfies(edge)) return KEEP;\n      }\n\n      const {\n        version: curVer\n      } = current;\n      const {\n        version: newVer\n      } = dep;\n      const tryReplace = curVer && newVer && semver.gte(newVer, curVer);\n\n      if (tryReplace && dep.canReplace(current)) {\n        const res = this[_canPlacePeers](dep, target, edge, REPLACE, peerEntryEdge, peerPath, isSource);\n        /* istanbul ignore else - It's extremely rare that a replaceable\n         * node would be a conflict, if the current one wasn't a conflict,\n         * but it is theoretically possible if peer deps are pinned.  In\n         * that case we treat it like any other conflict, and keep trying */\n\n\n        if (res !== CONFLICT) return res;\n      } // ok, can't replace the current with new one, but maybe current is ok?\n      // no need to check if it's a peer that's valid to be here, because\n      // peers are always placed along with their entry source\n\n\n      if (edge.satisfiedBy(current)) return KEEP; // if we prefer deduping, then try replacing newer with older\n      // we always prefer to dedupe peers, because they are trying\n      // a bit harder to be singletons.\n\n      const preferDedupe = this[_preferDedupe] || edge.peer;\n\n      if (preferDedupe && !tryReplace && dep.canReplace(current)) {\n        const res = this[_canPlacePeers](dep, target, edge, REPLACE, peerEntryEdge, peerPath, isSource);\n        /* istanbul ignore else - It's extremely rare that a replaceable\n         * node would be a conflict, if the current one wasn't a conflict,\n         * but it is theoretically possible if peer deps are pinned.  In\n         * that case we treat it like any other conflict, and keep trying */\n\n\n        if (res !== CONFLICT) return res;\n      } // check for conflict override cases.\n      // first: is this the only place this thing can go?  If the target is\n      // the source, then one of these things are true.\n      //\n      // 1. the conflicted dep was deduped up to here from a lower dependency\n      // w -> (x,y)\n      // x -> (z)\n      // y -> PEER(p@1)\n      // z -> (q)\n      // q -> (p@2)\n      //\n      // When building, let's say that x is fully placed, with all of its\n      // deps, and we're _adding_ y.  Since the peer on p@1 was not initially\n      // present, it's been deduped up to w, and now needs to be pushed out.\n      // Replace it, and potentially also replace its peer set (though that'll\n      // be accomplished by making the same determination when we call\n      // _canPlacePeers)\n      //\n      // 2. the dep we're TRYING to place here ought to be overridden by the\n      // one that's here now, because current is (a) a direct dep of the\n      // source, or (b) an already-placed peer in a conflicted peer set, or\n      // (c) an already-placed peer in a different peer set at the same level.\n      // If strict or ours, conflict.  Otherwise, keep.\n\n\n      if (isSource) {\n        // check to see if the current module could go deeper in the tree\n        let canReplace = true; // only do this check when we're placing peers.  when we're placing\n        // the original in the source, we know that the edge from the source\n        // is the thing we're trying to place, so its peer set will need to be\n        // placed here as well.  the virtualRoot already has the appropriate\n        // overrides applied.\n\n        if (peerEntryEdge) {\n          const peerSet = getPeerSet(current);\n\n          OUTER: for (const p of peerSet) {\n            // if any have a non-peer dep from the target, or a peer dep if\n            // the target is root, then cannot safely replace and dupe deeper.\n            for (const edge of p.edgesIn) {\n              if (peerSet.has(edge.from)) continue; // only respect valid edges, however, since we're likely trying\n              // to fix the very one that's currently broken!  If the virtual\n              // root's replacement is ok, and doesn't have any invalid edges\n              // indicating that it was an overridden peer, then ignore the\n              // conflict and continue.  If it WAS an override, then we need\n              // to get the conflict here so that we can decide whether to\n              // accept the current dep node, clobber it, or fail the install.\n\n              if (edge.from === target && edge.valid) {\n                const rep = dep.parent.children.get(edge.name);\n                const override = rep && [...rep.edgesIn].some(e => !e.valid);\n\n                if (!rep || !rep.satisfies(edge) || override) {\n                  canReplace = false;\n                  break OUTER;\n                }\n              }\n            }\n          }\n        }\n\n        if (canReplace) {\n          const ret = this[_canPlacePeers](dep, target, edge, REPLACE, peerEntryEdge, peerPath, isSource);\n          /* istanbul ignore else - extremely rare that the peer set would\n           * conflict if we can replace the node in question, but theoretically\n           * possible, if peer deps are pinned aggressively. */\n\n\n          if (ret !== CONFLICT) return ret;\n        } // so it's not a deeper dep that's been deduped.  That means that the\n        // only way it could have ended up here is if it's a conflicted peer.\n\n        /* istanbul ignore else - would have already crashed if not forced,\n         * and either mine or strict, when creating the peerSet.  Keeping this\n         * check so that we're not only relying on action at a distance. */\n\n\n        if (!this[_strictPeerDeps] && !isMine || this[_force]) {\n          this[_warnPeerConflict](edge, dep);\n\n          return KEEP;\n        }\n      } // no justification for overriding, and no agreement possible.\n\n\n      return CONFLICT;\n    } // no existing node at this location!\n    // check to see if the target doesn't have a child by that name,\n    // but WANTS one, and won't be happy with this one.  if this is the\n    // edge we're looking to resolve, then not relevant, of course.\n\n\n    if (target !== entryEdge.from && target.edgesOut.has(dep.name)) {\n      const targetEdge = target.edgesOut.get(dep.name); // It might be that the dep would not be valid here, BUT some other\n      // version would.  Could to try to resolve that, but that makes this no\n      // longer a pure synchronous function.  ugh.\n      // This is a pretty unlikely scenario in a normal install, because we\n      // resolve the peer dep set against the parent dependencies, and\n      // presumably they all worked together SOMEWHERE to get published in the\n      // first place, and since we resolve shallower deps before deeper ones,\n      // this can only occur by a child having a peer dep that does not satisfy\n      // the parent.  It can happen if we're doing a deep update limited by\n      // a specific name, however, or if a dep makes an incompatible change\n      // to its peer dep in a non-semver-major version bump, or if the parent\n      // is unbounded in its dependency list.\n\n      if (!targetEdge.satisfiedBy(dep)) return CONFLICT;\n    } // check to see what that name resolves to here, and who may depend on\n    // being able to reach it by crawling up past this parent.  we know\n    // at this point that it's not the target's direct child node.  if it's\n    // a direct dep of the target, we just make the invalid edge and\n    // resolve it later.\n\n\n    const current = target !== entryEdge.from && target.resolve(dep.name);\n\n    if (current) {\n      for (const edge of current.edgesIn.values()) {\n        if (edge.from.isDescendantOf(target) && edge.valid) {\n          if (!edge.satisfiedBy(dep)) return CONFLICT;\n        }\n      }\n    } // no objections!  ok to place here\n\n\n    return this[_canPlacePeers](dep, target, edge, OK, peerEntryEdge, peerPath, isSource);\n  } // make sure the family of peer deps can live here alongside it.\n  // this doesn't guarantee that THIS solution will be the one we take,\n  // but it does establish that SOME solution exists at this level in\n  // the tree.\n\n\n  [_canPlacePeers](dep, target, edge, ret, peerEntryEdge, peerPath, isSource) {\n    // do not go in cycles when we're resolving a peer group\n    if (!dep.parent || peerEntryEdge && peerPath.includes(dep)) return ret;\n    const entryEdge = peerEntryEdge || edge;\n    peerPath = [...peerPath, dep];\n\n    for (const peerEdge of dep.edgesOut.values()) {\n      if (!peerEdge.peer || !peerEdge.to) continue;\n      const peer = peerEdge.to;\n\n      const canPlacePeer = this[_canPlaceDep](peer, target, peerEdge, entryEdge, peerPath, isSource);\n\n      if (canPlacePeer !== CONFLICT) continue;\n      const current = target.resolve(peer.name);\n      this[_peerConflict] = {\n        peer: peer.explain(peerEdge),\n        current: current && current.explain()\n      };\n      return CONFLICT;\n    }\n\n    return ret;\n  } // go through all the links in the this[_linkNodes] set\n  // for each one:\n  // - if outside the root, ignore it, assume it's fine, it's not our problem\n  // - if a node in the tree already, assign the target to that node.\n  // - if a path under an existing node, then assign that as the fsParent,\n  //   and add it to the _depsQueue\n  //\n  // call buildDepStep if anything was added to the queue, otherwise we're done\n\n\n  [_resolveLinks]() {\n    for (const link of this[_linkNodes]) {\n      this[_linkNodes].delete(link); // link we never ended up placing, skip it\n\n\n      if (link.root !== this.idealTree) continue;\n      const external = /^\\.\\.(\\/|$)/.test(relpath(this.path, link.realpath)); // outside the root, somebody else's problem, ignore it\n\n      if (external && !this[_follow]) continue; // didn't find a parent for it or it has not been seen yet\n      // so go ahead and process it.\n\n      const unseenLink = (link.target.parent || link.target.fsParent) && !this[_depsSeen].has(link.target);\n\n      if (this[_follow] && !link.target.parent && !link.target.fsParent || unseenLink) {\n        this.addTracker('idealTree', link.target.name, link.target.location);\n\n        this[_depsQueue].push(link.target);\n      }\n    }\n\n    if (this[_depsQueue].length) return this[_buildDepStep]();\n  }\n\n  [_fixDepFlags]() {\n    process.emit('time', 'idealTree:fixDepFlags');\n    const metaFromDisk = this.idealTree.meta.loadedFromDisk;\n    const flagsSuspect = this[_flagsSuspect];\n    const mutateTree = this[_mutateTree]; // if the options set prune:false, then we don't prune, but we still\n    // mark the extraneous items in the tree if we modified it at all.\n    // If we did no modifications, we just iterate over the extraneous nodes.\n    // if we started with an empty tree, then the dep flags are already\n    // all set to true, and there can be nothing extraneous, so there's\n    // nothing to prune, because we built it from scratch.  if we didn't\n    // add or remove anything, then also nothing to do.\n\n    if (metaFromDisk && mutateTree) resetDepFlags(this.idealTree); // update all the dev/optional/etc flags in the tree\n    // either we started with a fresh tree, or we\n    // reset all the flags to find the extraneous nodes.\n    //\n    // if we started from a blank slate, or changed something, then\n    // the dep flags will be all set to true.\n\n    if (!metaFromDisk || mutateTree) calcDepFlags(this.idealTree);else {\n      // otherwise just unset all the flags on the root node\n      // since they will sometimes have the default value\n      this.idealTree.extraneous = false;\n      this.idealTree.dev = false;\n      this.idealTree.optional = false;\n      this.idealTree.devOptional = false;\n      this.idealTree.peer = false;\n    } // at this point, any node marked as extraneous should be pruned.\n    // if we started from a shrinkwrap, and then added/removed something,\n    // then the tree is suspect.  Prune what is marked as extraneous.\n    // otherwise, don't bother.\n\n    const needPrune = metaFromDisk && (mutateTree || flagsSuspect);\n    if (this[_prune] && needPrune) this[_idealTreePrune]();\n    process.emit('timeEnd', 'idealTree:fixDepFlags');\n  }\n\n  [_idealTreePrune]() {\n    for (const node of this.idealTree.inventory.filter(n => n.extraneous)) node.parent = null;\n  }\n\n  [_pruneFailedOptional]() {\n    for (const node of this[_loadFailures]) {\n      if (!node.optional) throw node.errors[0];\n      const set = optionalSet(node);\n\n      for (const node of set) node.parent = null;\n    }\n  }\n\n};","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/node_modules/@npmcli/arborist/lib/arborist/build-ideal-tree.js"],"names":["rpj","require","npa","pacote","cacache","semver","promiseCallLimit","getPeerSet","realpath","resolve","promisify","treeCheck","readdir","debug","fromPath","calcDepFlags","Shrinkwrap","Node","Link","addRmPkgDeps","gatherDepSet","optionalSet","checkEngine","checkPlatform","CONFLICT","Symbol","OK","KEEP","REPLACE","relpath","_complete","_depsSeen","_depsQueue","_currentDep","_updateAll","_mutateTree","_flagsSuspect","for","_workspaces","_prune","_preferDedupe","_legacyBundling","_parseSettings","_initTree","_applyUserRequests","_applyUserRequestsToNode","_inflateAncientLockfile","_buildDeps","_buildDepStep","_nodeFromEdge","_nodeFromSpec","_fetchManifest","_problemEdges","_manifests","_loadWorkspaces","_linkFromSpec","_loadPeerSet","_updateNames","_placeDep","_canPlaceDep","_canPlacePeers","_pruneForReplacement","_fixDepFlags","_resolveLinks","_rootNodeFromPackage","_add","_resolvedAdd","_queueNamedUpdates","_queueVulnDependents","_avoidRange","_shouldUpdateNode","resetDepFlags","_loadFailures","_pruneFailedOptional","_linkNodes","_follow","_globalStyle","_globalRootNode","_isVulnerable","_usePackageLock","_rpcache","_stcache","_updateFilePath","_followSymlinkPath","_getRelpathSpec","_retrieveSpecName","_strictPeerDeps","_checkEngineAndPlatform","_checkEngine","_checkPlatform","_virtualRoots","_virtualRoot","_peerConflict","_failPeerConflict","_explainPeerConflict","_warnPeerConflict","_edgesOverridden","_peerSetSource","_force","_explicitRequests","_global","_idealTreePrune","module","exports","cls","IdealTreeBuilder","constructor","options","registry","replace","idealTree","global","follow","globalStyle","legacyPeerDeps","force","packageLock","strictPeerDeps","workspaces","length","Error","Set","Map","WeakMap","explicitRequests","buildIdealTree","Promise","add","rm","process","emit","update","er","reject","addTracker","finishTracker","then","node","inventory","values","optional","package","engineStrict","npmVersion","nodeVersion","c","log","warn","code","message","pkgid","required","current","all","Array","isArray","names","complete","preferDedupe","legacyBundling","prune","path","pkg","root","reset","meta","Object","assign","loadVirtual","loadedFromDisk","loadActual","tree","target","children","size","virtualTree","dependencies","real","Cls","extraneous","dev","devOptional","peer","isLink","wsMap","promises","name","get","loc","push","globalExplicitUpdateNames","nm","catch","updateName","includes","auditReport","from","action","spec","edgesOut","saveType","saveBundle","map","rawSpec","isTag","type","mani","manifest","version","fetchSpec","filepath","nodes","bundler","getBundler","location","edge","edgesIn","topVulns","topVuln","entries","simpleRange","topNodes","fixAvailable","isSemVerMajor","breakingMessage","isVulnerable","vuln","range","set","filter","n","isTop","inDepBundle","inShrinkwrap","ancient","ancientLockfile","old","originalLockfileVersion","heading","queue","isProjectRoot","silly","resolved","integrity","useResolved","startsWith","id","sloc","substr","t","fullMetadata","_id","warning","sort","a","b","depth","localeCompare","shift","bd","bundleDependencies","hasBundle","hasShrinkwrap","has","crackOpen","Arborist","opt","tmp","withTmp","cache","extract","ignoreMissing","tasks","peerSource","source","virtualRoot","vrEdge","vrDep","valid","to","parent","dep","satisfies","placed","e","parent_","secondEdge","realParent","resolveParent","first","spec2","second","p","matches","src","sourceReference","reuse","vr","child","bundled","avoid","checkYarnLock","raw","error","requiredBy","link","peerEdges","parentEdge","isWorkspace","isMine","conflictOK","currentEdge","expl","curNode","pc","explain","peerConflict","peerEntryEdge","peerPath","start","canPlace","isSource","check","checkEdge","cp","description","newDep","errors","oldChild","oldDeps","edgeIn","invalid","delete","canReplace","query","isDescendantOf","inBundle","canReplaceWith","mask","peerEdge","peerPlaced","invalidDeps","deps","entryEdge","curVer","newVer","tryReplace","gte","res","satisfiedBy","peerSet","OUTER","rep","override","some","ret","targetEdge","canPlacePeer","external","test","unseenLink","fsParent","metaFromDisk","flagsSuspect","mutateTree","needPrune"],"mappings":"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","sourcesContent":["// mixin implementing the buildIdealTree method\nconst rpj = require('read-package-json-fast')\nconst npa = require('npm-package-arg')\nconst pacote = require('pacote')\nconst cacache = require('cacache')\nconst semver = require('semver')\nconst promiseCallLimit = require('promise-call-limit')\nconst getPeerSet = require('../peer-set.js')\nconst realpath = require('../../lib/realpath.js')\nconst { resolve } = require('path')\nconst { promisify } = require('util')\nconst treeCheck = require('../tree-check.js')\nconst readdir = promisify(require('readdir-scoped-modules'))\n\nconst debug = require('../debug.js')\nconst fromPath = require('../from-path.js')\nconst calcDepFlags = require('../calc-dep-flags.js')\nconst Shrinkwrap = require('../shrinkwrap.js')\nconst Node = require('../node.js')\nconst Link = require('../link.js')\nconst addRmPkgDeps = require('../add-rm-pkg-deps.js')\nconst gatherDepSet = require('../gather-dep-set.js')\nconst optionalSet = require('../optional-set.js')\nconst {checkEngine, checkPlatform} = require('npm-install-checks')\n\n// enum of return values for canPlaceDep.\n// No, this is a conflict, you may not put that package here\nconst CONFLICT = Symbol('CONFLICT')\n// Yes, this is fine, and should not be a problem\nconst OK = Symbol('OK')\n// No need, because the package already here is fine\nconst KEEP = Symbol('KEEP')\n// Yes, clobber the package that is already here\nconst REPLACE = Symbol('REPLACE')\n\nconst relpath = require('../relpath.js')\n\n// note: some of these symbols are shared so we can hit\n// them with unit tests and reuse them across mixins\nconst _complete = Symbol('complete')\nconst _depsSeen = Symbol('depsSeen')\nconst _depsQueue = Symbol('depsQueue')\nconst _currentDep = Symbol('currentDep')\nconst _updateAll = Symbol('updateAll')\nconst _mutateTree = Symbol('mutateTree')\nconst _flagsSuspect = Symbol.for('flagsSuspect')\nconst _workspaces = Symbol.for('workspaces')\nconst _prune = Symbol('prune')\nconst _preferDedupe = Symbol('preferDedupe')\nconst _legacyBundling = Symbol('legacyBundling')\nconst _parseSettings = Symbol('parseSettings')\nconst _initTree = Symbol('initTree')\nconst _applyUserRequests = Symbol('applyUserRequests')\nconst _applyUserRequestsToNode = Symbol('applyUserRequestsToNode')\nconst _inflateAncientLockfile = Symbol('inflateAncientLockfile')\nconst _buildDeps = Symbol('buildDeps')\nconst _buildDepStep = Symbol('buildDepStep')\nconst _nodeFromEdge = Symbol('nodeFromEdge')\nconst _nodeFromSpec = Symbol('nodeFromSpec')\nconst _fetchManifest = Symbol('fetchManifest')\nconst _problemEdges = Symbol('problemEdges')\nconst _manifests = Symbol('manifests')\nconst _loadWorkspaces = Symbol.for('loadWorkspaces')\nconst _linkFromSpec = Symbol('linkFromSpec')\nconst _loadPeerSet = Symbol('loadPeerSet')\nconst _updateNames = Symbol.for('updateNames')\nconst _placeDep = Symbol.for('placeDep')\nconst _canPlaceDep = Symbol.for('canPlaceDep')\nconst _canPlacePeers = Symbol('canPlacePeers')\nconst _pruneForReplacement = Symbol('pruneForReplacement')\nconst _fixDepFlags = Symbol('fixDepFlags')\nconst _resolveLinks = Symbol('resolveLinks')\nconst _rootNodeFromPackage = Symbol('rootNodeFromPackage')\nconst _add = Symbol('add')\nconst _resolvedAdd = Symbol.for('resolvedAdd')\nconst _queueNamedUpdates = Symbol('queueNamedUpdates')\nconst _queueVulnDependents = Symbol('queueVulnDependents')\nconst _avoidRange = Symbol('avoidRange')\nconst _shouldUpdateNode = Symbol('shouldUpdateNode')\nconst resetDepFlags = require('../reset-dep-flags.js')\nconst _loadFailures = Symbol('loadFailures')\nconst _pruneFailedOptional = Symbol('pruneFailedOptional')\nconst _linkNodes = Symbol('linkNodes')\nconst _follow = Symbol('follow')\nconst _globalStyle = Symbol('globalStyle')\nconst _globalRootNode = Symbol('globalRootNode')\nconst _isVulnerable = Symbol.for('isVulnerable')\nconst _usePackageLock = Symbol.for('usePackageLock')\nconst _rpcache = Symbol.for('realpathCache')\nconst _stcache = Symbol.for('statCache')\nconst _updateFilePath = Symbol('updateFilePath')\nconst _followSymlinkPath = Symbol('followSymlinkPath')\nconst _getRelpathSpec = Symbol('getRelpathSpec')\nconst _retrieveSpecName = Symbol('retrieveSpecName')\nconst _strictPeerDeps = Symbol('strictPeerDeps')\nconst _checkEngineAndPlatform = Symbol('checkEngineAndPlatform')\nconst _checkEngine = Symbol('checkEngine')\nconst _checkPlatform = Symbol('checkPlatform')\nconst _virtualRoots = Symbol('virtualRoots')\nconst _virtualRoot = Symbol('virtualRoot')\n\n// used for the ERESOLVE error to show the last peer conflict encountered\nconst _peerConflict = Symbol('peerConflict')\n\nconst _failPeerConflict = Symbol('failPeerConflict')\nconst _explainPeerConflict = Symbol('explainPeerConflict')\nconst _warnPeerConflict = Symbol('warnPeerConflict')\nconst _edgesOverridden = Symbol('edgesOverridden')\n// exposed symbol for unit testing the placeDep method directly\nconst _peerSetSource = Symbol.for('peerSetSource')\n\n// used by Reify mixin\nconst _force = Symbol.for('force')\nconst _explicitRequests = Symbol('explicitRequests')\nconst _global = Symbol.for('global')\nconst _idealTreePrune = Symbol.for('idealTreePrune')\n\nmodule.exports = cls => class IdealTreeBuilder extends cls {\n  constructor (options) {\n    super(options)\n\n    // normalize trailing slash\n    const registry = options.registry || 'https://registry.npmjs.org'\n    options.registry = this.registry = registry.replace(/\\/+$/, '') + '/'\n\n    const {\n      idealTree = null,\n      global = false,\n      follow = false,\n      globalStyle = false,\n      legacyPeerDeps = false,\n      force = false,\n      packageLock = true,\n      strictPeerDeps = false,\n      workspaces = [],\n    } = options\n\n    this[_workspaces] = workspaces || []\n    this[_force] = !!force\n    this[_strictPeerDeps] = !!strictPeerDeps\n\n    this.idealTree = idealTree\n    this.legacyPeerDeps = legacyPeerDeps\n\n    this[_usePackageLock] = packageLock\n    this[_global] = !!global\n    this[_globalStyle] = this[_global] || globalStyle\n    this[_follow] = !!follow\n\n    if (this[_workspaces].length && this[_global])\n      throw new Error('Cannot operate on workspaces in global mode')\n\n    this[_explicitRequests] = new Set()\n    this[_preferDedupe] = false\n    this[_legacyBundling] = false\n    this[_depsSeen] = new Set()\n    this[_depsQueue] = []\n    this[_currentDep] = null\n    this[_updateNames] = []\n    this[_updateAll] = false\n    this[_mutateTree] = false\n    this[_loadFailures] = new Set()\n    this[_linkNodes] = new Set()\n    this[_manifests] = new Map()\n    this[_peerConflict] = null\n    this[_edgesOverridden] = new Set()\n    this[_resolvedAdd] = []\n\n    // a map of each module in a peer set to the thing that depended on\n    // that set of peers in the first place.  Use a WeakMap so that we\n    // don't hold onto references for nodes that are garbage collected.\n    this[_peerSetSource] = new WeakMap()\n    this[_virtualRoots] = new Map()\n  }\n\n  get explicitRequests () {\n    return new Set(this[_explicitRequests])\n  }\n\n  // public method\n  async buildIdealTree (options = {}) {\n    if (this.idealTree)\n      return Promise.resolve(this.idealTree)\n\n    // allow the user to set reify options on the ctor as well.\n    // XXX: deprecate separate reify() options object.\n    options = { ...this.options, ...options }\n\n    // an empty array or any falsey value is the same as null\n    if (!options.add || options.add.length === 0)\n      options.add = null\n    if (!options.rm || options.rm.length === 0)\n      options.rm = null\n\n    process.emit('time', 'idealTree')\n\n    if (!options.add && !options.rm && !options.update && this[_global]) {\n      const er = new Error('global requires add, rm, or update option')\n      return Promise.reject(er)\n    }\n\n    // first get the virtual tree, if possible.  If there's a lockfile, then\n    // that defines the ideal tree, unless the root package.json is not\n    // satisfied by what the ideal tree provides.\n    // from there, we start adding nodes to it to satisfy the deps requested\n    // by the package.json in the root.\n\n    this[_parseSettings](options)\n\n    // start tracker block\n    this.addTracker('idealTree')\n\n    try {\n      await this[_initTree]()\n      await this[_inflateAncientLockfile]()\n      await this[_applyUserRequests](options)\n      await this[_buildDeps]()\n      await this[_fixDepFlags]()\n      await this[_pruneFailedOptional]()\n      await this[_checkEngineAndPlatform]()\n    } finally {\n      process.emit('timeEnd', 'idealTree')\n      this.finishTracker('idealTree')\n    }\n\n    return treeCheck(this.idealTree)\n  }\n\n  [_checkEngineAndPlatform] () {\n    // engine/platform checks throw, so start the promise chain off first\n    return Promise.resolve()\n      .then(() => {\n        for (const node of this.idealTree.inventory.values()) {\n          if (!node.optional) {\n            this[_checkEngine](node)\n            this[_checkPlatform](node)\n          }\n        }\n      })\n  }\n\n  [_checkPlatform] (node) {\n    checkPlatform(node.package, this[_force])\n  }\n\n  [_checkEngine] (node) {\n    const { engineStrict, npmVersion, nodeVersion } = this.options\n    const c = () => checkEngine(node.package, npmVersion, nodeVersion, this[_force])\n\n    if (engineStrict)\n      c()\n    else {\n      try {\n        c()\n      } catch (er) {\n        this.log.warn(er.code, er.message, {\n          package: er.pkgid,\n          required: er.required,\n          current: er.current,\n        })\n      }\n    }\n  }\n\n  [_parseSettings] (options) {\n    const update = options.update === true ? { all: true }\n      : Array.isArray(options.update) ? { names: options.update }\n      : options.update || {}\n\n    if (update.all || !Array.isArray(update.names))\n      update.names = []\n\n    this[_complete] = !!options.complete\n    this[_preferDedupe] = !!options.preferDedupe\n    this[_legacyBundling] = !!options.legacyBundling\n    this[_updateNames] = update.names\n\n    this[_updateAll] = update.all\n    // we prune by default unless explicitly set to boolean false\n    this[_prune] = options.prune !== false\n\n    // set if we add anything, but also set here if we know we'll make\n    // changes and thus have to maybe prune later.\n    this[_mutateTree] = !!(\n      options.add ||\n      options.rm ||\n      update.all ||\n      update.names.length\n    )\n  }\n\n  // load the initial tree, either the virtualTree from a shrinkwrap,\n  // or just the root node from a package.json\n  [_initTree] () {\n    process.emit('time', 'idealTree:init')\n    return (\n      this[_global] ? this[_globalRootNode]()\n      : rpj(this.path + '/package.json').then(\n        pkg => this[_rootNodeFromPackage](pkg),\n        er => {\n          if (er.code === 'EJSONPARSE')\n            throw er\n          return this[_rootNodeFromPackage]({})\n        }\n      ))\n      .then(root => this[_loadWorkspaces](root))\n      // ok to not have a virtual tree.  probably initial install.\n      // When updating all, we load the shrinkwrap, but don't bother\n      // to build out the full virtual tree from it, since we'll be\n      // reconstructing it anyway.\n      .then(root => this[_global] ? root\n      : !this[_usePackageLock] || this[_updateAll]\n        ? Shrinkwrap.reset({ path: this.path })\n          .then(meta => Object.assign(root, {meta}))\n        : this.loadVirtual({ root }))\n\n      // if we don't have a lockfile to go from, then start with the\n      // actual tree, so we only make the minimum required changes.\n      // don't do this for global installs or updates, because in those\n      // cases we don't use a lockfile anyway.\n      // Load on a new Arborist object, so the Nodes aren't the same,\n      // or else it'll get super confusing when we change them!\n      .then(async root => {\n        if (!this[_updateAll] && !this[_global] && !root.meta.loadedFromDisk) {\n          await new this.constructor(this.options).loadActual({ root })\n          const tree = root.target || root\n          // even though we didn't load it from a package-lock.json FILE,\n          // we still loaded it \"from disk\", meaning we have to reset\n          // dep flags before assuming that any mutations were reflected.\n          if (tree.children.size)\n            root.meta.loadedFromDisk = true\n        }\n        return root\n      })\n\n      .then(tree => {\n        // null the virtual tree, because we're about to hack away at it\n        // if you want another one, load another copy.\n        this.idealTree = tree\n        this.virtualTree = null\n        process.emit('timeEnd', 'idealTree:init')\n      })\n  }\n\n  async [_globalRootNode] () {\n    const root = await this[_rootNodeFromPackage]({ dependencies: {} })\n    // this is a gross kludge to handle the fact that we don't save\n    // metadata on the root node in global installs, because the \"root\"\n    // node is something like /usr/local/lib.\n    const meta = new Shrinkwrap({ path: this.path })\n    meta.reset()\n    root.meta = meta\n    return root\n  }\n\n  async [_rootNodeFromPackage] (pkg) {\n    // if the path doesn't exist, then we explode at this point. Note that\n    // this is not a problem for reify(), since it creates the root path\n    // before ever loading trees.\n    // TODO: make buildIdealTree() and loadActual handle a missing root path,\n    // or a symlink to a missing target, and let reify() create it as needed.\n    const real = await realpath(this.path, this[_rpcache], this[_stcache])\n    const Cls = real === this.path ? Node : Link\n    const root = new Cls({\n      path: this.path,\n      realpath: real,\n      pkg,\n      extraneous: false,\n      dev: false,\n      devOptional: false,\n      peer: false,\n      optional: false,\n      global: this[_global],\n      legacyPeerDeps: this.legacyPeerDeps,\n    })\n    if (root.isLink) {\n      root.target = new Node({\n        path: real,\n        realpath: real,\n        pkg,\n        extraneous: false,\n        dev: false,\n        devOptional: false,\n        peer: false,\n        optional: false,\n        global: this[_global],\n        legacyPeerDeps: this.legacyPeerDeps,\n        root,\n      })\n    }\n    return root\n  }\n\n  // process the add/rm requests by modifying the root node, and the\n  // update.names request by queueing nodes dependent on those named.\n  async [_applyUserRequests] (options) {\n    process.emit('time', 'idealTree:userRequests')\n    const tree = this.idealTree.target || this.idealTree\n\n    if (!this[_workspaces].length) {\n      return this[_applyUserRequestsToNode](tree, options).then(() =>\n        process.emit('timeEnd', 'idealTree:userRequests'))\n    }\n\n    const wsMap = tree.workspaces\n    if (!wsMap) {\n      this.log.warn('idealTree', 'Workspace filter set, but no workspaces present')\n      return\n    }\n\n    const promises = []\n    for (const name of this[_workspaces]) {\n      const path = wsMap.get(name)\n      if (!path) {\n        this.log.warn('idealTree', `Workspace ${name} in filter set, but not in workspaces`)\n        continue\n      }\n      const loc = relpath(tree.realpath, path)\n      const node = tree.inventory.get(loc)\n\n      /* istanbul ignore if - should be impossible */\n      if (!node) {\n        this.log.warn('idealTree', `Workspace ${name} in filter set, but no workspace folder present`)\n        continue\n      }\n\n      promises.push(this[_applyUserRequestsToNode](node, options))\n    }\n\n    return Promise.all(promises).then(() =>\n      process.emit('timeEnd', 'idealTree:userRequests'))\n  }\n\n  async [_applyUserRequestsToNode] (tree, options) {\n    // If we have a list of package names to update, and we know it's\n    // going to update them wherever they are, add any paths into those\n    // named nodes to the buildIdealTree queue.\n    if (!this[_global] && this[_updateNames].length)\n      this[_queueNamedUpdates]()\n\n    // global updates only update the globalTop nodes, but we need to know\n    // that they're there, and not reinstall the world unnecessarily.\n    const globalExplicitUpdateNames = []\n    if (this[_global] && (this[_updateAll] || this[_updateNames].length)) {\n      const nm = resolve(this.path, 'node_modules')\n      for (const name of await readdir(nm).catch(() => [])) {\n        tree.package.dependencies = tree.package.dependencies || {}\n        const updateName = this[_updateNames].includes(name)\n        if (this[_updateAll] || updateName) {\n          if (updateName)\n            globalExplicitUpdateNames.push(name)\n          tree.package.dependencies[name] = '*'\n        }\n      }\n    }\n\n    if (this.auditReport && this.auditReport.size > 0)\n      this[_queueVulnDependents](options)\n\n    const { add, rm } = options\n\n    if (rm && rm.length) {\n      addRmPkgDeps.rm(tree.package, rm)\n      for (const name of rm)\n        this[_explicitRequests].add({ from: tree, name, action: 'DELETE' })\n    }\n\n    if (add && add.length)\n      await this[_add](tree, options)\n\n    // triggers a refresh of all edgesOut.  this has to be done BEFORE\n    // adding the edges to explicitRequests, because the package setter\n    // resets all edgesOut.\n    if (add && add.length || rm && rm.length || this[_global])\n      tree.package = tree.package\n\n    for (const spec of this[_resolvedAdd])\n      this[_explicitRequests].add(tree.edgesOut.get(spec.name))\n    for (const name of globalExplicitUpdateNames)\n      this[_explicitRequests].add(tree.edgesOut.get(name))\n  }\n\n  // This returns a promise because we might not have the name yet,\n  // and need to call pacote.manifest to find the name.\n  [_add] (tree, {add, saveType = null, saveBundle = false}) {\n    // get the name for each of the specs in the list.\n    // ie, doing `foo@bar` we just return foo\n    // but if it's a url or git, we don't know the name until we\n    // fetch it and look in its manifest.\n    return Promise.all(add.map(rawSpec => {\n      // We do NOT provide the path here, because user-additions need\n      // to be resolved relative to the CWD the user is in.\n      return this[_retrieveSpecName](npa(rawSpec))\n        .then(add => this[_updateFilePath](add))\n        .then(add => this[_followSymlinkPath](add))\n    })).then(add => {\n      this[_resolvedAdd].push(...add)\n      // now add is a list of spec objects with names.\n      // find a home for each of them!\n      addRmPkgDeps.add({\n        pkg: tree.package,\n        add,\n        saveBundle,\n        saveType,\n        path: this.path,\n      })\n    })\n  }\n\n  async [_retrieveSpecName] (spec) {\n    // if it's just @'' then we reload whatever's there, or get latest\n    // if it's an explicit tag, we need to install that specific tag version\n    const isTag = spec.rawSpec && spec.type === 'tag'\n\n    if (spec.name && !isTag)\n      return spec\n\n    const mani = await pacote.manifest(spec, { ...this.options })\n    // if it's a tag type, then we need to run it down to an actual version\n    if (isTag)\n      return npa(`${mani.name}@${mani.version}`)\n\n    spec.name = mani.name\n    return spec\n  }\n\n  async [_updateFilePath] (spec) {\n    if (spec.type === 'file')\n      spec = this[_getRelpathSpec](spec, spec.fetchSpec)\n\n    return spec\n  }\n\n  async [_followSymlinkPath] (spec) {\n    if (spec.type === 'directory') {\n      const real = await (\n        realpath(spec.fetchSpec, this[_rpcache], this[_stcache])\n          // TODO: create synthetic test case to simulate realpath failure\n          .catch(/* istanbul ignore next */() => null)\n      )\n\n      spec = this[_getRelpathSpec](spec, real)\n    }\n    return spec\n  }\n\n  [_getRelpathSpec] (spec, filepath) {\n    /* istanbul ignore else - should also be covered by realpath failure */\n    if (filepath) {\n      const { name } = spec\n      const tree = this.idealTree.target || this.idealTree\n      spec = npa(`file:${relpath(tree.path, filepath)}`, tree.path)\n      spec.name = name\n    }\n    return spec\n  }\n\n  // TODO: provide a way to fix bundled deps by exposing metadata about\n  // what's in the bundle at each published manifest.  Without that, we\n  // can't possibly fix bundled deps without breaking a ton of other stuff,\n  // and leaving the user subject to getting it overwritten later anyway.\n  [_queueVulnDependents] (options) {\n    for (const {nodes} of this.auditReport.values()) {\n      for (const node of nodes) {\n        const bundler = node.getBundler()\n\n        // XXX this belongs in the audit report itself, not here.\n        // We shouldn't even get these things here, and they shouldn't\n        // be printed by npm-audit-report as if they can be fixed, because\n        // they can't.\n        if (bundler) {\n          this.log.warn(`audit fix ${node.name}@${node.version}`,\n            `${node.location}\\nis a bundled dependency of\\n${\n            bundler.name}@${bundler.version} at ${bundler.location}\\n` +\n            'It cannot be fixed automatically.\\n' +\n            `Check for updates to the ${bundler.name} package.`)\n          continue\n        }\n\n        for (const edge of node.edgesIn) {\n          this.addTracker('idealTree', edge.from.name, edge.from.location)\n          this[_depsQueue].push(edge.from)\n        }\n      }\n    }\n\n    // note any that can't be fixed at the root level without --force\n    // if there's a fix, we use that.  otherwise, the user has to remove it,\n    // find a different thing, fix the upstream, etc.\n    //\n    // XXX: how to handle top nodes that aren't the root?  Maybe the report\n    // just tells the user to cd into that directory and fix it?\n    if (this[_force] && this.auditReport && this.auditReport.topVulns.size) {\n      options.add = options.add || []\n      options.rm = options.rm || []\n      for (const [name, topVuln] of this.auditReport.topVulns.entries()) {\n        const {\n          simpleRange,\n          topNodes,\n          fixAvailable,\n        } = topVuln\n        for (const node of topNodes) {\n          if (node !== this.idealTree && node !== this.idealTree.target) {\n            // not something we're going to fix, sorry.  have to cd into\n            // that directory and fix it yourself.\n            this.log.warn('audit', 'Manual fix required in linked project ' +\n              `at ./${node.location} for ${name}@${simpleRange}.\\n` +\n              `'cd ./${node.location}' and run 'npm audit' for details.`)\n            continue\n          }\n\n          if (!fixAvailable) {\n            this.log.warn('audit', `No fix available for ${name}@${simpleRange}`)\n            continue\n          }\n\n          const { isSemVerMajor, version } = fixAvailable\n          const breakingMessage = isSemVerMajor\n            ? 'a SemVer major change'\n            : 'outside your stated dependency range'\n          this.log.warn('audit', `Updating ${name} to ${version},` +\n            `which is ${breakingMessage}.`)\n          options.add.push(`${name}@${version}`)\n        }\n      }\n    }\n  }\n\n  [_isVulnerable] (node) {\n    return this.auditReport && this.auditReport.isVulnerable(node)\n  }\n\n  [_avoidRange] (name) {\n    if (!this.auditReport)\n      return null\n    const vuln = this.auditReport.get(name)\n    if (!vuln)\n      return null\n    return vuln.range\n  }\n\n  [_queueNamedUpdates] () {\n    // ignore top nodes, since they are not loaded the same way, and\n    // probably have their own project associated with them.\n\n    // for every node with one of the names on the list, we add its\n    // dependents to the queue to be evaluated.  in buildDepStem,\n    // anything on the update names list will get refreshed, even if\n    // it isn't a problem.\n\n    // XXX this could be faster by doing a series of inventory.query('name')\n    // calls rather than walking over everything in the tree.\n    const set = this.idealTree.inventory\n      .filter(n => this[_shouldUpdateNode](n))\n    for (const node of set) {\n      for (const edge of node.edgesIn) {\n        this.addTracker('idealTree', edge.from.name, edge.from.location)\n        this[_depsQueue].push(edge.from)\n      }\n    }\n  }\n\n  [_shouldUpdateNode] (node) {\n    return this[_updateNames].includes(node.name) &&\n      !node.isTop &&\n      !node.inDepBundle &&\n      !node.inShrinkwrap\n  }\n\n  async [_inflateAncientLockfile] () {\n    const { meta, inventory } = this.idealTree\n    const ancient = meta.ancientLockfile\n    const old = meta.loadedFromDisk && !(meta.originalLockfileVersion >= 2)\n\n    if (inventory.size === 0 || !ancient && !(old && this[_complete]))\n      return\n\n    // if the lockfile is from node v5 or earlier, then we'll have to reload\n    // all the manifests of everything we encounter.  this is costly, but at\n    // least it's just a one-time hit.\n    process.emit('time', 'idealTree:inflate')\n\n    const heading = ancient ? 'ancient lockfile' : 'old lockfile'\n    this.log.warn(heading,\n      `\nThe ${meta.type} file was created with an old version of npm,\nso supplemental metadata must be fetched from the registry.\n\nThis is a one-time fix-up, please be patient...\n`)\n\n    this.addTracker('idealTree:inflate')\n    const queue = []\n    for (const node of inventory.values()) {\n      if (node.isProjectRoot)\n        continue\n\n      queue.push(async () => {\n        this.log.silly('inflate', node.location)\n        const { resolved, version, path, name, location, integrity } = node\n        // don't try to hit the registry for linked deps\n        const useResolved = !version ||\n          resolved && resolved.startsWith('file:')\n        const id = useResolved ? resolved : version\n        const spec = npa.resolve(name, id, path)\n        const sloc = location.substr('node_modules/'.length)\n        const t = `idealTree:inflate:${sloc}`\n        this.addTracker(t)\n        await pacote.manifest(spec, {\n          ...this.options,\n          resolved: resolved,\n          integrity: integrity,\n          fullMetadata: false,\n        }).then(mani => {\n          node.package = { ...mani, _id: `${mani.name}@${mani.version}` }\n        }).catch((er) => {\n          const warning = `Could not fetch metadata for ${name}@${id}`\n          this.log.warn(heading, warning, er)\n        })\n        this.finishTracker(t)\n      })\n    }\n    await promiseCallLimit(queue)\n\n    // have to re-calc dep flags, because the nodes don't have edges\n    // until their packages get assigned, so everything looks extraneous\n    calcDepFlags(this.idealTree)\n\n    // yes, yes, this isn't the \"original\" version, but now that it's been\n    // upgraded, we need to make sure we don't do the work to upgrade it\n    // again, since it's now as new as can be.\n    meta.originalLockfileVersion = 2\n    this.finishTracker('idealTree:inflate')\n    process.emit('timeEnd', 'idealTree:inflate')\n  }\n\n  // at this point we have a virtual tree with the actual root node's\n  // package deps, which may be partly or entirely incomplete, invalid\n  // or extraneous.\n  [_buildDeps] () {\n    process.emit('time', 'idealTree:buildDeps')\n    const tree = this.idealTree.target || this.idealTree\n    this[_depsQueue].push(tree)\n    this.log.silly('idealTree', 'buildDeps')\n    this.addTracker('idealTree', tree.name, '')\n    return this[_buildDepStep]()\n      .then(() => process.emit('timeEnd', 'idealTree:buildDeps'))\n  }\n\n  async [_buildDepStep] () {\n    // removes tracker of previous dependency in the queue\n    if (this[_currentDep]) {\n      const { location, name } = this[_currentDep]\n      process.emit('timeEnd', `idealTree:${location || '#root'}`)\n      this.finishTracker('idealTree', name, location)\n      this[_currentDep] = null\n    }\n\n    if (!this[_depsQueue].length)\n      return this[_resolveLinks]()\n\n    // sort physically shallower deps up to the front of the queue,\n    // because they'll affect things deeper in, then alphabetical\n    this[_depsQueue].sort((a, b) =>\n      (a.depth - b.depth) || a.path.localeCompare(b.path))\n\n    const node = this[_depsQueue].shift()\n    const bd = node.package.bundleDependencies\n    const hasBundle = bd && Array.isArray(bd) && bd.length\n    const { hasShrinkwrap } = node\n\n    // if the node was already visited, or has since been removed from the\n    // tree, skip over it and process the rest of the queue.  If a node has\n    // a shrinkwrap, also skip it, because it's going to get its deps\n    // satisfied by whatever's in that file anyway.\n    if (this[_depsSeen].has(node) ||\n        node.root !== this.idealTree ||\n        hasShrinkwrap && !this[_complete])\n      return this[_buildDepStep]()\n\n    this[_depsSeen].add(node)\n    this[_currentDep] = node\n    process.emit('time', `idealTree:${node.location || '#root'}`)\n\n    // if we're loading a _complete_ ideal tree, for a --package-lock-only\n    // installation for example, we have to crack open the tarball and\n    // look inside if it has bundle deps or shrinkwraps.  note that this is\n    // not necessary during a reification, because we just update the\n    // ideal tree by reading bundles/shrinkwraps in place.\n    // Don't bother if the node is from the actual tree and hasn't\n    // been resolved, because we can't fetch it anyway, could be anything!\n    const crackOpen = this[_complete] &&\n      node !== this.idealTree &&\n      node.resolved &&\n      (hasBundle || hasShrinkwrap)\n    if (crackOpen) {\n      const Arborist = this.constructor\n      const opt = { ...this.options }\n      await cacache.tmp.withTmp(this.cache, opt, async path => {\n        await pacote.extract(node.resolved, path, opt)\n\n        if (hasShrinkwrap) {\n          await new Arborist({ ...this.options, path })\n            .loadVirtual({ root: node })\n        }\n\n        if (hasBundle) {\n          await new Arborist({ ...this.options, path })\n            .loadActual({ root: node, ignoreMissing: true })\n        }\n      })\n    }\n\n    // if any deps are missing or invalid, then we fetch the manifest for\n    // the thing we want, and build a new dep node from that.\n    // Then, find the ideal placement for that node.  The ideal placement\n    // searches from the node's deps (or parent deps in the case of non-root\n    // peer deps), and walks up the tree until it finds the highest spot\n    // where it doesn't cause any conflicts.\n    //\n    // A conflict can be:\n    // - A node by that name already exists at that location.\n    // - The parent has a peer dep on that name\n    // - One of the node's peer deps conflicts at that location, unless the\n    //   peer dep is met by a node at that location, which is fine.\n    //\n    // If we create a new node, then build its ideal deps as well.\n    //\n    // Note: this is the same \"maximally naive\" deduping tree-building\n    // algorithm that npm has used since v3.  In a case like this:\n    //\n    // root -> (a@1, b@1||2)\n    // a -> (b@1)\n    //\n    // You'll end up with a tree like this:\n    //\n    // root\n    // +-- a@1\n    // |   +-- b@1\n    // +-- b@2\n    //\n    // rather than this, more deduped, but just as correct tree:\n    //\n    // root\n    // +-- a@1\n    // +-- b@1\n    //\n    // Another way to look at it is that this algorithm favors getting higher\n    // version deps at higher levels in the tree, even if that reduces\n    // potential deduplication.\n    //\n    // Set `preferDedupe: true` in the options to replace the shallower\n    // dep if allowed.\n\n    const tasks = []\n    const peerSource = this[_peerSetSource].get(node) || node\n    for (const edge of this[_problemEdges](node)) {\n      if (this[_edgesOverridden].has(edge))\n        continue\n\n      // peerSetSource is only relevant when we have a peerEntryEdge\n      // otherwise we're setting regular non-peer deps as if they have\n      // a virtual root of whatever brought in THIS node.\n      // so we VR the node itself if the edge is not a peer\n      const source = edge.peer ? peerSource : node\n\n      const virtualRoot = this[_virtualRoot](source, true)\n      // reuse virtual root if we already have one, but don't\n      // try to do the override ahead of time, since we MAY be able\n      // to create a more correct tree than the virtual root could.\n      const vrEdge = virtualRoot && virtualRoot.edgesOut.get(edge.name)\n      const vrDep = vrEdge && vrEdge.valid && vrEdge.to\n      // only re-use the virtualRoot if it's a peer edge we're placing.\n      // otherwise, we end up in situations where we override peer deps that\n      // we could have otherwise found homes for.  Eg:\n      // xy -> (x, y)\n      // x -> PEER(z@1)\n      // y -> PEER(z@2)\n      // If xy is a dependency, we can resolve this like:\n      // project\n      // +-- xy\n      // |   +-- y\n      // |   +-- z@2\n      // +-- x\n      // +-- z@1\n      // But if x and y are loaded in the same virtual root, then they will\n      // be forced to agree on a version of z.\n      const required = new Set([edge.from])\n      const parent = edge.peer ? virtualRoot : null\n      const dep = vrDep && vrDep.satisfies(edge) ? vrDep\n        : await this[_nodeFromEdge](edge, parent, null, required)\n\n      /* istanbul ignore next */\n      debug(() => {\n        if (!dep)\n          throw new Error('no dep??')\n      })\n\n      tasks.push({edge, dep})\n    }\n\n    const placed = tasks\n      .sort((a, b) => a.edge.name.localeCompare(b.edge.name))\n      .map(({ edge, dep }) => this[_placeDep](dep, node, edge))\n\n    const promises = []\n    for (const set of placed) {\n      for (const node of set) {\n        this[_mutateTree] = true\n        this.addTracker('idealTree', node.name, node.location)\n        this[_depsQueue].push(node)\n\n        // we're certainly going to need these soon, fetch them asap\n        // if it fails at this point, though, dont' worry because it\n        // may well be an optional dep that has gone missing.  it'll\n        // fail later anyway.\n        const from = fromPath(node)\n        promises.push(...this[_problemEdges](node).map(e =>\n          this[_fetchManifest](npa.resolve(e.name, e.spec, from))\n            .catch(er => null)))\n      }\n    }\n    await Promise.all(promises)\n\n    for (const { to } of node.edgesOut.values()) {\n      if (to && to.isLink)\n        this[_linkNodes].add(to)\n    }\n\n    return this[_buildDepStep]()\n  }\n\n  // loads a node from an edge, and then loads its peer deps (and their\n  // peer deps, on down the line) into a virtual root parent.\n  async [_nodeFromEdge] (edge, parent_, secondEdge, required) {\n    // create a virtual root node with the same deps as the node that\n    // is requesting this one, so that we can get all the peer deps in\n    // a context where they're likely to be resolvable.\n    // Note that the virtual root will also have virtual copies of the\n    // targets of any child Links, so that they resolve appropriately.\n    const parent = parent_ || this[_virtualRoot](edge.from)\n    const realParent = edge.peer ? edge.from.resolveParent : edge.from\n\n    const spec = npa.resolve(edge.name, edge.spec, edge.from.path)\n    const first = await this[_nodeFromSpec](edge.name, spec, parent, edge)\n\n    // we might have a case where the parent has a peer dependency on\n    // `foo@*` which resolves to v2, but another dep in the set has a\n    // peerDependency on `foo@1`.  In that case, if we force it to be v2,\n    // we're unnecessarily triggering an ERESOLVE.\n    // If we have a second edge to worry about, and it's not satisfied\n    // by the first node, try a second and see if that satisfies the\n    // original edge here.\n    const spec2 = secondEdge && npa.resolve(\n      edge.name,\n      secondEdge.spec,\n      secondEdge.from.path\n    )\n    const second = secondEdge && !secondEdge.valid\n      ? await this[_nodeFromSpec](edge.name, spec2, parent, secondEdge)\n      : null\n\n    // pick the second one if they're both happy with that, otherwise first\n    const node = second && edge.valid ? second : first\n    // ensure the one we want is the one that's placed\n    node.parent = parent\n\n    if (required.has(edge.from) && edge.type !== 'peerOptional' ||\n        secondEdge && (\n          required.has(secondEdge.from) && secondEdge.type !== 'peerOptional'))\n      required.add(node)\n\n    // handle otherwise unresolvable dependency nesting loops by\n    // creating a symbolic link\n    // a1 -> b1 -> a2 -> b2 -> a1 -> ...\n    // instead of nesting forever, when the loop occurs, create\n    // a symbolic link to the earlier instance\n    for (let p = edge.from.resolveParent; p; p = p.resolveParent) {\n      if (p.matches(node) && !p.isTop)\n        return new Link({ parent: realParent, target: p })\n    }\n\n    // keep track of the thing that caused this node to be included.\n    const src = parent.sourceReference\n    this[_peerSetSource].set(node, src)\n    return this[_loadPeerSet](node, required)\n  }\n\n  [_virtualRoot] (node, reuse = false) {\n    if (reuse && this[_virtualRoots].has(node))\n      return this[_virtualRoots].get(node)\n\n    const vr = new Node({\n      path: node.realpath,\n      sourceReference: node,\n      legacyPeerDeps: this.legacyPeerDeps,\n    })\n\n    // also need to set up any targets from any link deps, so that\n    // they are properly reflected in the virtual environment\n    for (const child of node.children.values()) {\n      if (child.isLink) {\n        new Node({\n          path: child.realpath,\n          sourceReference: child.target,\n          root: vr,\n        })\n      }\n    }\n\n    this[_virtualRoots].set(node, vr)\n    return vr\n  }\n\n  [_problemEdges] (node) {\n    // skip over any bundled deps, they're not our problem.\n    // Note that this WILL fetch bundled meta-deps which are also dependencies\n    // but not listed as bundled deps.  When reifying, we first unpack any\n    // nodes that have bundleDependencies, then do a loadActual on them, move\n    // the nodes into the ideal tree, and then prune.  So, fetching those\n    // possibly-bundled meta-deps at this point doesn't cause any worse\n    // problems than a few unnecessary packument fetches.\n\n    // also skip over any nodes in the tree that failed to load, since those\n    // will crash the install later on anyway.\n    const bd = node.isProjectRoot ? null : node.package.bundleDependencies\n    const bundled = new Set(bd || [])\n\n    return [...node.edgesOut.values()]\n      .filter(edge => {\n        // If it's included in a bundle, we take whatever is specified.\n        if (bundled.has(edge.name))\n          return false\n\n        // If it's already been logged as a load failure, skip it.\n        if (edge.to && this[_loadFailures].has(edge.to))\n          return false\n\n        // If it's shrinkwrapped, we use what the shrinkwap wants.\n        if (edge.to && edge.to.inShrinkwrap)\n          return false\n\n        // If the edge has no destination, that's a problem, unless\n        // if it's peerOptional and not explicitly requested.\n        if (!edge.to) {\n          return edge.type !== 'peerOptional' ||\n            this[_explicitRequests].has(edge)\n        }\n\n        // If the edge has an error, there's a problem.\n        if (!edge.valid)\n          return true\n\n        // If user has explicitly asked to update this package by name, it's a problem.\n        if (this[_updateNames].includes(edge.name))\n          return true\n\n        // If we're fixing a security vulnerability with this package, it's a problem.\n        if (this[_isVulnerable](edge.to))\n          return true\n\n        // If the user has explicitly asked to install this package, it's a problem.\n        if (node.isProjectRoot && this[_explicitRequests].has(edge))\n          return true\n\n        // No problems!\n        return false\n      })\n  }\n\n  async [_fetchManifest] (spec) {\n    const options = {\n      ...this.options,\n      avoid: this[_avoidRange](spec.name),\n    }\n    // get the intended spec and stored metadata from yarn.lock file,\n    // if available and valid.\n    spec = this.idealTree.meta.checkYarnLock(spec, options)\n\n    if (this[_manifests].has(spec.raw))\n      return this[_manifests].get(spec.raw)\n    else {\n      this.log.silly('fetch manifest', spec.raw)\n      const p = pacote.manifest(spec, options)\n        .then(mani => {\n          this[_manifests].set(spec.raw, mani)\n          return mani\n        })\n      this[_manifests].set(spec.raw, p)\n      return p\n    }\n  }\n\n  [_nodeFromSpec] (name, spec, parent, edge) {\n    // pacote will slap integrity on its options, so we have to clone\n    // the object so it doesn't get mutated.\n    // Don't bother to load the manifest for link deps, because the target\n    // might be within another package that doesn't exist yet.\n    const { legacyPeerDeps } = this\n    return spec.type === 'directory'\n      ? this[_linkFromSpec](name, spec, parent, edge)\n      : this[_fetchManifest](spec)\n        .then(pkg => new Node({ name, pkg, parent, legacyPeerDeps }), error => {\n          error.requiredBy = edge.from.location || '.'\n\n          // failed to load the spec, either because of enotarget or\n          // fetch failure of some other sort.  save it so we can verify\n          // later that it's optional, otherwise the error is fatal.\n          const n = new Node({\n            name,\n            parent,\n            error,\n            legacyPeerDeps,\n          })\n          this[_loadFailures].add(n)\n          return n\n        })\n  }\n\n  [_linkFromSpec] (name, spec, parent, edge) {\n    const realpath = spec.fetchSpec\n    const { legacyPeerDeps } = this\n    return rpj(realpath + '/package.json').catch(() => ({})).then(pkg => {\n      const link = new Link({ name, parent, realpath, pkg, legacyPeerDeps })\n      this[_linkNodes].add(link)\n      return link\n    })\n  }\n\n  // load all peer deps and meta-peer deps into the node's parent\n  // At the end of this, the node's peer-type outward edges are all\n  // resolved, and so are all of theirs, but other dep types are not.\n  // We prefer to get peer deps that meet the requiring node's dependency,\n  // if possible, since that almost certainly works (since that package was\n  // developed with this set of deps) and will typically be more restrictive.\n  // Note that the peers in the set can conflict either with each other,\n  // or with a direct dependency from the virtual root parent!  In strict\n  // mode, this is always an error.  In force mode, it never is, and we\n  // prefer the parent's non-peer dep over a peer dep, or the version that\n  // gets placed first.  In non-strict mode, we behave strictly if the\n  // virtual root is based on the root project, and allow non-peer parent\n  // deps to override, but throw if no preference can be determined.\n  async [_loadPeerSet] (node, required) {\n    const peerEdges = [...node.edgesOut.values()]\n      // we typically only install non-optional peers, but we have to\n      // factor them into the peerSet so that we can avoid conflicts\n      .filter(e => e.peer && !(e.valid && e.to))\n      .sort(({name: a}, {name: b}) => a.localeCompare(b))\n\n    for (const edge of peerEdges) {\n      // already placed this one, and we're happy with it.\n      if (edge.valid && edge.to)\n        continue\n\n      const parentEdge = node.parent.edgesOut.get(edge.name)\n      const {isProjectRoot, isWorkspace} = node.parent.sourceReference\n      const isMine = isProjectRoot || isWorkspace\n      const conflictOK = this[_force] || !isMine && !this[_strictPeerDeps]\n\n      if (!edge.to) {\n        if (!parentEdge) {\n          // easy, just put the thing there\n          await this[_nodeFromEdge](edge, node.parent, null, required)\n          continue\n        } else {\n          // if the parent's edge is very broad like >=1, and the edge in\n          // question is something like 1.x, then we want to get a 1.x, not\n          // a 2.x.  pass along the child edge as an advisory guideline.\n          // if the parent edge doesn't satisfy the child edge, and the\n          // child edge doesn't satisfy the parent edge, then we have\n          // a conflict.  this is always a problem in strict mode, never\n          // in force mode, and a problem in non-strict mode if this isn't\n          // on behalf of our project.  in all such cases, we warn at least.\n          const dep = await this[_nodeFromEdge](parentEdge, node.parent, edge, required)\n\n          // hooray! that worked!\n          if (edge.valid)\n            continue\n\n          // allow it.  either we're overriding, or it's not something\n          // that will be installed by default anyway, and we'll fail when\n          // we get to the point where we need to, if we need to.\n          if (conflictOK || !required.has(dep))\n            continue\n\n          // problem\n          this[_failPeerConflict](edge, parentEdge)\n        }\n      }\n\n      // at this point we know that there is a dep there, and\n      // we don't like it.  always fail strictly, always allow forcibly or\n      // in non-strict mode if it's not our fault.  don't warn here, because\n      // we are going to warn again when we place the deps, if we end up\n      // overriding for something else.  If the thing that has this dep\n      // isn't also required, then there's a good chance we won't need it,\n      // so allow it for now and let it conflict if it turns out to actually\n      // be necessary for the installation.\n      if (conflictOK || !required.has(edge.from))\n        continue\n\n      // ok, it's the root, or we're in unforced strict mode, so this is bad\n      this[_failPeerConflict](edge, parentEdge)\n    }\n    return node\n  }\n\n  [_failPeerConflict] (edge, currentEdge) {\n    const expl = this[_explainPeerConflict](edge, currentEdge)\n    throw Object.assign(new Error('unable to resolve dependency tree'), expl)\n  }\n\n  [_explainPeerConflict] (edge, currentEdge) {\n    const node = edge.from\n    const curNode = node.resolve(edge.name)\n    const pc = this[_peerConflict] || { peer: null, current: null }\n    const current = curNode ? curNode.explain() : pc.current\n    const peerConflict = pc.peer\n    return {\n      code: 'ERESOLVE',\n      current,\n      // it SHOULD be impossible to get here without a current node in place,\n      // but this at least gives us something report on when bugs creep into\n      // the tree handling logic.\n      currentEdge: currentEdge ? currentEdge.explain() : null,\n      edge: edge.explain(),\n      peerConflict,\n      strictPeerDeps: this[_strictPeerDeps],\n      force: this[_force],\n    }\n  }\n\n  [_warnPeerConflict] (edge) {\n    // track that we've overridden this edge, so that we don't keep trying\n    // to re-resolve it in an infinite loop.\n    this[_edgesOverridden].add(edge)\n    const expl = this[_explainPeerConflict](edge)\n    this.log.warn('ERESOLVE', 'overriding peer dependency', expl)\n  }\n\n  // starting from either node, or in the case of non-root peer deps,\n  // the node's parent, walk up the tree until we find the first spot\n  // where this dep cannot be placed, and use the one right before that.\n  // place dep, requested by node, to satisfy edge\n  // XXX split this out into a separate method or mixin?  It's quite a lot\n  // of functionality that ought to have its own unit tests more conveniently.\n  [_placeDep] (dep, node, edge, peerEntryEdge = null, peerPath = []) {\n    if (edge.to &&\n        !edge.error &&\n        !this[_explicitRequests].has(edge) &&\n        !this[_updateNames].includes(edge.name) &&\n        !this[_isVulnerable](edge.to))\n      return []\n\n    // top nodes should still get peer deps from their fsParent if possible,\n    // and only install locally if there's no other option, eg for a link\n    // outside of the project root, or for a conflicted dep.\n    const start = edge.peer && !node.isProjectRoot ? node.resolveParent || node\n      : node\n\n    let target\n    let canPlace = null\n    let isSource = false\n    const source = this[_peerSetSource].get(dep)\n    for (let check = start; check; check = check.resolveParent) {\n      // we always give the FIRST place we possibly *can* put this a little\n      // extra prioritization with peer dep overrides and deduping\n      if (check === source)\n        isSource = true\n\n      // if the current location has a peerDep on it, then we can't place here\n      // this is pretty rare to hit, since we always prefer deduping peers.\n      const checkEdge = check.edgesOut.get(edge.name)\n      if (!check.isTop && checkEdge && checkEdge.peer)\n        continue\n\n      const cp = this[_canPlaceDep](dep, check, edge, peerEntryEdge, peerPath, isSource)\n      isSource = false\n\n      // anything other than a conflict is fine to proceed with\n      if (cp !== CONFLICT) {\n        canPlace = cp\n        target = check\n      } else\n        break\n\n      // nest packages like npm v1 and v2\n      // very disk-inefficient\n      if (this[_legacyBundling])\n        break\n\n      // when installing globally, or just in global style, we never place\n      // deps above the first level.\n      const tree = this.idealTree && this.idealTree.target || this.idealTree\n      if (this[_globalStyle] && check.resolveParent === tree)\n        break\n    }\n\n    // if we can't find a target, that means that the last placed checked\n    // (and all the places before it) had a copy already.  if we're in\n    // --force mode, then the user has explicitly said that they're ok\n    // with conflicts.  This can only occur in --force mode in the case\n    // when a node was added to the tree with a peerOptional dep that we\n    // ignored, and then later, that edge became invalid, and we fail to\n    // resolve it.  We will warn about it in a moment.\n    if (!target) {\n      if (this[_force]) {\n        // we know that there is a dep (not the root) which is the target\n        // of this edge, or else it wouldn't have been a conflict.\n        target = edge.to.resolveParent\n        canPlace = KEEP\n      } else\n        this[_failPeerConflict](edge)\n    } else {\n      // it worked, so we clearly have no peer conflicts at this point.\n      this[_peerConflict] = null\n    }\n\n    this.log.silly(\n      'placeDep',\n      target.location || 'ROOT',\n      `${dep.name}@${dep.version}`,\n      canPlace.description || /* istanbul ignore next */ canPlace,\n      `for: ${node.package._id || node.location}`,\n      `want: ${edge.spec || '*'}`\n    )\n\n    // Can only get KEEP here if the original edge was valid,\n    // and we're checking for an update but it's already up to date.\n    if (canPlace === KEEP) {\n      if (edge.peer && !target.children.get(edge.name).satisfies(edge)) {\n        // this is an overridden peer dep\n        this[_warnPeerConflict](edge)\n      }\n      return []\n    }\n\n    // figure out which of this node's peer deps will get placed as well\n    const virtualRoot = dep.parent\n\n    const newDep = new dep.constructor({\n      name: dep.name,\n      pkg: dep.package,\n      resolved: dep.resolved,\n      integrity: dep.integrity,\n      legacyPeerDeps: this.legacyPeerDeps,\n      error: dep.errors[0],\n      ...(dep.target ? { target: dep.target, realpath: dep.target.path } : {}),\n    })\n    if (this[_loadFailures].has(dep))\n      this[_loadFailures].add(newDep)\n\n    const placed = [newDep]\n    const oldChild = target.children.get(edge.name)\n    if (oldChild) {\n      // if we're replacing, we should also remove any nodes for edges that\n      // are now invalid, and where this (or its deps) is the only dependent,\n      // and also recurse on that pruning.  Otherwise leaving that dep node\n      // around can result in spurious conflicts pushing nodes deeper into\n      // the tree than needed in the case of cycles that will be removed\n      // later anyway.\n      const oldDeps = []\n      for (const [name, edge] of oldChild.edgesOut.entries()) {\n        if (!newDep.edgesOut.has(name) && edge.to)\n          oldDeps.push(...gatherDepSet([edge.to], e => e.to !== edge.to))\n      }\n      newDep.replace(oldChild)\n      this[_pruneForReplacement](newDep, oldDeps)\n      // this may also create some invalid edges, for example if we're\n      // intentionally causing something to get nested which was previously\n      // placed in this location.\n      for (const edgeIn of newDep.edgesIn) {\n        if (edgeIn.invalid && edgeIn !== edge) {\n          this[_depsQueue].push(edgeIn.from)\n          this[_depsSeen].delete(edgeIn.from)\n        }\n      }\n    } else\n      newDep.parent = target\n\n    if (edge.peer && !newDep.satisfies(edge)) {\n      // this is an overridden peer dep\n      this[_warnPeerConflict](edge)\n    }\n\n    // If the edge is not an error, then we're updating something, and\n    // MAY end up putting a better/identical node further up the tree in\n    // a way that causes an unnecessary duplication.  If so, remove the\n    // now-unnecessary node.\n    if (edge.valid && edge.to.parent !== target && newDep.canReplace(edge.to))\n      edge.to.parent = null\n\n    // visit any dependents who are upset by this change\n    // if it's an angry overridden peer edge, however, make sure we\n    // skip over it!\n    for (const edgeIn of newDep.edgesIn) {\n      if (edgeIn !== edge && !edgeIn.valid && !this[_depsSeen].has(edge.from)) {\n        this.addTracker('idealTree', edgeIn.from.name, edgeIn.from.location)\n        this[_depsQueue].push(edgeIn.from)\n      }\n    }\n\n    // in case we just made some duplicates that can be removed,\n    // prune anything deeper in the tree that can be replaced by this\n    if (this.idealTree) {\n      for (const node of this.idealTree.inventory.query('name', newDep.name)) {\n        if (node !== newDep &&\n            node.isDescendantOf(target) &&\n            !node.inShrinkwrap &&\n            !node.inBundle &&\n            node.canReplaceWith(newDep)) {\n          // don't prune if the dupe is necessary!\n          // root (a, d)\n          // +-- a (b, c2)\n          // |   +-- b (c2) <-- place c2 for b, lands at root\n          // +-- d (e)\n          //     +-- e (c1, d)\n          //         +-- c1\n          //         +-- f (c2)\n          //             +-- c2 <-- pruning this would be bad\n\n          const mask = node.parent !== target &&\n            node.parent &&\n            node.parent.parent &&\n            node.parent.parent !== target &&\n            node.parent.parent.resolve(newDep.name)\n\n          if (!mask || mask === newDep || node.canReplaceWith(mask))\n            node.parent = null\n        }\n      }\n    }\n\n    // also place its unmet or invalid peer deps at this location\n    // note that newDep has now been removed from the virtualRoot set\n    // by virtue of being placed in the target's node_modules.\n    // loop through any peer deps from the thing we just placed, and place\n    // those ones as well.  it's safe to do this with the virtual nodes,\n    // because we're copying rather than moving them out of the virtual root,\n    // otherwise they'd be gone and the peer set would change throughout\n    // this loop.\n    for (const peerEdge of newDep.edgesOut.values()) {\n      const peer = virtualRoot.children.get(peerEdge.name)\n\n      // Note: if the virtualRoot *doesn't* have the peer, then that means\n      // it's an optional peer dep.  If it's not being properly met (ie,\n      // peerEdge.valid is false), that this is likely heading for an\n      // ERESOLVE error, unless it can walk further up the tree.\n      if (!peerEdge.peer || peerEdge.valid || !peer)\n        continue\n\n      const peerPlaced = this[_placeDep](\n        peer, newDep, peerEdge, peerEntryEdge || edge, peerPath)\n      placed.push(...peerPlaced)\n    }\n\n    // we're done with this now, clean it up.\n    this[_virtualRoots].delete(virtualRoot.sourceReference)\n\n    return placed\n  }\n\n  [_pruneForReplacement] (node, oldDeps) {\n    // gather up all the invalid edgesOut, and any now-extraneous\n    // deps that the new node doesn't depend on but the old one did.\n    const invalidDeps = new Set([...node.edgesOut.values()]\n      .filter(e => e.to && !e.valid).map(e => e.to))\n    for (const dep of oldDeps) {\n      const set = gatherDepSet([dep], e => e.to !== dep && e.valid)\n      for (const dep of set)\n        invalidDeps.add(dep)\n    }\n\n    // ignore dependency edges from the node being replaced, but\n    // otherwise filter the set down to just the set with no\n    // dependencies from outside the set, except the node in question.\n    const deps = gatherDepSet(invalidDeps, edge =>\n      edge.from !== node && edge.to !== node && edge.valid)\n\n    // now just delete whatever's left, because it's junk\n    for (const dep of deps)\n      dep.parent = null\n  }\n\n  // check if we can place DEP in TARGET to satisfy EDGE\n  // Need to verify:\n  // - no child by that name there already\n  // - target does not have a peer dep on name\n  // - no higher-level pkg by that name and incompatible spec is depended on\n  //   by anything lower in the tree.\n  // - node's peer deps and meta-peer deps are siblings in a virtual root at\n  //   this point.  make sure that the whole family can come along, so apply\n  //   the same checks to each of them.  They may land higher up in the tree,\n  //   but we need to know that they CAN live here.\n  // Responses:\n  // - OK - Yes, because there is nothing there and no conflicts caused\n  // - REPLACE - Yes, and you can clobber what's there\n  // - KEEP - No, but what's there is fine\n  // - CONFLICT - You may not put that there\n  //\n  // Check peers on OK or REPLACE.  KEEP and CONFLICT do not require peer\n  // checking, because either we're leaving it alone, or it won't work anyway.\n  // When we check peers, we pass along the peerEntryEdge to track the\n  // original edge that caused us to load the family of peer dependencies.\n  [_canPlaceDep] (dep, target, edge, peerEntryEdge = null, peerPath = [], isSource = false) {\n    /* istanbul ignore next */\n    debug(() => {\n      if (!dep)\n        throw new Error('no dep??')\n    })\n    const entryEdge = peerEntryEdge || edge\n    const source = this[_peerSetSource].get(dep)\n\n    isSource = isSource || target === source\n    // if we're overriding the source, then we care if the *target* is\n    // ours, even if it wasn't actually the original source, since we\n    // are depending on something that has a dep that can't go in its own\n    // folder.  for example, a -> b, b -> PEER(a).  Even though a is the\n    // source, b has to be installed up a level, and if the root package\n    // depends on a, and it has a conflict, it's our problem.  So, the root\n    // (or whatever is bringing in a) becomes the \"effective source\" for\n    // the purposes of this calculation.\n    const { isProjectRoot, isWorkspace } = isSource ? target : source || {}\n    const isMine = isProjectRoot || isWorkspace\n\n    // Useful testing thingie right here.\n    // peerEntryEdge should *always* be a non-peer dependency, or a peer\n    // dependency from the root node.  When we get spurious ERESOLVE errors,\n    // or *don't* get ERESOLVE errors when we should, check to see if this\n    // fails, because it MAY mean we got off track somehow.\n    /* istanbul ignore next - debug check, should be impossible */\n    debug(() => {\n      if (peerEntryEdge && peerEntryEdge.peer && !peerEntryEdge.from.isTop)\n        throw new Error('lost original peerEntryEdge somehow?')\n    })\n\n    if (target.children.has(edge.name)) {\n      const current = target.children.get(edge.name)\n\n      // same thing = keep, UNLESS the current doesn't satisfy and new\n      // one does satisfy.  This can happen if it's a link to a matching target\n      // at a different location, which satisfies a version dep, but not a\n      // file: dep.  If neither of them satisfy, then we can replace it,\n      // because presumably it's better for a peer or something.\n      if (dep.matches(current)) {\n        if (current.satisfies(edge) || !dep.satisfies(edge))\n          return KEEP\n      }\n\n      const { version: curVer } = current\n      const { version: newVer } = dep\n      const tryReplace = curVer && newVer && semver.gte(newVer, curVer)\n      if (tryReplace && dep.canReplace(current)) {\n        const res = this[_canPlacePeers](dep, target, edge, REPLACE, peerEntryEdge, peerPath, isSource)\n        /* istanbul ignore else - It's extremely rare that a replaceable\n         * node would be a conflict, if the current one wasn't a conflict,\n         * but it is theoretically possible if peer deps are pinned.  In\n         * that case we treat it like any other conflict, and keep trying */\n        if (res !== CONFLICT)\n          return res\n      }\n\n      // ok, can't replace the current with new one, but maybe current is ok?\n      // no need to check if it's a peer that's valid to be here, because\n      // peers are always placed along with their entry source\n      if (edge.satisfiedBy(current))\n        return KEEP\n\n      // if we prefer deduping, then try replacing newer with older\n      // we always prefer to dedupe peers, because they are trying\n      // a bit harder to be singletons.\n      const preferDedupe = this[_preferDedupe] || edge.peer\n      if (preferDedupe && !tryReplace && dep.canReplace(current)) {\n        const res = this[_canPlacePeers](dep, target, edge, REPLACE, peerEntryEdge, peerPath, isSource)\n        /* istanbul ignore else - It's extremely rare that a replaceable\n         * node would be a conflict, if the current one wasn't a conflict,\n         * but it is theoretically possible if peer deps are pinned.  In\n         * that case we treat it like any other conflict, and keep trying */\n        if (res !== CONFLICT)\n          return res\n      }\n\n      // check for conflict override cases.\n      // first: is this the only place this thing can go?  If the target is\n      // the source, then one of these things are true.\n      //\n      // 1. the conflicted dep was deduped up to here from a lower dependency\n      // w -> (x,y)\n      // x -> (z)\n      // y -> PEER(p@1)\n      // z -> (q)\n      // q -> (p@2)\n      //\n      // When building, let's say that x is fully placed, with all of its\n      // deps, and we're _adding_ y.  Since the peer on p@1 was not initially\n      // present, it's been deduped up to w, and now needs to be pushed out.\n      // Replace it, and potentially also replace its peer set (though that'll\n      // be accomplished by making the same determination when we call\n      // _canPlacePeers)\n      //\n      // 2. the dep we're TRYING to place here ought to be overridden by the\n      // one that's here now, because current is (a) a direct dep of the\n      // source, or (b) an already-placed peer in a conflicted peer set, or\n      // (c) an already-placed peer in a different peer set at the same level.\n      // If strict or ours, conflict.  Otherwise, keep.\n      if (isSource) {\n        // check to see if the current module could go deeper in the tree\n        let canReplace = true\n        // only do this check when we're placing peers.  when we're placing\n        // the original in the source, we know that the edge from the source\n        // is the thing we're trying to place, so its peer set will need to be\n        // placed here as well.  the virtualRoot already has the appropriate\n        // overrides applied.\n        if (peerEntryEdge) {\n          const peerSet = getPeerSet(current)\n          OUTER: for (const p of peerSet) {\n            // if any have a non-peer dep from the target, or a peer dep if\n            // the target is root, then cannot safely replace and dupe deeper.\n            for (const edge of p.edgesIn) {\n              if (peerSet.has(edge.from))\n                continue\n\n              // only respect valid edges, however, since we're likely trying\n              // to fix the very one that's currently broken!  If the virtual\n              // root's replacement is ok, and doesn't have any invalid edges\n              // indicating that it was an overridden peer, then ignore the\n              // conflict and continue.  If it WAS an override, then we need\n              // to get the conflict here so that we can decide whether to\n              // accept the current dep node, clobber it, or fail the install.\n              if (edge.from === target && edge.valid) {\n                const rep = dep.parent.children.get(edge.name)\n                const override = rep && ([...rep.edgesIn].some(e => !e.valid))\n                if (!rep || !rep.satisfies(edge) || override) {\n                  canReplace = false\n                  break OUTER\n                }\n              }\n            }\n          }\n        }\n        if (canReplace) {\n          const ret = this[_canPlacePeers](dep, target, edge, REPLACE, peerEntryEdge, peerPath, isSource)\n          /* istanbul ignore else - extremely rare that the peer set would\n           * conflict if we can replace the node in question, but theoretically\n           * possible, if peer deps are pinned aggressively. */\n          if (ret !== CONFLICT)\n            return ret\n        }\n\n        // so it's not a deeper dep that's been deduped.  That means that the\n        // only way it could have ended up here is if it's a conflicted peer.\n        /* istanbul ignore else - would have already crashed if not forced,\n         * and either mine or strict, when creating the peerSet.  Keeping this\n         * check so that we're not only relying on action at a distance. */\n        if (!this[_strictPeerDeps] && !isMine || this[_force]) {\n          this[_warnPeerConflict](edge, dep)\n          return KEEP\n        }\n      }\n\n      // no justification for overriding, and no agreement possible.\n      return CONFLICT\n    }\n\n    // no existing node at this location!\n    // check to see if the target doesn't have a child by that name,\n    // but WANTS one, and won't be happy with this one.  if this is the\n    // edge we're looking to resolve, then not relevant, of course.\n    if (target !== entryEdge.from && target.edgesOut.has(dep.name)) {\n      const targetEdge = target.edgesOut.get(dep.name)\n      // It might be that the dep would not be valid here, BUT some other\n      // version would.  Could to try to resolve that, but that makes this no\n      // longer a pure synchronous function.  ugh.\n      // This is a pretty unlikely scenario in a normal install, because we\n      // resolve the peer dep set against the parent dependencies, and\n      // presumably they all worked together SOMEWHERE to get published in the\n      // first place, and since we resolve shallower deps before deeper ones,\n      // this can only occur by a child having a peer dep that does not satisfy\n      // the parent.  It can happen if we're doing a deep update limited by\n      // a specific name, however, or if a dep makes an incompatible change\n      // to its peer dep in a non-semver-major version bump, or if the parent\n      // is unbounded in its dependency list.\n      if (!targetEdge.satisfiedBy(dep))\n        return CONFLICT\n    }\n\n    // check to see what that name resolves to here, and who may depend on\n    // being able to reach it by crawling up past this parent.  we know\n    // at this point that it's not the target's direct child node.  if it's\n    // a direct dep of the target, we just make the invalid edge and\n    // resolve it later.\n    const current = target !== entryEdge.from && target.resolve(dep.name)\n    if (current) {\n      for (const edge of current.edgesIn.values()) {\n        if (edge.from.isDescendantOf(target) && edge.valid) {\n          if (!edge.satisfiedBy(dep))\n            return CONFLICT\n        }\n      }\n    }\n\n    // no objections!  ok to place here\n    return this[_canPlacePeers](dep, target, edge, OK, peerEntryEdge, peerPath, isSource)\n  }\n\n  // make sure the family of peer deps can live here alongside it.\n  // this doesn't guarantee that THIS solution will be the one we take,\n  // but it does establish that SOME solution exists at this level in\n  // the tree.\n  [_canPlacePeers] (dep, target, edge, ret, peerEntryEdge, peerPath, isSource) {\n    // do not go in cycles when we're resolving a peer group\n    if (!dep.parent || peerEntryEdge && peerPath.includes(dep))\n      return ret\n\n    const entryEdge = peerEntryEdge || edge\n    peerPath = [...peerPath, dep]\n\n    for (const peerEdge of dep.edgesOut.values()) {\n      if (!peerEdge.peer || !peerEdge.to)\n        continue\n      const peer = peerEdge.to\n      const canPlacePeer = this[_canPlaceDep](peer, target, peerEdge, entryEdge, peerPath, isSource)\n      if (canPlacePeer !== CONFLICT)\n        continue\n\n      const current = target.resolve(peer.name)\n      this[_peerConflict] = {\n        peer: peer.explain(peerEdge),\n        current: current && current.explain(),\n      }\n      return CONFLICT\n    }\n    return ret\n  }\n\n  // go through all the links in the this[_linkNodes] set\n  // for each one:\n  // - if outside the root, ignore it, assume it's fine, it's not our problem\n  // - if a node in the tree already, assign the target to that node.\n  // - if a path under an existing node, then assign that as the fsParent,\n  //   and add it to the _depsQueue\n  //\n  // call buildDepStep if anything was added to the queue, otherwise we're done\n  [_resolveLinks] () {\n    for (const link of this[_linkNodes]) {\n      this[_linkNodes].delete(link)\n\n      // link we never ended up placing, skip it\n      if (link.root !== this.idealTree)\n        continue\n\n      const external = /^\\.\\.(\\/|$)/.test(relpath(this.path, link.realpath))\n\n      // outside the root, somebody else's problem, ignore it\n      if (external && !this[_follow])\n        continue\n\n      // didn't find a parent for it or it has not been seen yet\n      // so go ahead and process it.\n      const unseenLink = (link.target.parent || link.target.fsParent) &&\n        !this[_depsSeen].has(link.target)\n\n      if (this[_follow] &&\n          !link.target.parent &&\n          !link.target.fsParent ||\n          unseenLink) {\n        this.addTracker('idealTree', link.target.name, link.target.location)\n        this[_depsQueue].push(link.target)\n      }\n    }\n\n    if (this[_depsQueue].length)\n      return this[_buildDepStep]()\n  }\n\n  [_fixDepFlags] () {\n    process.emit('time', 'idealTree:fixDepFlags')\n    const metaFromDisk = this.idealTree.meta.loadedFromDisk\n    const flagsSuspect = this[_flagsSuspect]\n    const mutateTree = this[_mutateTree]\n    // if the options set prune:false, then we don't prune, but we still\n    // mark the extraneous items in the tree if we modified it at all.\n    // If we did no modifications, we just iterate over the extraneous nodes.\n    // if we started with an empty tree, then the dep flags are already\n    // all set to true, and there can be nothing extraneous, so there's\n    // nothing to prune, because we built it from scratch.  if we didn't\n    // add or remove anything, then also nothing to do.\n    if (metaFromDisk && mutateTree)\n      resetDepFlags(this.idealTree)\n\n    // update all the dev/optional/etc flags in the tree\n    // either we started with a fresh tree, or we\n    // reset all the flags to find the extraneous nodes.\n    //\n    // if we started from a blank slate, or changed something, then\n    // the dep flags will be all set to true.\n    if (!metaFromDisk || mutateTree)\n      calcDepFlags(this.idealTree)\n    else {\n      // otherwise just unset all the flags on the root node\n      // since they will sometimes have the default value\n      this.idealTree.extraneous = false\n      this.idealTree.dev = false\n      this.idealTree.optional = false\n      this.idealTree.devOptional = false\n      this.idealTree.peer = false\n    }\n\n    // at this point, any node marked as extraneous should be pruned.\n    // if we started from a shrinkwrap, and then added/removed something,\n    // then the tree is suspect.  Prune what is marked as extraneous.\n    // otherwise, don't bother.\n    const needPrune = metaFromDisk && (mutateTree || flagsSuspect)\n    if (this[_prune] && needPrune)\n      this[_idealTreePrune]()\n    process.emit('timeEnd', 'idealTree:fixDepFlags')\n  }\n\n  [_idealTreePrune] () {\n    for (const node of this.idealTree.inventory.filter(n => n.extraneous))\n      node.parent = null\n  }\n\n  [_pruneFailedOptional] () {\n    for (const node of this[_loadFailures]) {\n      if (!node.optional)\n        throw node.errors[0]\n\n      const set = optionalSet(node)\n      for (const node of set)\n        node.parent = null\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}
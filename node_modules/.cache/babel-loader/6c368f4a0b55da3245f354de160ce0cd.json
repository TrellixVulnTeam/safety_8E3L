{"ast":null,"code":"// an object representing the set of vulnerabilities in a tree\n\n/* eslint camelcase: \"off\" */\nconst npa = require('npm-package-arg');\n\nconst pickManifest = require('npm-pick-manifest');\n\nconst Vuln = require('./vuln.js');\n\nconst Calculator = require('@npmcli/metavuln-calculator');\n\nconst _getReport = Symbol('getReport');\n\nconst _fixAvailable = Symbol('fixAvailable');\n\nconst _checkTopNode = Symbol('checkTopNode');\n\nconst _init = Symbol('init');\n\nconst _omit = Symbol('omit');\n\nconst procLog = require('./proc-log.js');\n\nconst fetch = require('npm-registry-fetch');\n\nclass AuditReport extends Map {\n  static load(tree, opts) {\n    return new AuditReport(tree, opts).run();\n  }\n\n  get auditReportVersion() {\n    return 2;\n  }\n\n  toJSON() {\n    const obj = {\n      auditReportVersion: this.auditReportVersion,\n      vulnerabilities: {},\n      metadata: {\n        vulnerabilities: {\n          info: 0,\n          low: 0,\n          moderate: 0,\n          high: 0,\n          critical: 0,\n          total: this.size\n        },\n        dependencies: {\n          prod: 0,\n          dev: 0,\n          optional: 0,\n          peer: 0,\n          peerOptional: 0,\n          total: this.tree.inventory.size - 1\n        }\n      }\n    };\n\n    for (const node of this.tree.inventory.values()) {\n      const {\n        dependencies\n      } = obj.metadata;\n      let prod = true;\n\n      for (const type of ['dev', 'optional', 'peer', 'peerOptional']) {\n        if (node[type]) {\n          dependencies[type]++;\n          prod = false;\n        }\n      }\n\n      if (prod) dependencies.prod++;\n    } // if it doesn't have any topVulns, then it's fixable with audit fix\n    // for each topVuln, figure out if it's fixable with audit fix --force,\n    // or if we have to just delete the thing, and if the fix --force will\n    // require a semver major update.\n\n\n    const vulnerabilities = [];\n\n    for (const [name, vuln] of this.entries()) {\n      vulnerabilities.push([name, vuln.toJSON()]);\n      obj.metadata.vulnerabilities[vuln.severity]++;\n    }\n\n    obj.vulnerabilities = vulnerabilities.sort(([a], [b]) => a.localeCompare(b)).reduce((set, [name, vuln]) => {\n      set[name] = vuln;\n      return set;\n    }, {});\n    return obj;\n  }\n\n  constructor(tree, opts = {}) {\n    super();\n    this[_omit] = new Set(opts.omit || []);\n    this.topVulns = new Map();\n    this.calculator = new Calculator(opts);\n    this.error = null;\n    this.options = opts;\n    this.log = opts.log || procLog;\n    this.tree = tree;\n  }\n\n  async run() {\n    this.report = await this[_getReport]();\n    if (this.report) await this[_init]();\n    return this;\n  }\n\n  isVulnerable(node) {\n    const vuln = this.get(node.package.name);\n    return !!(vuln && vuln.isVulnerable(node));\n  }\n\n  async [_init]() {\n    process.emit('time', 'auditReport:init');\n    const promises = [];\n\n    for (const [name, advisories] of Object.entries(this.report)) {\n      for (const advisory of advisories) promises.push(this.calculator.calculate(name, advisory));\n    } // now the advisories are calculated with a set of versions\n    // and the packument.  turn them into our style of vuln objects\n    // which also have the affected nodes, and also create entries\n    // for all the metavulns that we find from dependents.\n\n\n    const advisories = new Set(await Promise.all(promises));\n    const seen = new Set();\n\n    for (const advisory of advisories) {\n      const {\n        name,\n        range\n      } = advisory; // don't flag the exact same name/range more than once\n      // adding multiple advisories with the same range is fine, but no\n      // need to search for nodes we already would have added.\n\n      const k = `${name}@${range}`;\n      if (seen.has(k)) continue;\n      seen.add(k);\n      const vuln = this.get(name) || new Vuln({\n        name,\n        advisory\n      });\n      if (this.has(name)) vuln.addAdvisory(advisory);\n      super.set(name, vuln);\n      const p = [];\n\n      for (const node of this.tree.inventory.query('name', name)) {\n        if (shouldOmit(node, this[_omit])) continue; // if not vulnerable by this advisory, keep searching\n\n        if (!advisory.testVersion(node.version)) continue; // we will have loaded the source already if this is a metavuln\n\n        if (advisory.type === 'metavuln') vuln.addVia(this.get(advisory.dependency)); // already marked this one, no need to do it again\n\n        if (vuln.nodes.has(node)) continue; // haven't marked this one yet.  get its dependents.\n\n        vuln.nodes.add(node);\n\n        for (const {\n          from: dep,\n          spec\n        } of node.edgesIn) {\n          if (dep.isTop && !vuln.topNodes.has(dep)) this[_checkTopNode](dep, vuln, spec);else {\n            // calculate a metavuln, if necessary\n            p.push(this.calculator.calculate(dep.name, advisory).then(meta => {\n              if (meta.testVersion(dep.version, spec)) advisories.add(meta);\n            }));\n          }\n        }\n      }\n\n      await Promise.all(p); // make sure we actually got something.  if not, remove it\n      // this can happen if you are loading from a lockfile created by\n      // npm v5, since it lists the current version of all deps,\n      // rather than the range that is actually depended upon,\n      // or if using --omit with the older audit endpoint.\n\n      if (this.get(name).nodes.size === 0) {\n        this.delete(name);\n        continue;\n      } // if the vuln is valid, but THIS advisory doesn't apply to any of\n      // the nodes it references, then remove it from the advisory list.\n      // happens when using omit with old audit endpoint.\n\n\n      for (const advisory of vuln.advisories) {\n        const relevant = [...vuln.nodes].some(n => advisory.testVersion(n.version));\n        if (!relevant) vuln.deleteAdvisory(advisory);\n      }\n    }\n\n    process.emit('timeEnd', 'auditReport:init');\n  }\n\n  [_checkTopNode](topNode, vuln, spec) {\n    vuln.fixAvailable = this[_fixAvailable](topNode, vuln, spec);\n\n    if (vuln.fixAvailable !== true) {\n      // now we know the top node is vulnerable, and cannot be\n      // upgraded out of the bad place without --force.  But, there's\n      // no need to add it to the actual vulns list, because nothing\n      // depends on root.\n      this.topVulns.set(vuln.name, vuln);\n      vuln.topNodes.add(topNode);\n    }\n  } // check whether the top node is vulnerable.\n  // check whether we can get out of the bad place with --force, and if\n  // so, whether that update is SemVer Major\n\n\n  [_fixAvailable](topNode, vuln, spec) {\n    // this will always be set to at least {name, versions:{}}\n    const paku = vuln.packument;\n    if (!vuln.testSpec(spec)) return true; // similarly, even if we HAVE a packument, but we're looking for it\n    // somewhere other than the registry, and we got something vulnerable,\n    // then we're stuck with it.\n\n    const specObj = npa(spec);\n    if (!specObj.registry) return false; // We don't provide fixes for top nodes other than root, but we\n    // still check to see if the node is fixable with a different version,\n    // and if that is a semver major bump.\n\n    try {\n      const {\n        _isSemVerMajor: isSemVerMajor,\n        version,\n        name\n      } = pickManifest(paku, spec, { ...this.options,\n        before: null,\n        avoid: vuln.range,\n        avoidStrict: true\n      });\n      return {\n        name,\n        version,\n        isSemVerMajor\n      };\n    } catch (er) {\n      return false;\n    }\n  }\n\n  set() {\n    throw new Error('do not call AuditReport.set() directly');\n  } // convert a quick-audit into a bulk advisory listing\n\n\n  static auditToBulk(report) {\n    if (!report.advisories) {\n      // tack on the report json where the response body would go\n      throw Object.assign(new Error('Invalid advisory report'), {\n        body: JSON.stringify(report)\n      });\n    }\n\n    const bulk = {};\n    const {\n      advisories\n    } = report;\n\n    for (const advisory of Object.values(advisories)) {\n      const {\n        id,\n        url,\n        title,\n        severity = 'high',\n        vulnerable_versions = '*',\n        module_name: name\n      } = advisory;\n      bulk[name] = bulk[name] || [];\n      bulk[name].push({\n        id,\n        url,\n        title,\n        severity,\n        vulnerable_versions\n      });\n    }\n\n    return bulk;\n  }\n\n  async [_getReport]() {\n    // if we're not auditing, just return false\n    if (this.options.audit === false || this.tree.inventory.size === 1) return null;\n    process.emit('time', 'auditReport:getReport');\n\n    try {\n      try {\n        // first try the super fast bulk advisory listing\n        const body = prepareBulkData(this.tree, this[_omit]); // no sense asking if we don't have anything to audit,\n        // we know it'll be empty\n\n        if (!Object.keys(body).length) return null;\n        const res = await fetch('/-/npm/v1/security/advisories/bulk', { ...this.options,\n          registry: this.options.auditRegistry || this.options.registry,\n          method: 'POST',\n          gzip: true,\n          body\n        });\n        return await res.json();\n      } catch (_) {\n        // that failed, try the quick audit endpoint\n        const body = prepareData(this.tree, this.options);\n        const res = await fetch('/-/npm/v1/security/audits/quick', { ...this.options,\n          registry: this.options.auditRegistry || this.options.registry,\n          method: 'POST',\n          gzip: true,\n          body\n        });\n        return AuditReport.auditToBulk(await res.json());\n      }\n    } catch (er) {\n      this.log.verbose('audit error', er);\n      this.log.silly('audit error', String(er.body));\n      this.error = er;\n      return null;\n    } finally {\n      process.emit('timeEnd', 'auditReport:getReport');\n    }\n  }\n\n} // return true if we should ignore this one\n\n\nconst shouldOmit = (node, omit) => !node.version ? true : omit.size === 0 ? false : node.dev && omit.has('dev') || node.optional && omit.has('optional') || node.devOptional && omit.has('dev') && omit.has('optional') || node.peer && omit.has('peer');\n\nconst prepareBulkData = (tree, omit) => {\n  const payload = {};\n\n  for (const name of tree.inventory.query('name')) {\n    const set = new Set();\n\n    for (const node of tree.inventory.query('name', name)) {\n      if (shouldOmit(node, omit)) continue;\n      set.add(node.version);\n    }\n\n    if (set.size) payload[name] = [...set];\n  }\n\n  return payload;\n};\n\nconst prepareData = (tree, opts) => {\n  const {\n    npmVersion: npm_version\n  } = opts;\n  const node_version = process.version;\n  const {\n    platform,\n    arch\n  } = process;\n  const {\n    NODE_ENV: node_env\n  } = process.env;\n  const data = tree.meta.commit(); // the legacy audit endpoint doesn't support any kind of pre-filtering\n  // we just have to get the advisories and skip over them in the report\n\n  return {\n    name: data.name,\n    version: data.version,\n    requires: { ...(tree.package.devDependencies || {}),\n      ...(tree.package.peerDependencies || {}),\n      ...(tree.package.optionalDependencies || {}),\n      ...(tree.package.dependencies || {})\n    },\n    dependencies: data.dependencies,\n    metadata: {\n      node_version,\n      npm_version,\n      platform,\n      arch,\n      node_env\n    }\n  };\n};\n\nmodule.exports = AuditReport;","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/node_modules/@npmcli/arborist/lib/audit-report.js"],"names":["npa","require","pickManifest","Vuln","Calculator","_getReport","Symbol","_fixAvailable","_checkTopNode","_init","_omit","procLog","fetch","AuditReport","Map","load","tree","opts","run","auditReportVersion","toJSON","obj","vulnerabilities","metadata","info","low","moderate","high","critical","total","size","dependencies","prod","dev","optional","peer","peerOptional","inventory","node","values","type","name","vuln","entries","push","severity","sort","a","b","localeCompare","reduce","set","constructor","Set","omit","topVulns","calculator","error","options","log","report","isVulnerable","get","package","process","emit","promises","advisories","Object","advisory","calculate","Promise","all","seen","range","k","has","add","addAdvisory","p","query","shouldOmit","testVersion","version","addVia","dependency","nodes","from","dep","spec","edgesIn","isTop","topNodes","then","meta","delete","relevant","some","n","deleteAdvisory","topNode","fixAvailable","paku","packument","testSpec","specObj","registry","_isSemVerMajor","isSemVerMajor","before","avoid","avoidStrict","er","Error","auditToBulk","assign","body","JSON","stringify","bulk","id","url","title","vulnerable_versions","module_name","audit","prepareBulkData","keys","length","res","auditRegistry","method","gzip","json","_","prepareData","verbose","silly","String","devOptional","payload","npmVersion","npm_version","node_version","platform","arch","NODE_ENV","node_env","env","data","commit","requires","devDependencies","peerDependencies","optionalDependencies","module","exports"],"mappings":"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","sourcesContent":["// an object representing the set of vulnerabilities in a tree\n/* eslint camelcase: \"off\" */\n\nconst npa = require('npm-package-arg')\nconst pickManifest = require('npm-pick-manifest')\n\nconst Vuln = require('./vuln.js')\nconst Calculator = require('@npmcli/metavuln-calculator')\n\nconst _getReport = Symbol('getReport')\nconst _fixAvailable = Symbol('fixAvailable')\nconst _checkTopNode = Symbol('checkTopNode')\nconst _init = Symbol('init')\nconst _omit = Symbol('omit')\nconst procLog = require('./proc-log.js')\n\nconst fetch = require('npm-registry-fetch')\n\nclass AuditReport extends Map {\n  static load (tree, opts) {\n    return new AuditReport(tree, opts).run()\n  }\n\n  get auditReportVersion () {\n    return 2\n  }\n\n  toJSON () {\n    const obj = {\n      auditReportVersion: this.auditReportVersion,\n      vulnerabilities: {},\n      metadata: {\n        vulnerabilities: {\n          info: 0,\n          low: 0,\n          moderate: 0,\n          high: 0,\n          critical: 0,\n          total: this.size,\n        },\n        dependencies: {\n          prod: 0,\n          dev: 0,\n          optional: 0,\n          peer: 0,\n          peerOptional: 0,\n          total: this.tree.inventory.size - 1,\n        },\n      },\n    }\n\n    for (const node of this.tree.inventory.values()) {\n      const { dependencies } = obj.metadata\n      let prod = true\n      for (const type of [\n        'dev',\n        'optional',\n        'peer',\n        'peerOptional',\n      ]) {\n        if (node[type]) {\n          dependencies[type]++\n          prod = false\n        }\n      }\n      if (prod)\n        dependencies.prod++\n    }\n\n    // if it doesn't have any topVulns, then it's fixable with audit fix\n    // for each topVuln, figure out if it's fixable with audit fix --force,\n    // or if we have to just delete the thing, and if the fix --force will\n    // require a semver major update.\n    const vulnerabilities = []\n    for (const [name, vuln] of this.entries()) {\n      vulnerabilities.push([name, vuln.toJSON()])\n      obj.metadata.vulnerabilities[vuln.severity]++\n    }\n\n    obj.vulnerabilities = vulnerabilities\n      .sort(([a], [b]) => a.localeCompare(b))\n      .reduce((set, [name, vuln]) => {\n        set[name] = vuln\n        return set\n      }, {})\n\n    return obj\n  }\n\n  constructor (tree, opts = {}) {\n    super()\n    this[_omit] = new Set(opts.omit || [])\n    this.topVulns = new Map()\n\n    this.calculator = new Calculator(opts)\n    this.error = null\n    this.options = opts\n    this.log = opts.log || procLog\n    this.tree = tree\n  }\n\n  async run () {\n    this.report = await this[_getReport]()\n    if (this.report)\n      await this[_init]()\n    return this\n  }\n\n  isVulnerable (node) {\n    const vuln = this.get(node.package.name)\n    return !!(vuln && vuln.isVulnerable(node))\n  }\n\n  async [_init] () {\n    process.emit('time', 'auditReport:init')\n\n    const promises = []\n    for (const [name, advisories] of Object.entries(this.report)) {\n      for (const advisory of advisories)\n        promises.push(this.calculator.calculate(name, advisory))\n    }\n\n    // now the advisories are calculated with a set of versions\n    // and the packument.  turn them into our style of vuln objects\n    // which also have the affected nodes, and also create entries\n    // for all the metavulns that we find from dependents.\n    const advisories = new Set(await Promise.all(promises))\n    const seen = new Set()\n    for (const advisory of advisories) {\n      const { name, range } = advisory\n\n      // don't flag the exact same name/range more than once\n      // adding multiple advisories with the same range is fine, but no\n      // need to search for nodes we already would have added.\n      const k = `${name}@${range}`\n      if (seen.has(k))\n        continue\n\n      seen.add(k)\n\n      const vuln = this.get(name) || new Vuln({ name, advisory })\n      if (this.has(name))\n        vuln.addAdvisory(advisory)\n      super.set(name, vuln)\n\n      const p = []\n      for (const node of this.tree.inventory.query('name', name)) {\n        if (shouldOmit(node, this[_omit]))\n          continue\n\n        // if not vulnerable by this advisory, keep searching\n        if (!advisory.testVersion(node.version))\n          continue\n\n        // we will have loaded the source already if this is a metavuln\n        if (advisory.type === 'metavuln')\n          vuln.addVia(this.get(advisory.dependency))\n\n        // already marked this one, no need to do it again\n        if (vuln.nodes.has(node))\n          continue\n\n        // haven't marked this one yet.  get its dependents.\n        vuln.nodes.add(node)\n        for (const { from: dep, spec } of node.edgesIn) {\n          if (dep.isTop && !vuln.topNodes.has(dep))\n            this[_checkTopNode](dep, vuln, spec)\n          else {\n            // calculate a metavuln, if necessary\n            p.push(this.calculator.calculate(dep.name, advisory).then(meta => {\n              if (meta.testVersion(dep.version, spec))\n                advisories.add(meta)\n            }))\n          }\n        }\n      }\n      await Promise.all(p)\n\n      // make sure we actually got something.  if not, remove it\n      // this can happen if you are loading from a lockfile created by\n      // npm v5, since it lists the current version of all deps,\n      // rather than the range that is actually depended upon,\n      // or if using --omit with the older audit endpoint.\n      if (this.get(name).nodes.size === 0) {\n        this.delete(name)\n        continue\n      }\n\n      // if the vuln is valid, but THIS advisory doesn't apply to any of\n      // the nodes it references, then remove it from the advisory list.\n      // happens when using omit with old audit endpoint.\n      for (const advisory of vuln.advisories) {\n        const relevant = [...vuln.nodes].some(n => advisory.testVersion(n.version))\n        if (!relevant)\n          vuln.deleteAdvisory(advisory)\n      }\n    }\n    process.emit('timeEnd', 'auditReport:init')\n  }\n\n  [_checkTopNode] (topNode, vuln, spec) {\n    vuln.fixAvailable = this[_fixAvailable](topNode, vuln, spec)\n\n    if (vuln.fixAvailable !== true) {\n      // now we know the top node is vulnerable, and cannot be\n      // upgraded out of the bad place without --force.  But, there's\n      // no need to add it to the actual vulns list, because nothing\n      // depends on root.\n      this.topVulns.set(vuln.name, vuln)\n      vuln.topNodes.add(topNode)\n    }\n  }\n\n  // check whether the top node is vulnerable.\n  // check whether we can get out of the bad place with --force, and if\n  // so, whether that update is SemVer Major\n  [_fixAvailable] (topNode, vuln, spec) {\n    // this will always be set to at least {name, versions:{}}\n    const paku = vuln.packument\n\n    if (!vuln.testSpec(spec))\n      return true\n\n    // similarly, even if we HAVE a packument, but we're looking for it\n    // somewhere other than the registry, and we got something vulnerable,\n    // then we're stuck with it.\n    const specObj = npa(spec)\n    if (!specObj.registry)\n      return false\n\n    // We don't provide fixes for top nodes other than root, but we\n    // still check to see if the node is fixable with a different version,\n    // and if that is a semver major bump.\n    try {\n      const {\n        _isSemVerMajor: isSemVerMajor,\n        version,\n        name,\n      } = pickManifest(paku, spec, {\n        ...this.options,\n        before: null,\n        avoid: vuln.range,\n        avoidStrict: true,\n      })\n      return {name, version, isSemVerMajor}\n    } catch (er) {\n      return false\n    }\n  }\n\n  set () {\n    throw new Error('do not call AuditReport.set() directly')\n  }\n\n  // convert a quick-audit into a bulk advisory listing\n  static auditToBulk (report) {\n    if (!report.advisories) {\n      // tack on the report json where the response body would go\n      throw Object.assign(new Error('Invalid advisory report'), {\n        body: JSON.stringify(report),\n      })\n    }\n\n    const bulk = {}\n    const {advisories} = report\n    for (const advisory of Object.values(advisories)) {\n      const {\n        id,\n        url,\n        title,\n        severity = 'high',\n        vulnerable_versions = '*',\n        module_name: name,\n      } = advisory\n      bulk[name] = bulk[name] || []\n      bulk[name].push({id, url, title, severity, vulnerable_versions})\n    }\n\n    return bulk\n  }\n\n  async [_getReport] () {\n    // if we're not auditing, just return false\n    if (this.options.audit === false || this.tree.inventory.size === 1)\n      return null\n\n    process.emit('time', 'auditReport:getReport')\n    try {\n      try {\n        // first try the super fast bulk advisory listing\n        const body = prepareBulkData(this.tree, this[_omit])\n\n        // no sense asking if we don't have anything to audit,\n        // we know it'll be empty\n        if (!Object.keys(body).length)\n          return null\n\n        const res = await fetch('/-/npm/v1/security/advisories/bulk', {\n          ...this.options,\n          registry: this.options.auditRegistry || this.options.registry,\n          method: 'POST',\n          gzip: true,\n          body,\n        })\n\n        return await res.json()\n      } catch (_) {\n        // that failed, try the quick audit endpoint\n        const body = prepareData(this.tree, this.options)\n        const res = await fetch('/-/npm/v1/security/audits/quick', {\n          ...this.options,\n          registry: this.options.auditRegistry || this.options.registry,\n          method: 'POST',\n          gzip: true,\n          body,\n        })\n        return AuditReport.auditToBulk(await res.json())\n      }\n    } catch (er) {\n      this.log.verbose('audit error', er)\n      this.log.silly('audit error', String(er.body))\n      this.error = er\n      return null\n    } finally {\n      process.emit('timeEnd', 'auditReport:getReport')\n    }\n  }\n}\n\n// return true if we should ignore this one\nconst shouldOmit = (node, omit) =>\n  !node.version ? true\n  : omit.size === 0 ? false\n  : node.dev && omit.has('dev') ||\n    node.optional && omit.has('optional') ||\n    node.devOptional && omit.has('dev') && omit.has('optional') ||\n    node.peer && omit.has('peer')\n\nconst prepareBulkData = (tree, omit) => {\n  const payload = {}\n  for (const name of tree.inventory.query('name')) {\n    const set = new Set()\n    for (const node of tree.inventory.query('name', name)) {\n      if (shouldOmit(node, omit))\n        continue\n\n      set.add(node.version)\n    }\n    if (set.size)\n      payload[name] = [...set]\n  }\n  return payload\n}\n\nconst prepareData = (tree, opts) => {\n  const { npmVersion: npm_version } = opts\n  const node_version = process.version\n  const { platform, arch } = process\n  const { NODE_ENV: node_env } = process.env\n  const data = tree.meta.commit()\n  // the legacy audit endpoint doesn't support any kind of pre-filtering\n  // we just have to get the advisories and skip over them in the report\n  return {\n    name: data.name,\n    version: data.version,\n    requires: {\n      ...(tree.package.devDependencies || {}),\n      ...(tree.package.peerDependencies || {}),\n      ...(tree.package.optionalDependencies || {}),\n      ...(tree.package.dependencies || {}),\n    },\n    dependencies: data.dependencies,\n    metadata: {\n      node_version,\n      npm_version,\n      platform,\n      arch,\n      node_env,\n    },\n  }\n}\n\nmodule.exports = AuditReport\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"// inventory, path, realpath, root, and parent\n//\n// node.root is a reference to the root module in the tree (ie, typically the\n// cwd project folder)\n//\n// node.location is the /-delimited path from the root module to the node.  In\n// the case of link targets that may be outside of the root's package tree,\n// this can include some number of /../ path segments.  The location of the\n// root module is always '.'.  node.location thus never contains drive letters\n// or absolute paths, and is portable within a given project, suitable for\n// inclusion in lockfiles and metadata.\n//\n// node.path is the path to the place where this node lives on disk.  It is\n// system-specific and absolute.\n//\n// node.realpath is the path to where the module actually resides on disk.  In\n// the case of non-link nodes, node.realpath is equivalent to node.path.  In\n// the case of link nodes, it is equivalent to node.target.path.\n//\n// Setting node.parent will set the node's root to the parent's root, as well\n// as updating edgesIn and edgesOut to reload dependency resolutions as needed,\n// and setting node.path to parent.path/node_modules/name.\n//\n// node.inventory is a Map of name to a Set() of all the nodes under a given\n// root by that name.  It's empty for non-root nodes, and changing the root\n// reference will remove it from the old root's inventory and add it to the new\n// one.  This map is useful for cases like `npm update foo` or `npm ls foo`\n// where we need to quickly find all instances of a given package name within a\n// tree.\nconst nameFromFolder = require('@npmcli/name-from-folder');\n\nconst Edge = require('./edge.js');\n\nconst Inventory = require('./inventory.js');\n\nconst {\n  normalize\n} = require('read-package-json-fast');\n\nconst {\n  getPaths: getBinPaths\n} = require('bin-links');\n\nconst npa = require('npm-package-arg');\n\nconst debug = require('./debug.js');\n\nconst gatherDepSet = require('./gather-dep-set.js');\n\nconst treeCheck = require('./tree-check.js');\n\nconst walkUp = require('walk-up-path');\n\nconst {\n  resolve,\n  relative,\n  dirname,\n  basename\n} = require('path');\n\nconst util = require('util');\n\nconst _package = Symbol('_package');\n\nconst _parent = Symbol('_parent');\n\nconst _target = Symbol.for('_target');\n\nconst _fsParent = Symbol('_fsParent');\n\nconst _loadDepType = Symbol('_loadDepType');\n\nconst _loadWorkspaces = Symbol('_loadWorkspaces');\n\nconst _reloadNamedEdges = Symbol('_reloadNamedEdges'); // overridden by Link class\n\n\nconst _loadDeps = Symbol.for('Arborist.Node._loadDeps');\n\nconst _root = Symbol('_root');\n\nconst _refreshLocation = Symbol.for('_refreshLocation');\n\nconst _changePath = Symbol.for('_changePath'); // used by Link class as well\n\n\nconst _delistFromMeta = Symbol.for('_delistFromMeta');\n\nconst _global = Symbol.for('global');\n\nconst _workspaces = Symbol('_workspaces');\n\nconst _explain = Symbol('_explain');\n\nconst _explanation = Symbol('_explanation');\n\nconst _meta = Symbol('_meta');\n\nconst relpath = require('./relpath.js');\n\nconst consistentResolve = require('./consistent-resolve.js');\n\nconst printableTree = require('./printable.js');\n\nclass Node {\n  constructor(options) {\n    // NB: path can be null if it's a link target\n    const {\n      root,\n      path,\n      realpath,\n      parent,\n      error,\n      meta,\n      fsParent,\n      resolved,\n      integrity,\n      // allow setting name explicitly when we haven't set a path yet\n      name,\n      children,\n      fsChildren,\n      legacyPeerDeps = false,\n      linksIn,\n      hasShrinkwrap,\n      extraneous = true,\n      dev = true,\n      optional = true,\n      devOptional = true,\n      peer = true,\n      global = false,\n      dummy = false,\n      sourceReference = null\n    } = options; // true if part of a global install\n\n    this[_global] = global;\n    this[_workspaces] = null;\n    this.errors = error ? [error] : []; // this will usually be null, except when modeling a\n    // package's dependencies in a virtual root.\n\n    this.sourceReference = sourceReference;\n    const pkg = sourceReference ? sourceReference.package : normalize(options.pkg || {});\n    this.name = name || nameFromFolder(path || pkg.name || realpath) || pkg.name || null; // should be equal if not a link\n\n    this.path = path ? resolve(path) : null;\n    if (!this.name && (!this.path || this.path !== dirname(this.path))) throw new TypeError('could not detect node name from path or package');\n    this.realpath = !this.isLink ? this.path : resolve(realpath);\n    this.resolved = resolved || null;\n\n    if (!this.resolved) {\n      // note: this *only* works for non-file: deps, so we avoid even\n      // trying here.\n      // file: deps are tracked in package.json will _resolved set to the\n      // full path to the tarball or link target.  However, if the package\n      // is checked into git or moved to another location, that's 100% not\n      // portable at all!  The _where and _location don't provide much help,\n      // since _location is just where the module ended up in the tree,\n      // and _where can be different than the actual root if it's a\n      // meta-dep deeper in the dependency graph.\n      //\n      // If we don't have the other oldest indicators of legacy npm, then it's\n      // probably what we're getting from pacote, which IS trustworthy.\n      //\n      // Otherwise, hopefully a shrinkwrap will help us out.\n      const resolved = consistentResolve(pkg._resolved);\n      if (resolved && !(/^file:/.test(resolved) && pkg._where)) this.resolved = resolved;\n    }\n\n    this.integrity = integrity || pkg._integrity || null;\n    this.hasShrinkwrap = hasShrinkwrap || pkg._hasShrinkwrap || false;\n    this.legacyPeerDeps = legacyPeerDeps;\n    this.children = new Map();\n    this.fsChildren = new Set();\n    this.inventory = new Inventory({});\n    this.tops = new Set();\n    this.linksIn = new Set(linksIn || []); // these three are set by an Arborist taking a catalog\n    // after the tree is built.  We don't get this along the way,\n    // because they have a tendency to change as new children are\n    // added, especially when they're deduped.  Eg, a dev dep may be\n    // a 3-levels-deep dependency of a non-dev dep.  If we calc the\n    // flags along the way, then they'll tend to be invalid  by the\n    // time we need to look at them.\n\n    if (!dummy) {\n      this.dev = dev;\n      this.optional = optional;\n      this.devOptional = devOptional;\n      this.peer = peer;\n      this.extraneous = extraneous;\n      this.dummy = false;\n    } else {\n      // true if this is a placeholder for the purpose of serving as a\n      // fsParent to link targets that get their deps resolved outside\n      // the root tree folder.\n      this.dummy = true;\n      this.dev = false;\n      this.optional = false;\n      this.devOptional = false;\n      this.peer = false;\n      this.extraneous = false;\n    }\n\n    this.edgesIn = new Set();\n    this.edgesOut = new Map(); // have to set the internal package ref before assigning the parent,\n    // because this.package is read when adding to inventory\n\n    this[_package] = pkg && typeof pkg === 'object' ? pkg : {}; // only relevant for the root and top nodes\n\n    this.meta = meta; // Note: this is _slightly_ less efficient for the initial tree\n    // building than it could be, but in exchange, it's a much simpler\n    // algorithm.\n    // If this node has a bunch of children, and those children satisfy\n    // its various deps, then we're going to _first_ create all the\n    // edges, and _then_ assign the children into place, re-resolving\n    // them all in _reloadNamedEdges.\n    // A more efficient, but more complicated, approach would be to\n    // flag this node as being a part of a tree build, so it could\n    // hold off on resolving its deps until its children are in place.\n    // call the parent setter\n    // Must be set prior to calling _loadDeps, because top-ness is relevant\n    // will also assign root if present on the parent\n\n    this[_parent] = null;\n    this.parent = parent || null;\n    this[_fsParent] = null;\n    this.fsParent = fsParent || null; // see parent/root setters below.\n    // root is set to parent's root if we have a parent, otherwise if it's\n    // null, then it's set to the node itself.\n\n    if (!parent && !fsParent) this.root = root || null; // mostly a convenience for testing, but also a way to create\n    // trees in a more declarative way than setting parent on each\n\n    if (children) {\n      for (const c of children) new Node({ ...c,\n        parent: this\n      });\n    }\n\n    if (fsChildren) {\n      for (const c of fsChildren) new Node({ ...c,\n        fsParent: this\n      });\n    } // now load all the dep edges\n\n\n    this[_loadDeps]();\n  }\n\n  get meta() {\n    return this[_meta];\n  }\n\n  set meta(meta) {\n    this[_meta] = meta;\n    if (meta) meta.add(this);\n  }\n\n  get global() {\n    return this.root[_global];\n  } // true for packages installed directly in the global node_modules folder\n\n\n  get globalTop() {\n    return this.global && this.parent.isProjectRoot;\n  }\n\n  get workspaces() {\n    return this[_workspaces];\n  }\n\n  set workspaces(workspaces) {\n    // deletes edges if they already exists\n    if (this[_workspaces]) {\n      for (const name of this[_workspaces].keys()) {\n        if (!workspaces.has(name)) this.edgesOut.get(name).detach();\n      }\n    }\n\n    this[_workspaces] = workspaces;\n\n    this[_loadWorkspaces]();\n\n    this[_loadDeps]();\n  }\n\n  get binPaths() {\n    if (!this.parent) return [];\n    return getBinPaths({\n      pkg: this[_package],\n      path: this.path,\n      global: this.global,\n      top: this.globalTop\n    });\n  }\n\n  get hasInstallScript() {\n    const {\n      hasInstallScript,\n      scripts\n    } = this.package;\n    const {\n      install,\n      preinstall,\n      postinstall\n    } = scripts || {};\n    return !!(hasInstallScript || install || preinstall || postinstall);\n  }\n\n  get version() {\n    return this[_package].version || '';\n  }\n\n  get pkgid() {\n    const {\n      name = '',\n      version = ''\n    } = this.package; // root package will prefer package name over folder name,\n    // and never be called an alias.\n\n    const {\n      isProjectRoot\n    } = this;\n    const myname = isProjectRoot ? name || this.name : this.name;\n    const alias = !isProjectRoot && name && myname !== name ? `npm:${name}@` : '';\n    return `${myname}@${alias}${version}`;\n  }\n\n  get package() {\n    return this[_package];\n  }\n\n  set package(pkg) {\n    // just detach them all.  we could make this _slightly_ more efficient\n    // by only detaching the ones that changed, but we'd still have to walk\n    // them all, and the comparison logic gets a bit tricky.  we generally\n    // only do this more than once at the root level, so the resolve() calls\n    // are only one level deep, and there's not much to be saved, anyway.\n    // simpler to just toss them all out.\n    for (const edge of this.edgesOut.values()) edge.detach();\n\n    this[_explanation] = null;\n    /* istanbul ignore next - should be impossible */\n\n    if (!pkg || typeof pkg !== 'object') {\n      debug(() => {\n        throw new Error('setting Node.package to non-object');\n      });\n      pkg = {};\n    }\n\n    this[_package] = pkg;\n\n    this[_loadWorkspaces]();\n\n    this[_loadDeps](); // do a hard reload, since the dependents may now be valid or invalid\n    // as a result of the package change.\n\n\n    this.edgesIn.forEach(edge => edge.reload(true));\n  } // node.explain(nodes seen already, edge we're trying to satisfy\n  // if edge is not specified, it lists every edge into the node.\n\n\n  explain(edge = null, seen = []) {\n    if (this[_explanation]) return this[_explanation];\n    return this[_explanation] = this[_explain](edge, seen);\n  }\n\n  [_explain](edge, seen) {\n    if (this.isProjectRoot && !this.sourceReference) {\n      return {\n        location: this.path\n      };\n    }\n\n    const why = {\n      name: this.isProjectRoot ? this.package.name : this.name,\n      version: this.package.version\n    };\n\n    if (this.errors.length || !this.package.name || !this.package.version) {\n      why.errors = this.errors.length ? this.errors : [new Error('invalid package: lacks name and/or version')];\n      why.package = this.package;\n    }\n\n    if (this.root.sourceReference) {\n      const {\n        name,\n        version\n      } = this.root.package;\n      why.whileInstalling = {\n        name,\n        version,\n        path: this.root.sourceReference.path\n      };\n    }\n\n    if (this.sourceReference) return this.sourceReference.explain(edge, seen);\n    if (seen.includes(this)) return why;\n    why.location = this.location; // make a new list each time.  we can revisit, but not loop.\n\n    seen = seen.concat(this);\n    why.dependents = [];\n    if (edge) why.dependents.push(edge.explain(seen));else {\n      // ignore invalid edges, since those aren't satisfied by this thing,\n      // and are not keeping it held in this spot anyway.\n      const edges = [];\n\n      for (const edge of this.edgesIn) {\n        if (!edge.valid && !edge.from.isProjectRoot) continue;\n        edges.push(edge);\n      }\n\n      for (const edge of edges) why.dependents.push(edge.explain(seen));\n    }\n    return why;\n  }\n\n  isDescendantOf(node) {\n    for (let p = this; p; p = p.parent) {\n      if (p === node) return true;\n    }\n\n    return false;\n  }\n\n  getBundler(path = []) {\n    // made a cycle, definitely not bundled!\n    if (path.includes(this)) return null;\n    path.push(this);\n    const parent = this[_parent];\n    if (!parent) return null;\n    const pBundler = parent.getBundler(path);\n    if (pBundler) return pBundler;\n    const ppkg = parent.package;\n    const bd = ppkg && ppkg.bundleDependencies; // explicit bundling\n\n    if (Array.isArray(bd) && bd.includes(this.name)) return parent; // deps that are deduped up to the bundling level are bundled.\n    // however, if they get their dep met further up than that,\n    // then they are not bundled.  Ie, installing a package with\n    // unmet bundled deps will not cause your deps to be bundled.\n\n    for (const edge of this.edgesIn) {\n      const eBundler = edge.from.getBundler(path);\n      if (!eBundler) continue;\n      if (eBundler === parent) return eBundler;\n    }\n\n    return null;\n  }\n\n  get inBundle() {\n    return !!this.getBundler();\n  } // when reifying, if a package is technically in a bundleDependencies list,\n  // but that list is the root project, we still have to install it.  This\n  // getter returns true if it's in a dependency's bundle list, not the root's.\n\n\n  get inDepBundle() {\n    const bundler = this.getBundler();\n    return !!bundler && bundler !== this.root;\n  }\n\n  get isWorkspace() {\n    if (this.isProjectRoot) return false;\n    const {\n      root\n    } = this;\n    const {\n      type,\n      to\n    } = root.edgesOut.get(this.package.name) || {};\n    return type === 'workspace' && to && (to.target === this || to === this);\n  }\n\n  get isRoot() {\n    return this === this.root;\n  }\n\n  get isProjectRoot() {\n    return this === this.root || this === this.root.target;\n  }\n\n  set root(root) {\n    // setting to null means this is the new root\n    // should only ever be one step\n    while (root && root.root !== root) root = root.root;\n\n    root = root || this; // delete from current root inventory\n\n    this[_delistFromMeta](); // can't set the root (yet) if there's no way to determine location\n    // this allows us to do new Node({...}) and then set the root later.\n    // just make the assignment so we don't lose it, and move on.\n\n\n    if (!this.path || !root.realpath || !root.path) return this[_root] = root; // temporarily become a root node\n\n    this[_root] = this; // break all linksIn, we're going to re-set them if needed later\n\n    for (const link of this.linksIn) {\n      link[_target] = null;\n      this.linksIn.delete(link);\n    } // temporarily break this link as well, we'll re-set if possible later\n\n\n    const {\n      target\n    } = this;\n\n    if (this.isLink) {\n      if (target) {\n        target.linksIn.delete(this);\n        if (target.root === this) target[_delistFromMeta]();\n      }\n\n      this[_target] = null;\n    } // if this is part of a cascading root set, then don't do this bit\n    // but if the parent/fsParent is in a different set, we have to break\n    // that reference before proceeding\n\n\n    if (this.parent && this.parent.root !== root) {\n      this.parent.children.delete(this.name);\n      this[_parent] = null;\n    }\n\n    if (this.fsParent && this.fsParent.root !== root) {\n      this.fsParent.fsChildren.delete(this);\n      this[_fsParent] = null;\n    }\n\n    if (root === this) this[_refreshLocation]();else {\n      // setting to some different node.\n      const loc = relpath(root.realpath, this.path);\n      const current = root.inventory.get(loc); // clobber whatever is there now\n\n      if (current) current.root = null;\n      this[_root] = root; // set this.location and add to inventory\n\n      this[_refreshLocation](); // try to find our parent/fsParent in the new root inventory\n\n\n      for (const p of walkUp(dirname(this.path))) {\n        const ploc = relpath(root.realpath, p);\n        const parent = root.inventory.get(ploc);\n\n        if (parent) {\n          /* istanbul ignore next - impossible */\n          if (parent.isLink) {\n            debug(() => {\n              throw Object.assign(new Error('assigning parentage to link'), {\n                path: this.path,\n                parent: parent.path,\n                parentReal: parent.realpath\n              });\n            });\n            continue;\n          }\n\n          const childLoc = `${ploc}${ploc ? '/' : ''}node_modules/${this.name}`;\n          const isParent = this.location === childLoc;\n\n          if (isParent) {\n            const oldChild = parent.children.get(this.name);\n            if (oldChild && oldChild !== this) oldChild.root = null;\n\n            if (this.parent) {\n              this.parent.children.delete(this.name);\n\n              this.parent[_reloadNamedEdges](this.name);\n            }\n\n            parent.children.set(this.name, this);\n            this[_parent] = parent; // don't do it for links, because they don't have a target yet\n            // we'll hit them up a bit later on.\n\n            if (!this.isLink) parent[_reloadNamedEdges](this.name);\n          } else {\n            /* istanbul ignore if - should be impossible, since we break\n             * all fsParent/child relationships when moving? */\n            if (this.fsParent) this.fsParent.fsChildren.delete(this);\n            parent.fsChildren.add(this);\n            this[_fsParent] = parent;\n          }\n\n          break;\n        }\n      } // if it doesn't have a parent, it's a top node\n\n\n      if (!this.parent) root.tops.add(this);else root.tops.delete(this); // assign parentage for any nodes that need to have this as a parent\n      // this can happen when we have a node at nm/a/nm/b added *before*\n      // the node at nm/a, which might have the root node as a fsParent.\n      // we can't rely on the public setter here, because it calls into\n      // this function to set up these references!\n\n      const nmloc = `${this.location}${this.location ? '/' : ''}node_modules/`;\n\n      const isChild = n => n.location === nmloc + n.name; // check dirname so that /foo isn't treated as the fsparent of /foo-bar\n\n\n      const isFsChild = n => dirname(n.path).startsWith(this.path) && n !== this && !n.parent && (!n.fsParent || n.fsParent === this || dirname(this.path).startsWith(n.fsParent.path));\n\n      const isKid = n => isChild(n) || isFsChild(n); // only walk top nodes, since anything else already has a parent.\n\n\n      for (const child of root.tops) {\n        if (!isKid(child)) continue; // set up the internal parentage links\n\n        if (this.isLink) child.root = null;else {\n          // can't possibly have a parent, because it's in tops\n          if (child.fsParent) child.fsParent.fsChildren.delete(child);\n          child[_fsParent] = null;\n\n          if (isChild(child)) {\n            this.children.set(child.name, child);\n            child[_parent] = this;\n            root.tops.delete(child);\n          } else {\n            this.fsChildren.add(child);\n            child[_fsParent] = this;\n          }\n        }\n      } // look for any nodes with the same realpath.  either they're links\n      // to that realpath, or a thing at that realpath if we're adding a link\n      // (if we're adding a regular node, we already deleted the old one)\n\n\n      for (const node of root.inventory.query('realpath', this.realpath)) {\n        if (node === this) continue;\n        /* istanbul ignore next - should be impossible */\n\n        debug(() => {\n          if (node.root !== root) throw new Error('inventory contains node from other root');\n        });\n\n        if (this.isLink) {\n          const target = node.target || node;\n          this[_target] = target;\n          this[_package] = target.package;\n          target.linksIn.add(this); // reload edges here, because now we have a target\n\n          if (this.parent) this.parent[_reloadNamedEdges](this.name);\n          break;\n        } else {\n          /* istanbul ignore else - should be impossible */\n          if (node.isLink) {\n            node[_target] = this;\n            node[_package] = this.package;\n            this.linksIn.add(node);\n            if (node.parent) node.parent[_reloadNamedEdges](node.name);\n          } else {\n            debug(() => {\n              throw Object.assign(new Error('duplicate node in root setter'), {\n                path: this.path,\n                realpath: this.realpath,\n                root: root.realpath\n              });\n            });\n          }\n        }\n      }\n    } // reload all edgesIn where the root doesn't match, so we don't have\n    // cross-tree dependency graphs\n\n    for (const edge of this.edgesIn) {\n      if (edge.from.root !== root) edge.reload();\n    } // reload all edgesOut where root doens't match, or is missing, since\n    // it might not be missing in the new tree\n\n\n    for (const edge of this.edgesOut.values()) {\n      if (!edge.to || edge.to.root !== root) edge.reload();\n    } // now make sure our family comes along for the ride!\n\n\n    const family = new Set([...this.fsChildren, ...this.children.values(), ...this.inventory.values()].filter(n => n !== this));\n\n    for (const child of family) {\n      if (child.root !== root) {\n        child[_delistFromMeta]();\n\n        child[_parent] = null;\n        this.children.delete(child.name);\n        child[_fsParent] = null;\n        this.fsChildren.delete(child);\n\n        for (const l of child.linksIn) {\n          l[_target] = null;\n          child.linksIn.delete(l);\n        }\n      }\n    }\n\n    for (const child of family) {\n      if (child.root !== root) child.root = root;\n    } // if we had a target, and didn't find one in the new root, then bring\n    // it over as well, but only if we're setting the link into a new root,\n    // as we don't want to lose the target any time we remove a link.\n\n\n    if (this.isLink && target && !this.target && root !== this) target.root = root; // tree should always be valid upon root setter completion.\n\n    treeCheck(this);\n    treeCheck(root);\n  }\n\n  get root() {\n    return this[_root] || this;\n  }\n\n  [_loadWorkspaces]() {\n    if (!this[_workspaces]) return;\n\n    for (const [name, path] of this[_workspaces].entries()) new Edge({\n      from: this,\n      name,\n      spec: `file:${path}`,\n      type: 'workspace'\n    });\n  }\n\n  [_loadDeps]() {\n    // Caveat!  Order is relevant!\n    // packages in optionalDependencies and prod/peer/dev are\n    // optional.  Packages in both deps and devDeps are required.\n    // Note the subtle breaking change from v6: it is no longer possible\n    // to have a different spec for a devDep than production dep.\n    this[_loadDepType](this.package.optionalDependencies, 'optional'); // Linked targets that are disconnected from the tree are tops,\n    // but don't have a 'path' field, only a 'realpath', because we\n    // don't know their canonical location. We don't need their devDeps.\n\n\n    const {\n      isTop,\n      path,\n      sourceReference\n    } = this;\n    const {\n      isTop: srcTop,\n      path: srcPath\n    } = sourceReference || {};\n    if (isTop && path && (!sourceReference || srcTop && srcPath)) this[_loadDepType](this.package.devDependencies, 'dev');\n    const pd = this.package.peerDependencies;\n\n    if (pd && typeof pd === 'object' && !this.legacyPeerDeps) {\n      const pm = this.package.peerDependenciesMeta || {};\n      const peerDependencies = {};\n      const peerOptional = {};\n\n      for (const [name, dep] of Object.entries(pd)) {\n        if (pm[name] && pm[name].optional) peerOptional[name] = dep;else peerDependencies[name] = dep;\n      }\n\n      this[_loadDepType](peerDependencies, 'peer');\n\n      this[_loadDepType](peerOptional, 'peerOptional');\n    }\n\n    this[_loadDepType](this.package.dependencies, 'prod');\n  }\n\n  [_loadDepType](obj, type) {\n    const from = this;\n    const ad = this.package.acceptDependencies || {};\n\n    for (const [name, spec] of Object.entries(obj || {})) {\n      const accept = ad[name]; // if it's already set, then we keep the existing edge\n      // Prod deps should not be marked as dev, however.\n      // NB: the Edge ctor adds itself to from.edgesOut\n\n      const current = this.edgesOut.get(name);\n      if (!current || current.dev && type === 'prod') new Edge({\n        from,\n        name,\n        spec,\n        accept,\n        type\n      });\n    }\n  }\n\n  get fsParent() {\n    return this[_fsParent];\n  }\n\n  set fsParent(fsParent) {\n    if (!fsParent) {\n      if (this[_fsParent]) this.root = null;\n      return;\n    }\n\n    debug(() => {\n      if (fsParent === this) throw new Error('setting node to its own fsParent');\n      if (fsParent.realpath === this.realpath) throw new Error('setting fsParent to same path'); // the initial set MUST be an actual walk-up from the realpath\n      // subsequent sets will re-root on the new fsParent's path.\n\n      if (!this[_fsParent] && this.realpath.indexOf(fsParent.realpath) !== 0) {\n        throw Object.assign(new Error('setting fsParent improperly'), {\n          path: this.path,\n          realpath: this.realpath,\n          fsParent: {\n            path: fsParent.path,\n            realpath: fsParent.realpath\n          }\n        });\n      }\n    });\n    if (fsParent.isLink) fsParent = fsParent.target; // setting a thing to its own fsParent is not normal, but no-op for safety\n\n    if (this === fsParent || fsParent.realpath === this.realpath) return; // nothing to do\n\n    if (this[_fsParent] === fsParent) return;\n    const oldFsParent = this[_fsParent];\n    const newPath = !oldFsParent ? this.path : resolve(fsParent.path, relative(oldFsParent.path, this.path));\n    const nmPath = resolve(fsParent.path, 'node_modules', this.name); // this is actually the parent, set that instead\n\n    if (newPath === nmPath) {\n      this.parent = fsParent;\n      return;\n    }\n\n    const pathChange = newPath !== this.path; // remove from old parent/fsParent\n\n    const oldParent = this.parent;\n    const oldName = this.name;\n\n    if (this.parent) {\n      this.parent.children.delete(this.name);\n      this[_parent] = null;\n    }\n\n    if (this.fsParent) {\n      this.fsParent.fsChildren.delete(this);\n      this[_fsParent] = null;\n    } // update this.path/realpath for this and all children/fsChildren\n\n\n    if (pathChange) this[_changePath](newPath);\n    if (oldParent) oldParent[_reloadNamedEdges](oldName); // clobbers anything at that path, resets all appropriate references\n\n    this.root = fsParent.root;\n  } // is it safe to replace one node with another?  check the edges to\n  // make sure no one will get upset.  Note that the node might end up\n  // having its own unmet dependencies, if the new node has new deps.\n  // Note that there are cases where Arborist will opt to insert a node\n  // into the tree even though this function returns false!  This is\n  // necessary when a root dependency is added or updated, or when a\n  // root dependency brings peer deps along with it.  In that case, we\n  // will go ahead and create the invalid state, and then try to resolve\n  // it with more tree construction, because it's a user request.\n\n\n  canReplaceWith(node) {\n    if (node.name !== this.name) return false; // gather up all the deps of this node and that are only depended\n    // upon by deps of this node.  those ones don't count, since\n    // they'll be replaced if this node is replaced anyway.\n\n    const depSet = gatherDepSet([this], e => e.to !== this && e.valid);\n\n    for (const edge of this.edgesIn) {\n      // only care about edges that don't originate from this node\n      if (!depSet.has(edge.from) && !edge.satisfiedBy(node)) return false;\n    }\n\n    return true;\n  }\n\n  canReplace(node) {\n    return node.canReplaceWith(this);\n  }\n\n  satisfies(requested) {\n    if (requested instanceof Edge) return this.name === requested.name && requested.satisfiedBy(this);\n    const parsed = npa(requested);\n    const {\n      name = this.name,\n      rawSpec: spec\n    } = parsed;\n    return this.name === name && this.satisfies(new Edge({\n      from: new Node({\n        path: this.root.realpath\n      }),\n      type: 'prod',\n      name,\n      spec\n    }));\n  }\n\n  matches(node) {\n    // if the nodes are literally the same object, obviously a match.\n    if (node === this) return true; // if the names don't match, they're different things, even if\n    // the package contents are identical.\n\n    if (node.name !== this.name) return false; // if they're links, they match if the targets match\n\n    if (this.isLink) return node.isLink && this.target.matches(node.target); // if they're two project root nodes, they're different if the paths differ\n\n    if (this.isProjectRoot && node.isProjectRoot) return this.path === node.path; // if the integrity matches, then they're the same.\n\n    if (this.integrity && node.integrity) return this.integrity === node.integrity; // if no integrity, check resolved\n\n    if (this.resolved && node.resolved) return this.resolved === node.resolved; // if no resolved, check both package name and version\n    // otherwise, conclude that they are different things\n\n    return this.package.name && node.package.name && this.package.name === node.package.name && this.version && node.version && this.version === node.version;\n  } // replace this node with the supplied argument\n  // Useful when mutating an ideal tree, so we can avoid having to call\n  // the parent/root setters more than necessary.\n\n\n  replaceWith(node) {\n    node.replace(this);\n  }\n\n  replace(node) {\n    this[_delistFromMeta]();\n\n    this.path = node.path;\n    this.name = node.name;\n    if (!this.isLink) this.realpath = this.path;\n\n    this[_refreshLocation](); // keep children when a node replaces another\n\n\n    if (!this.isLink) {\n      for (const kid of node.children.values()) kid.parent = this;\n    }\n\n    if (!node.isRoot) this.root = node.root;\n    treeCheck(this);\n  }\n\n  get inShrinkwrap() {\n    return this.parent && (this.parent.hasShrinkwrap || this.parent.inShrinkwrap);\n  }\n\n  get parent() {\n    return this[_parent];\n  } // This setter keeps everything in order when we move a node from\n  // one point in a logical tree to another.  Edges get reloaded,\n  // metadata updated, etc.  It's also called when we *replace* a node\n  // with another by the same name (eg, to update or dedupe).\n  // This does a couple of walks out on the node_modules tree, recursing\n  // into child nodes.  However, as setting the parent is typically done\n  // with nodes that don't have have many children, and (deduped) package\n  // trees tend to be broad rather than deep, it's not that bad.\n  // The only walk that starts from the parent rather than this node is\n  // limited by edge name.\n\n\n  set parent(parent) {\n    // when setting to null, just remove it from the tree entirely\n    if (!parent) {\n      // but only delete it if we actually had a parent in the first place\n      // otherwise it's just setting to null when it's already null\n      if (this[_parent]) this.root = null;\n      return;\n    }\n\n    if (parent.isLink) parent = parent.target; // setting a thing to its own parent is not normal, but no-op for safety\n\n    if (this === parent) return;\n    const oldParent = this[_parent]; // nothing to do\n\n    if (oldParent === parent) return; // ok now we know something is actually changing, and parent is not a link\n\n    const newPath = resolve(parent.path, 'node_modules', this.name);\n    const pathChange = newPath !== this.path; // remove from old parent/fsParent\n\n    if (oldParent) {\n      oldParent.children.delete(this.name);\n      this[_parent] = null;\n    }\n\n    if (this.fsParent) {\n      this.fsParent.fsChildren.delete(this);\n      this[_fsParent] = null;\n    } // update this.path/realpath for this and all children/fsChildren\n\n\n    if (pathChange) this[_changePath](newPath); // clobbers anything at that path, resets all appropriate references\n\n    this.root = parent.root;\n  } // Call this before changing path or updating the _root reference.\n  // Removes the node from its root the metadata and inventory.\n\n\n  [_delistFromMeta]() {\n    const root = this.root;\n    if (!root.realpath || !this.path) return;\n    root.inventory.delete(this);\n    root.tops.delete(this);\n    if (root.meta) root.meta.delete(this.path);\n    /* istanbul ignore next - should be impossible */\n\n    debug(() => {\n      if ([...root.inventory.values()].includes(this)) throw new Error('failed to delist');\n    });\n  } // update this.path/realpath and the paths of all children/fsChildren\n\n\n  [_changePath](newPath) {\n    // have to de-list before changing paths\n    this[_delistFromMeta]();\n\n    const oldPath = this.path;\n    this.path = newPath;\n    const namePattern = /(?:^|\\/|\\\\)node_modules[\\\\/](@[^/\\\\]+[\\\\/][^\\\\/]+|[^\\\\/]+)$/;\n    const nameChange = newPath.match(namePattern);\n    if (nameChange && this.name !== nameChange[1]) this.name = nameChange[1].replace(/\\\\/g, '/'); // if we move a link target, update link realpaths\n\n    if (!this.isLink) {\n      this.realpath = newPath;\n\n      for (const link of this.linksIn) {\n        link[_delistFromMeta]();\n\n        link.realpath = newPath;\n\n        link[_refreshLocation]();\n      }\n    } // if we move /x to /y, then a module at /x/a/b becomes /y/a/b\n\n\n    for (const child of this.fsChildren) child[_changePath](resolve(newPath, relative(oldPath, child.path)));\n\n    for (const [name, child] of this.children.entries()) child[_changePath](resolve(newPath, 'node_modules', name));\n\n    this[_refreshLocation]();\n  } // Called whenever the root/parent is changed.\n  // NB: need to remove from former root's meta/inventory and then update\n  // this.path BEFORE calling this method!\n\n\n  [_refreshLocation]() {\n    const root = this.root;\n    const loc = relpath(root.realpath, this.path);\n    this.location = loc;\n    root.inventory.add(this);\n    if (root.meta) root.meta.add(this);\n  }\n\n  addEdgeOut(edge) {\n    this.edgesOut.set(edge.name, edge);\n  }\n\n  addEdgeIn(edge) {\n    this.edgesIn.add(edge); // try to get metadata from the yarn.lock file\n\n    if (this.root.meta) this.root.meta.addEdge(edge);\n  }\n\n  [_reloadNamedEdges](name, rootLoc = this.location) {\n    const edge = this.edgesOut.get(name); // if we don't have an edge, do nothing, but keep descending\n\n    const rootLocResolved = edge && edge.to && edge.to.location === `${rootLoc}/node_modules/${edge.name}`;\n    const sameResolved = edge && this.resolve(name) === edge.to;\n    const recheck = rootLocResolved || !sameResolved;\n    if (edge && recheck) edge.reload(true);\n\n    for (const c of this.children.values()) c[_reloadNamedEdges](name, rootLoc);\n\n    for (const c of this.fsChildren) c[_reloadNamedEdges](name, rootLoc);\n  }\n\n  get isLink() {\n    return false;\n  }\n\n  get target() {\n    return null;\n  }\n\n  set target(n) {\n    debug(() => {\n      throw Object.assign(new Error('cannot set target on non-Link Nodes'), {\n        path: this.path\n      });\n    });\n  }\n\n  get depth() {\n    return this.isTop ? 0 : this.parent.depth + 1;\n  }\n\n  get isTop() {\n    return !this.parent;\n  }\n\n  get top() {\n    return this.isTop ? this : this.parent.top;\n  }\n\n  get resolveParent() {\n    return this.parent || this.fsParent;\n  }\n\n  resolve(name) {\n    const mine = this.children.get(name);\n    if (mine) return mine;\n    const resolveParent = this.resolveParent;\n    if (resolveParent) return resolveParent.resolve(name);\n    return null;\n  }\n\n  inNodeModules() {\n    const rp = this.realpath;\n    const name = this.name;\n    const scoped = name.charAt(0) === '@';\n    const d = dirname(rp);\n    const nm = scoped ? dirname(d) : d;\n    const dir = dirname(nm);\n    const base = scoped ? `${basename(d)}/${basename(rp)}` : basename(rp);\n    return base === name && basename(nm) === 'node_modules' ? dir : false;\n  }\n\n  toJSON() {\n    return printableTree(this);\n  }\n\n  [util.inspect.custom]() {\n    return this.toJSON();\n  }\n\n}\n\nmodule.exports = Node;","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/node_modules/@npmcli/arborist/lib/node.js"],"names":["nameFromFolder","require","Edge","Inventory","normalize","getPaths","getBinPaths","npa","debug","gatherDepSet","treeCheck","walkUp","resolve","relative","dirname","basename","util","_package","Symbol","_parent","_target","for","_fsParent","_loadDepType","_loadWorkspaces","_reloadNamedEdges","_loadDeps","_root","_refreshLocation","_changePath","_delistFromMeta","_global","_workspaces","_explain","_explanation","_meta","relpath","consistentResolve","printableTree","Node","constructor","options","root","path","realpath","parent","error","meta","fsParent","resolved","integrity","name","children","fsChildren","legacyPeerDeps","linksIn","hasShrinkwrap","extraneous","dev","optional","devOptional","peer","global","dummy","sourceReference","errors","pkg","package","TypeError","isLink","_resolved","test","_where","_integrity","_hasShrinkwrap","Map","Set","inventory","tops","edgesIn","edgesOut","c","add","globalTop","isProjectRoot","workspaces","keys","has","get","detach","binPaths","top","hasInstallScript","scripts","install","preinstall","postinstall","version","pkgid","myname","alias","edge","values","Error","forEach","reload","explain","seen","location","why","length","whileInstalling","includes","concat","dependents","push","edges","valid","from","isDescendantOf","node","p","getBundler","pBundler","ppkg","bd","bundleDependencies","Array","isArray","eBundler","inBundle","inDepBundle","bundler","isWorkspace","type","to","target","isRoot","link","delete","loc","current","ploc","Object","assign","parentReal","childLoc","isParent","oldChild","set","nmloc","isChild","n","isFsChild","startsWith","isKid","child","query","family","filter","l","entries","spec","optionalDependencies","isTop","srcTop","srcPath","devDependencies","pd","peerDependencies","pm","peerDependenciesMeta","peerOptional","dep","dependencies","obj","ad","acceptDependencies","accept","indexOf","oldFsParent","newPath","nmPath","pathChange","oldParent","oldName","canReplaceWith","depSet","e","satisfiedBy","canReplace","satisfies","requested","parsed","rawSpec","matches","replaceWith","replace","kid","inShrinkwrap","oldPath","namePattern","nameChange","match","addEdgeOut","addEdgeIn","addEdge","rootLoc","rootLocResolved","sameResolved","recheck","depth","resolveParent","mine","inNodeModules","rp","scoped","charAt","d","nm","dir","base","toJSON","inspect","custom","module","exports"],"mappings":"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","sourcesContent":["// inventory, path, realpath, root, and parent\n//\n// node.root is a reference to the root module in the tree (ie, typically the\n// cwd project folder)\n//\n// node.location is the /-delimited path from the root module to the node.  In\n// the case of link targets that may be outside of the root's package tree,\n// this can include some number of /../ path segments.  The location of the\n// root module is always '.'.  node.location thus never contains drive letters\n// or absolute paths, and is portable within a given project, suitable for\n// inclusion in lockfiles and metadata.\n//\n// node.path is the path to the place where this node lives on disk.  It is\n// system-specific and absolute.\n//\n// node.realpath is the path to where the module actually resides on disk.  In\n// the case of non-link nodes, node.realpath is equivalent to node.path.  In\n// the case of link nodes, it is equivalent to node.target.path.\n//\n// Setting node.parent will set the node's root to the parent's root, as well\n// as updating edgesIn and edgesOut to reload dependency resolutions as needed,\n// and setting node.path to parent.path/node_modules/name.\n//\n// node.inventory is a Map of name to a Set() of all the nodes under a given\n// root by that name.  It's empty for non-root nodes, and changing the root\n// reference will remove it from the old root's inventory and add it to the new\n// one.  This map is useful for cases like `npm update foo` or `npm ls foo`\n// where we need to quickly find all instances of a given package name within a\n// tree.\n\nconst nameFromFolder = require('@npmcli/name-from-folder')\nconst Edge = require('./edge.js')\nconst Inventory = require('./inventory.js')\nconst {normalize} = require('read-package-json-fast')\nconst {getPaths: getBinPaths} = require('bin-links')\nconst npa = require('npm-package-arg')\nconst debug = require('./debug.js')\nconst gatherDepSet = require('./gather-dep-set.js')\nconst treeCheck = require('./tree-check.js')\nconst walkUp = require('walk-up-path')\n\nconst {resolve, relative, dirname, basename} = require('path')\nconst util = require('util')\nconst _package = Symbol('_package')\nconst _parent = Symbol('_parent')\nconst _target = Symbol.for('_target')\nconst _fsParent = Symbol('_fsParent')\nconst _loadDepType = Symbol('_loadDepType')\nconst _loadWorkspaces = Symbol('_loadWorkspaces')\nconst _reloadNamedEdges = Symbol('_reloadNamedEdges')\n// overridden by Link class\nconst _loadDeps = Symbol.for('Arborist.Node._loadDeps')\nconst _root = Symbol('_root')\nconst _refreshLocation = Symbol.for('_refreshLocation')\nconst _changePath = Symbol.for('_changePath')\n// used by Link class as well\nconst _delistFromMeta = Symbol.for('_delistFromMeta')\nconst _global = Symbol.for('global')\nconst _workspaces = Symbol('_workspaces')\nconst _explain = Symbol('_explain')\nconst _explanation = Symbol('_explanation')\nconst _meta = Symbol('_meta')\n\nconst relpath = require('./relpath.js')\nconst consistentResolve = require('./consistent-resolve.js')\n\nconst printableTree = require('./printable.js')\n\nclass Node {\n  constructor (options) {\n    // NB: path can be null if it's a link target\n    const {\n      root,\n      path,\n      realpath,\n      parent,\n      error,\n      meta,\n      fsParent,\n      resolved,\n      integrity,\n      // allow setting name explicitly when we haven't set a path yet\n      name,\n      children,\n      fsChildren,\n      legacyPeerDeps = false,\n      linksIn,\n      hasShrinkwrap,\n      extraneous = true,\n      dev = true,\n      optional = true,\n      devOptional = true,\n      peer = true,\n      global = false,\n      dummy = false,\n      sourceReference = null,\n    } = options\n\n    // true if part of a global install\n    this[_global] = global\n\n    this[_workspaces] = null\n\n    this.errors = error ? [error] : []\n\n    // this will usually be null, except when modeling a\n    // package's dependencies in a virtual root.\n    this.sourceReference = sourceReference\n\n    const pkg = sourceReference ? sourceReference.package\n      : normalize(options.pkg || {})\n\n    this.name = name ||\n      nameFromFolder(path || pkg.name || realpath) ||\n      pkg.name ||\n      null\n\n    // should be equal if not a link\n    this.path = path ? resolve(path) : null\n\n    if (!this.name && (!this.path || this.path !== dirname(this.path)))\n      throw new TypeError('could not detect node name from path or package')\n\n    this.realpath = !this.isLink ? this.path : resolve(realpath)\n\n    this.resolved = resolved || null\n    if (!this.resolved) {\n      // note: this *only* works for non-file: deps, so we avoid even\n      // trying here.\n      // file: deps are tracked in package.json will _resolved set to the\n      // full path to the tarball or link target.  However, if the package\n      // is checked into git or moved to another location, that's 100% not\n      // portable at all!  The _where and _location don't provide much help,\n      // since _location is just where the module ended up in the tree,\n      // and _where can be different than the actual root if it's a\n      // meta-dep deeper in the dependency graph.\n      //\n      // If we don't have the other oldest indicators of legacy npm, then it's\n      // probably what we're getting from pacote, which IS trustworthy.\n      //\n      // Otherwise, hopefully a shrinkwrap will help us out.\n      const resolved = consistentResolve(pkg._resolved)\n      if (resolved && !(/^file:/.test(resolved) && pkg._where))\n        this.resolved = resolved\n    }\n    this.integrity = integrity || pkg._integrity || null\n    this.hasShrinkwrap = hasShrinkwrap || pkg._hasShrinkwrap || false\n    this.legacyPeerDeps = legacyPeerDeps\n\n    this.children = new Map()\n    this.fsChildren = new Set()\n    this.inventory = new Inventory({})\n    this.tops = new Set()\n    this.linksIn = new Set(linksIn || [])\n\n    // these three are set by an Arborist taking a catalog\n    // after the tree is built.  We don't get this along the way,\n    // because they have a tendency to change as new children are\n    // added, especially when they're deduped.  Eg, a dev dep may be\n    // a 3-levels-deep dependency of a non-dev dep.  If we calc the\n    // flags along the way, then they'll tend to be invalid  by the\n    // time we need to look at them.\n    if (!dummy) {\n      this.dev = dev\n      this.optional = optional\n      this.devOptional = devOptional\n      this.peer = peer\n      this.extraneous = extraneous\n      this.dummy = false\n    } else {\n      // true if this is a placeholder for the purpose of serving as a\n      // fsParent to link targets that get their deps resolved outside\n      // the root tree folder.\n      this.dummy = true\n      this.dev = false\n      this.optional = false\n      this.devOptional = false\n      this.peer = false\n      this.extraneous = false\n    }\n\n    this.edgesIn = new Set()\n    this.edgesOut = new Map()\n\n    // have to set the internal package ref before assigning the parent,\n    // because this.package is read when adding to inventory\n    this[_package] = pkg && typeof pkg === 'object' ? pkg : {}\n\n    // only relevant for the root and top nodes\n    this.meta = meta\n\n    // Note: this is _slightly_ less efficient for the initial tree\n    // building than it could be, but in exchange, it's a much simpler\n    // algorithm.\n    // If this node has a bunch of children, and those children satisfy\n    // its various deps, then we're going to _first_ create all the\n    // edges, and _then_ assign the children into place, re-resolving\n    // them all in _reloadNamedEdges.\n    // A more efficient, but more complicated, approach would be to\n    // flag this node as being a part of a tree build, so it could\n    // hold off on resolving its deps until its children are in place.\n\n    // call the parent setter\n    // Must be set prior to calling _loadDeps, because top-ness is relevant\n\n    // will also assign root if present on the parent\n    this[_parent] = null\n    this.parent = parent || null\n\n    this[_fsParent] = null\n    this.fsParent = fsParent || null\n\n    // see parent/root setters below.\n    // root is set to parent's root if we have a parent, otherwise if it's\n    // null, then it's set to the node itself.\n    if (!parent && !fsParent)\n      this.root = root || null\n\n    // mostly a convenience for testing, but also a way to create\n    // trees in a more declarative way than setting parent on each\n    if (children) {\n      for (const c of children)\n        new Node({ ...c, parent: this })\n    }\n    if (fsChildren) {\n      for (const c of fsChildren)\n        new Node({ ...c, fsParent: this })\n    }\n\n    // now load all the dep edges\n    this[_loadDeps]()\n  }\n\n  get meta () {\n    return this[_meta]\n  }\n\n  set meta (meta) {\n    this[_meta] = meta\n    if (meta)\n      meta.add(this)\n  }\n\n  get global () {\n    return this.root[_global]\n  }\n\n  // true for packages installed directly in the global node_modules folder\n  get globalTop () {\n    return this.global && this.parent.isProjectRoot\n  }\n\n  get workspaces () {\n    return this[_workspaces]\n  }\n\n  set workspaces (workspaces) {\n    // deletes edges if they already exists\n    if (this[_workspaces]) {\n      for (const name of this[_workspaces].keys()) {\n        if (!workspaces.has(name))\n          this.edgesOut.get(name).detach()\n      }\n    }\n\n    this[_workspaces] = workspaces\n    this[_loadWorkspaces]()\n    this[_loadDeps]()\n  }\n\n  get binPaths () {\n    if (!this.parent)\n      return []\n\n    return getBinPaths({\n      pkg: this[_package],\n      path: this.path,\n      global: this.global,\n      top: this.globalTop,\n    })\n  }\n\n  get hasInstallScript () {\n    const {hasInstallScript, scripts} = this.package\n    const {install, preinstall, postinstall} = scripts || {}\n    return !!(hasInstallScript || install || preinstall || postinstall)\n  }\n\n  get version () {\n    return this[_package].version || ''\n  }\n\n  get pkgid () {\n    const { name = '', version = '' } = this.package\n    // root package will prefer package name over folder name,\n    // and never be called an alias.\n    const { isProjectRoot } = this\n    const myname = isProjectRoot ? name || this.name\n      : this.name\n    const alias = !isProjectRoot && name && myname !== name ? `npm:${name}@`\n      : ''\n    return `${myname}@${alias}${version}`\n  }\n\n  get package () {\n    return this[_package]\n  }\n\n  set package (pkg) {\n    // just detach them all.  we could make this _slightly_ more efficient\n    // by only detaching the ones that changed, but we'd still have to walk\n    // them all, and the comparison logic gets a bit tricky.  we generally\n    // only do this more than once at the root level, so the resolve() calls\n    // are only one level deep, and there's not much to be saved, anyway.\n    // simpler to just toss them all out.\n    for (const edge of this.edgesOut.values())\n      edge.detach()\n\n    this[_explanation] = null\n    /* istanbul ignore next - should be impossible */\n    if (!pkg || typeof pkg !== 'object') {\n      debug(() => {\n        throw new Error('setting Node.package to non-object')\n      })\n      pkg = {}\n    }\n    this[_package] = pkg\n    this[_loadWorkspaces]()\n    this[_loadDeps]()\n    // do a hard reload, since the dependents may now be valid or invalid\n    // as a result of the package change.\n    this.edgesIn.forEach(edge => edge.reload(true))\n  }\n\n  // node.explain(nodes seen already, edge we're trying to satisfy\n  // if edge is not specified, it lists every edge into the node.\n  explain (edge = null, seen = []) {\n    if (this[_explanation])\n      return this[_explanation]\n\n    return this[_explanation] = this[_explain](edge, seen)\n  }\n\n  [_explain] (edge, seen) {\n    if (this.isProjectRoot && !this.sourceReference) {\n      return {\n        location: this.path,\n      }\n    }\n\n    const why = {\n      name: this.isProjectRoot ? this.package.name : this.name,\n      version: this.package.version,\n    }\n    if (this.errors.length || !this.package.name || !this.package.version) {\n      why.errors = this.errors.length ? this.errors : [\n        new Error('invalid package: lacks name and/or version'),\n      ]\n      why.package = this.package\n    }\n\n    if (this.root.sourceReference) {\n      const {name, version} = this.root.package\n      why.whileInstalling = {\n        name,\n        version,\n        path: this.root.sourceReference.path,\n      }\n    }\n\n    if (this.sourceReference)\n      return this.sourceReference.explain(edge, seen)\n\n    if (seen.includes(this))\n      return why\n\n    why.location = this.location\n\n    // make a new list each time.  we can revisit, but not loop.\n    seen = seen.concat(this)\n\n    why.dependents = []\n    if (edge)\n      why.dependents.push(edge.explain(seen))\n    else {\n      // ignore invalid edges, since those aren't satisfied by this thing,\n      // and are not keeping it held in this spot anyway.\n      const edges = []\n      for (const edge of this.edgesIn) {\n        if (!edge.valid && !edge.from.isProjectRoot)\n          continue\n\n        edges.push(edge)\n      }\n      for (const edge of edges)\n        why.dependents.push(edge.explain(seen))\n    }\n    return why\n  }\n\n  isDescendantOf (node) {\n    for (let p = this; p; p = p.parent) {\n      if (p === node)\n        return true\n    }\n    return false\n  }\n\n  getBundler (path = []) {\n    // made a cycle, definitely not bundled!\n    if (path.includes(this))\n      return null\n\n    path.push(this)\n\n    const parent = this[_parent]\n    if (!parent)\n      return null\n\n    const pBundler = parent.getBundler(path)\n    if (pBundler)\n      return pBundler\n\n    const ppkg = parent.package\n    const bd = ppkg && ppkg.bundleDependencies\n    // explicit bundling\n    if (Array.isArray(bd) && bd.includes(this.name))\n      return parent\n\n    // deps that are deduped up to the bundling level are bundled.\n    // however, if they get their dep met further up than that,\n    // then they are not bundled.  Ie, installing a package with\n    // unmet bundled deps will not cause your deps to be bundled.\n    for (const edge of this.edgesIn) {\n      const eBundler = edge.from.getBundler(path)\n      if (!eBundler)\n        continue\n\n      if (eBundler === parent)\n        return eBundler\n    }\n\n    return null\n  }\n\n  get inBundle () {\n    return !!this.getBundler()\n  }\n\n  // when reifying, if a package is technically in a bundleDependencies list,\n  // but that list is the root project, we still have to install it.  This\n  // getter returns true if it's in a dependency's bundle list, not the root's.\n  get inDepBundle () {\n    const bundler = this.getBundler()\n    return !!bundler && bundler !== this.root\n  }\n\n  get isWorkspace () {\n    if (this.isProjectRoot)\n      return false\n    const { root } = this\n    const { type, to } = root.edgesOut.get(this.package.name) || {}\n    return type === 'workspace' && to && (to.target === this || to === this)\n  }\n\n  get isRoot () {\n    return this === this.root\n  }\n\n  get isProjectRoot () {\n    return this === this.root || this === this.root.target\n  }\n\n  set root (root) {\n    // setting to null means this is the new root\n    // should only ever be one step\n    while (root && root.root !== root)\n      root = root.root\n\n    root = root || this\n\n    // delete from current root inventory\n    this[_delistFromMeta]()\n\n    // can't set the root (yet) if there's no way to determine location\n    // this allows us to do new Node({...}) and then set the root later.\n    // just make the assignment so we don't lose it, and move on.\n    if (!this.path || !root.realpath || !root.path)\n      return this[_root] = root\n\n    // temporarily become a root node\n    this[_root] = this\n\n    // break all linksIn, we're going to re-set them if needed later\n    for (const link of this.linksIn) {\n      link[_target] = null\n      this.linksIn.delete(link)\n    }\n\n    // temporarily break this link as well, we'll re-set if possible later\n    const { target } = this\n    if (this.isLink) {\n      if (target) {\n        target.linksIn.delete(this)\n        if (target.root === this)\n          target[_delistFromMeta]()\n      }\n      this[_target] = null\n    }\n\n    // if this is part of a cascading root set, then don't do this bit\n    // but if the parent/fsParent is in a different set, we have to break\n    // that reference before proceeding\n    if (this.parent && this.parent.root !== root) {\n      this.parent.children.delete(this.name)\n      this[_parent] = null\n    }\n    if (this.fsParent && this.fsParent.root !== root) {\n      this.fsParent.fsChildren.delete(this)\n      this[_fsParent] = null\n    }\n\n    if (root === this)\n      this[_refreshLocation]()\n    else {\n      // setting to some different node.\n      const loc = relpath(root.realpath, this.path)\n      const current = root.inventory.get(loc)\n\n      // clobber whatever is there now\n      if (current)\n        current.root = null\n\n      this[_root] = root\n      // set this.location and add to inventory\n      this[_refreshLocation]()\n\n      // try to find our parent/fsParent in the new root inventory\n      for (const p of walkUp(dirname(this.path))) {\n        const ploc = relpath(root.realpath, p)\n        const parent = root.inventory.get(ploc)\n        if (parent) {\n          /* istanbul ignore next - impossible */\n          if (parent.isLink) {\n            debug(() => {\n              throw Object.assign(new Error('assigning parentage to link'), {\n                path: this.path,\n                parent: parent.path,\n                parentReal: parent.realpath,\n              })\n            })\n            continue\n          }\n          const childLoc = `${ploc}${ploc ? '/' : ''}node_modules/${this.name}`\n          const isParent = this.location === childLoc\n          if (isParent) {\n            const oldChild = parent.children.get(this.name)\n            if (oldChild && oldChild !== this)\n              oldChild.root = null\n            if (this.parent) {\n              this.parent.children.delete(this.name)\n              this.parent[_reloadNamedEdges](this.name)\n            }\n            parent.children.set(this.name, this)\n            this[_parent] = parent\n            // don't do it for links, because they don't have a target yet\n            // we'll hit them up a bit later on.\n            if (!this.isLink)\n              parent[_reloadNamedEdges](this.name)\n          } else {\n            /* istanbul ignore if - should be impossible, since we break\n             * all fsParent/child relationships when moving? */\n            if (this.fsParent)\n              this.fsParent.fsChildren.delete(this)\n            parent.fsChildren.add(this)\n            this[_fsParent] = parent\n          }\n          break\n        }\n      }\n\n      // if it doesn't have a parent, it's a top node\n      if (!this.parent)\n        root.tops.add(this)\n      else\n        root.tops.delete(this)\n\n      // assign parentage for any nodes that need to have this as a parent\n      // this can happen when we have a node at nm/a/nm/b added *before*\n      // the node at nm/a, which might have the root node as a fsParent.\n      // we can't rely on the public setter here, because it calls into\n      // this function to set up these references!\n      const nmloc = `${this.location}${this.location ? '/' : ''}node_modules/`\n      const isChild = n => n.location === nmloc + n.name\n      // check dirname so that /foo isn't treated as the fsparent of /foo-bar\n      const isFsChild = n => dirname(n.path).startsWith(this.path) &&\n        n !== this &&\n        !n.parent &&\n        (!n.fsParent || n.fsParent === this || dirname(this.path).startsWith(n.fsParent.path))\n      const isKid = n => isChild(n) || isFsChild(n)\n\n      // only walk top nodes, since anything else already has a parent.\n      for (const child of root.tops) {\n        if (!isKid(child))\n          continue\n\n        // set up the internal parentage links\n        if (this.isLink)\n          child.root = null\n        else {\n          // can't possibly have a parent, because it's in tops\n          if (child.fsParent)\n            child.fsParent.fsChildren.delete(child)\n          child[_fsParent] = null\n          if (isChild(child)) {\n            this.children.set(child.name, child)\n            child[_parent] = this\n            root.tops.delete(child)\n          } else {\n            this.fsChildren.add(child)\n            child[_fsParent] = this\n          }\n        }\n      }\n\n      // look for any nodes with the same realpath.  either they're links\n      // to that realpath, or a thing at that realpath if we're adding a link\n      // (if we're adding a regular node, we already deleted the old one)\n      for (const node of root.inventory.query('realpath', this.realpath)) {\n        if (node === this)\n          continue\n\n        /* istanbul ignore next - should be impossible */\n        debug(() => {\n          if (node.root !== root)\n            throw new Error('inventory contains node from other root')\n        })\n\n        if (this.isLink) {\n          const target = node.target || node\n          this[_target] = target\n          this[_package] = target.package\n          target.linksIn.add(this)\n          // reload edges here, because now we have a target\n          if (this.parent)\n            this.parent[_reloadNamedEdges](this.name)\n          break\n        } else {\n          /* istanbul ignore else - should be impossible */\n          if (node.isLink) {\n            node[_target] = this\n            node[_package] = this.package\n            this.linksIn.add(node)\n            if (node.parent)\n              node.parent[_reloadNamedEdges](node.name)\n          } else {\n            debug(() => {\n              throw Object.assign(new Error('duplicate node in root setter'), {\n                path: this.path,\n                realpath: this.realpath,\n                root: root.realpath,\n              })\n            })\n          }\n        }\n      }\n    }\n\n    // reload all edgesIn where the root doesn't match, so we don't have\n    // cross-tree dependency graphs\n    for (const edge of this.edgesIn) {\n      if (edge.from.root !== root)\n        edge.reload()\n    }\n    // reload all edgesOut where root doens't match, or is missing, since\n    // it might not be missing in the new tree\n    for (const edge of this.edgesOut.values()) {\n      if (!edge.to || edge.to.root !== root)\n        edge.reload()\n    }\n\n    // now make sure our family comes along for the ride!\n    const family = new Set([\n      ...this.fsChildren,\n      ...this.children.values(),\n      ...this.inventory.values(),\n    ].filter(n => n !== this))\n\n    for (const child of family) {\n      if (child.root !== root) {\n        child[_delistFromMeta]()\n        child[_parent] = null\n        this.children.delete(child.name)\n        child[_fsParent] = null\n        this.fsChildren.delete(child)\n        for (const l of child.linksIn) {\n          l[_target] = null\n          child.linksIn.delete(l)\n        }\n      }\n    }\n    for (const child of family) {\n      if (child.root !== root)\n        child.root = root\n    }\n\n    // if we had a target, and didn't find one in the new root, then bring\n    // it over as well, but only if we're setting the link into a new root,\n    // as we don't want to lose the target any time we remove a link.\n    if (this.isLink && target && !this.target && root !== this)\n      target.root = root\n\n    // tree should always be valid upon root setter completion.\n    treeCheck(this)\n    treeCheck(root)\n  }\n\n  get root () {\n    return this[_root] || this\n  }\n\n  [_loadWorkspaces] () {\n    if (!this[_workspaces])\n      return\n\n    for (const [name, path] of this[_workspaces].entries())\n      new Edge({ from: this, name, spec: `file:${path}`, type: 'workspace' })\n  }\n\n  [_loadDeps] () {\n    // Caveat!  Order is relevant!\n    // packages in optionalDependencies and prod/peer/dev are\n    // optional.  Packages in both deps and devDeps are required.\n    // Note the subtle breaking change from v6: it is no longer possible\n    // to have a different spec for a devDep than production dep.\n    this[_loadDepType](this.package.optionalDependencies, 'optional')\n\n    // Linked targets that are disconnected from the tree are tops,\n    // but don't have a 'path' field, only a 'realpath', because we\n    // don't know their canonical location. We don't need their devDeps.\n    const { isTop, path, sourceReference } = this\n    const { isTop: srcTop, path: srcPath } = sourceReference || {}\n    if (isTop && path && (!sourceReference || srcTop && srcPath))\n      this[_loadDepType](this.package.devDependencies, 'dev')\n\n    const pd = this.package.peerDependencies\n    if (pd && typeof pd === 'object' && !this.legacyPeerDeps) {\n      const pm = this.package.peerDependenciesMeta || {}\n      const peerDependencies = {}\n      const peerOptional = {}\n      for (const [name, dep] of Object.entries(pd)) {\n        if (pm[name] && pm[name].optional)\n          peerOptional[name] = dep\n        else\n          peerDependencies[name] = dep\n      }\n      this[_loadDepType](peerDependencies, 'peer')\n      this[_loadDepType](peerOptional, 'peerOptional')\n    }\n\n    this[_loadDepType](this.package.dependencies, 'prod')\n  }\n\n  [_loadDepType] (obj, type) {\n    const from = this\n    const ad = this.package.acceptDependencies || {}\n    for (const [name, spec] of Object.entries(obj || {})) {\n      const accept = ad[name]\n      // if it's already set, then we keep the existing edge\n      // Prod deps should not be marked as dev, however.\n      // NB: the Edge ctor adds itself to from.edgesOut\n      const current = this.edgesOut.get(name)\n      if (!current || current.dev && type === 'prod')\n        new Edge({ from, name, spec, accept, type })\n    }\n  }\n\n  get fsParent () {\n    return this[_fsParent]\n  }\n\n  set fsParent (fsParent) {\n    if (!fsParent) {\n      if (this[_fsParent])\n        this.root = null\n      return\n    }\n\n    debug(() => {\n      if (fsParent === this)\n        throw new Error('setting node to its own fsParent')\n\n      if (fsParent.realpath === this.realpath)\n        throw new Error('setting fsParent to same path')\n\n      // the initial set MUST be an actual walk-up from the realpath\n      // subsequent sets will re-root on the new fsParent's path.\n      if (!this[_fsParent] && this.realpath.indexOf(fsParent.realpath) !== 0) {\n        throw Object.assign(new Error('setting fsParent improperly'), {\n          path: this.path,\n          realpath: this.realpath,\n          fsParent: {\n            path: fsParent.path,\n            realpath: fsParent.realpath,\n          },\n        })\n      }\n    })\n\n    if (fsParent.isLink)\n      fsParent = fsParent.target\n\n    // setting a thing to its own fsParent is not normal, but no-op for safety\n    if (this === fsParent || fsParent.realpath === this.realpath)\n      return\n\n    // nothing to do\n    if (this[_fsParent] === fsParent)\n      return\n\n    const oldFsParent = this[_fsParent]\n    const newPath = !oldFsParent ? this.path\n      : resolve(fsParent.path, relative(oldFsParent.path, this.path))\n    const nmPath = resolve(fsParent.path, 'node_modules', this.name)\n\n    // this is actually the parent, set that instead\n    if (newPath === nmPath) {\n      this.parent = fsParent\n      return\n    }\n\n    const pathChange = newPath !== this.path\n\n    // remove from old parent/fsParent\n    const oldParent = this.parent\n    const oldName = this.name\n    if (this.parent) {\n      this.parent.children.delete(this.name)\n      this[_parent] = null\n    }\n    if (this.fsParent) {\n      this.fsParent.fsChildren.delete(this)\n      this[_fsParent] = null\n    }\n\n    // update this.path/realpath for this and all children/fsChildren\n    if (pathChange)\n      this[_changePath](newPath)\n\n    if (oldParent)\n      oldParent[_reloadNamedEdges](oldName)\n\n    // clobbers anything at that path, resets all appropriate references\n    this.root = fsParent.root\n  }\n\n  // is it safe to replace one node with another?  check the edges to\n  // make sure no one will get upset.  Note that the node might end up\n  // having its own unmet dependencies, if the new node has new deps.\n  // Note that there are cases where Arborist will opt to insert a node\n  // into the tree even though this function returns false!  This is\n  // necessary when a root dependency is added or updated, or when a\n  // root dependency brings peer deps along with it.  In that case, we\n  // will go ahead and create the invalid state, and then try to resolve\n  // it with more tree construction, because it's a user request.\n  canReplaceWith (node) {\n    if (node.name !== this.name)\n      return false\n\n    // gather up all the deps of this node and that are only depended\n    // upon by deps of this node.  those ones don't count, since\n    // they'll be replaced if this node is replaced anyway.\n    const depSet = gatherDepSet([this], e => e.to !== this && e.valid)\n\n    for (const edge of this.edgesIn) {\n      // only care about edges that don't originate from this node\n      if (!depSet.has(edge.from) && !edge.satisfiedBy(node))\n        return false\n    }\n\n    return true\n  }\n\n  canReplace (node) {\n    return node.canReplaceWith(this)\n  }\n\n  satisfies (requested) {\n    if (requested instanceof Edge)\n      return this.name === requested.name && requested.satisfiedBy(this)\n\n    const parsed = npa(requested)\n    const { name = this.name, rawSpec: spec } = parsed\n    return this.name === name && this.satisfies(new Edge({\n      from: new Node({ path: this.root.realpath }),\n      type: 'prod',\n      name,\n      spec,\n    }))\n  }\n\n  matches (node) {\n    // if the nodes are literally the same object, obviously a match.\n    if (node === this)\n      return true\n\n    // if the names don't match, they're different things, even if\n    // the package contents are identical.\n    if (node.name !== this.name)\n      return false\n\n    // if they're links, they match if the targets match\n    if (this.isLink)\n      return node.isLink && this.target.matches(node.target)\n\n    // if they're two project root nodes, they're different if the paths differ\n    if (this.isProjectRoot && node.isProjectRoot)\n      return this.path === node.path\n\n    // if the integrity matches, then they're the same.\n    if (this.integrity && node.integrity)\n      return this.integrity === node.integrity\n\n    // if no integrity, check resolved\n    if (this.resolved && node.resolved)\n      return this.resolved === node.resolved\n\n    // if no resolved, check both package name and version\n    // otherwise, conclude that they are different things\n    return this.package.name && node.package.name &&\n      this.package.name === node.package.name &&\n      this.version && node.version &&\n      this.version === node.version\n  }\n\n  // replace this node with the supplied argument\n  // Useful when mutating an ideal tree, so we can avoid having to call\n  // the parent/root setters more than necessary.\n  replaceWith (node) {\n    node.replace(this)\n  }\n\n  replace (node) {\n    this[_delistFromMeta]()\n    this.path = node.path\n    this.name = node.name\n    if (!this.isLink)\n      this.realpath = this.path\n    this[_refreshLocation]()\n\n    // keep children when a node replaces another\n    if (!this.isLink) {\n      for (const kid of node.children.values())\n        kid.parent = this\n    }\n\n    if (!node.isRoot)\n      this.root = node.root\n\n    treeCheck(this)\n  }\n\n  get inShrinkwrap () {\n    return this.parent && (this.parent.hasShrinkwrap || this.parent.inShrinkwrap)\n  }\n\n  get parent () {\n    return this[_parent]\n  }\n\n  // This setter keeps everything in order when we move a node from\n  // one point in a logical tree to another.  Edges get reloaded,\n  // metadata updated, etc.  It's also called when we *replace* a node\n  // with another by the same name (eg, to update or dedupe).\n  // This does a couple of walks out on the node_modules tree, recursing\n  // into child nodes.  However, as setting the parent is typically done\n  // with nodes that don't have have many children, and (deduped) package\n  // trees tend to be broad rather than deep, it's not that bad.\n  // The only walk that starts from the parent rather than this node is\n  // limited by edge name.\n  set parent (parent) {\n    // when setting to null, just remove it from the tree entirely\n    if (!parent) {\n      // but only delete it if we actually had a parent in the first place\n      // otherwise it's just setting to null when it's already null\n      if (this[_parent])\n        this.root = null\n      return\n    }\n\n    if (parent.isLink)\n      parent = parent.target\n\n    // setting a thing to its own parent is not normal, but no-op for safety\n    if (this === parent)\n      return\n\n    const oldParent = this[_parent]\n\n    // nothing to do\n    if (oldParent === parent)\n      return\n\n    // ok now we know something is actually changing, and parent is not a link\n    const newPath = resolve(parent.path, 'node_modules', this.name)\n    const pathChange = newPath !== this.path\n\n    // remove from old parent/fsParent\n    if (oldParent) {\n      oldParent.children.delete(this.name)\n      this[_parent] = null\n    }\n    if (this.fsParent) {\n      this.fsParent.fsChildren.delete(this)\n      this[_fsParent] = null\n    }\n\n    // update this.path/realpath for this and all children/fsChildren\n    if (pathChange)\n      this[_changePath](newPath)\n\n    // clobbers anything at that path, resets all appropriate references\n    this.root = parent.root\n  }\n\n  // Call this before changing path or updating the _root reference.\n  // Removes the node from its root the metadata and inventory.\n  [_delistFromMeta] () {\n    const root = this.root\n    if (!root.realpath || !this.path)\n      return\n    root.inventory.delete(this)\n    root.tops.delete(this)\n    if (root.meta)\n      root.meta.delete(this.path)\n    /* istanbul ignore next - should be impossible */\n    debug(() => {\n      if ([...root.inventory.values()].includes(this))\n        throw new Error('failed to delist')\n    })\n  }\n\n  // update this.path/realpath and the paths of all children/fsChildren\n  [_changePath] (newPath) {\n    // have to de-list before changing paths\n    this[_delistFromMeta]()\n    const oldPath = this.path\n    this.path = newPath\n    const namePattern = /(?:^|\\/|\\\\)node_modules[\\\\/](@[^/\\\\]+[\\\\/][^\\\\/]+|[^\\\\/]+)$/\n    const nameChange = newPath.match(namePattern)\n    if (nameChange && this.name !== nameChange[1])\n      this.name = nameChange[1].replace(/\\\\/g, '/')\n\n    // if we move a link target, update link realpaths\n    if (!this.isLink) {\n      this.realpath = newPath\n      for (const link of this.linksIn) {\n        link[_delistFromMeta]()\n        link.realpath = newPath\n        link[_refreshLocation]()\n      }\n    }\n    // if we move /x to /y, then a module at /x/a/b becomes /y/a/b\n    for (const child of this.fsChildren)\n      child[_changePath](resolve(newPath, relative(oldPath, child.path)))\n    for (const [name, child] of this.children.entries())\n      child[_changePath](resolve(newPath, 'node_modules', name))\n\n    this[_refreshLocation]()\n  }\n\n  // Called whenever the root/parent is changed.\n  // NB: need to remove from former root's meta/inventory and then update\n  // this.path BEFORE calling this method!\n  [_refreshLocation] () {\n    const root = this.root\n    const loc = relpath(root.realpath, this.path)\n\n    this.location = loc\n\n    root.inventory.add(this)\n    if (root.meta)\n      root.meta.add(this)\n  }\n\n  addEdgeOut (edge) {\n    this.edgesOut.set(edge.name, edge)\n  }\n\n  addEdgeIn (edge) {\n    this.edgesIn.add(edge)\n\n    // try to get metadata from the yarn.lock file\n    if (this.root.meta)\n      this.root.meta.addEdge(edge)\n  }\n\n  [_reloadNamedEdges] (name, rootLoc = this.location) {\n    const edge = this.edgesOut.get(name)\n    // if we don't have an edge, do nothing, but keep descending\n    const rootLocResolved = edge && edge.to &&\n      edge.to.location === `${rootLoc}/node_modules/${edge.name}`\n    const sameResolved = edge && this.resolve(name) === edge.to\n    const recheck = rootLocResolved || !sameResolved\n    if (edge && recheck)\n      edge.reload(true)\n    for (const c of this.children.values())\n      c[_reloadNamedEdges](name, rootLoc)\n\n    for (const c of this.fsChildren)\n      c[_reloadNamedEdges](name, rootLoc)\n  }\n\n  get isLink () {\n    return false\n  }\n\n  get target () {\n    return null\n  }\n\n  set target (n) {\n    debug(() => {\n      throw Object.assign(new Error('cannot set target on non-Link Nodes'), {\n        path: this.path,\n      })\n    })\n  }\n\n  get depth () {\n    return this.isTop ? 0 : this.parent.depth + 1\n  }\n\n  get isTop () {\n    return !this.parent\n  }\n\n  get top () {\n    return this.isTop ? this : this.parent.top\n  }\n\n  get resolveParent () {\n    return this.parent || this.fsParent\n  }\n\n  resolve (name) {\n    const mine = this.children.get(name)\n    if (mine)\n      return mine\n    const resolveParent = this.resolveParent\n    if (resolveParent)\n      return resolveParent.resolve(name)\n    return null\n  }\n\n  inNodeModules () {\n    const rp = this.realpath\n    const name = this.name\n    const scoped = name.charAt(0) === '@'\n    const d = dirname(rp)\n    const nm = scoped ? dirname(d) : d\n    const dir = dirname(nm)\n    const base = scoped ? `${basename(d)}/${basename(rp)}` : basename(rp)\n    return base === name && basename(nm) === 'node_modules' ? dir : false\n  }\n\n  toJSON () {\n    return printableTree(this)\n  }\n\n  [util.inspect.custom] () {\n    return this.toJSON()\n  }\n}\n\nmodule.exports = Node\n"]},"metadata":{},"sourceType":"script"}
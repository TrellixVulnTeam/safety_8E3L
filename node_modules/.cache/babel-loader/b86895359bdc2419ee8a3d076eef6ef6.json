{"ast":null,"code":"const {\n  depth\n} = require('treeverse');\n\nconst calcDepFlags = (tree, resetRoot = true) => {\n  if (resetRoot) {\n    tree.dev = false;\n    tree.optional = false;\n    tree.devOptional = false;\n    tree.peer = false;\n  }\n\n  const ret = depth({\n    tree,\n    visit: node => calcDepFlagsStep(node),\n    filter: node => node,\n    getChildren: (node, tree) => [...tree.edgesOut.values()].map(edge => edge.to)\n  });\n  return ret;\n};\n\nconst calcDepFlagsStep = node => {\n  // This rewalk is necessary to handle cases where devDep and optional\n  // or normal dependency graphs overlap deep in the dep graph.\n  // Since we're only walking through deps that are not already flagged\n  // as non-dev/non-optional, it's typically a very shallow traversal\n  node.extraneous = false; // for links, map their hierarchy appropriately\n\n  if (node.target) {\n    node.target.dev = node.dev;\n    node.target.optional = node.optional;\n    node.target.devOptional = node.devOptional;\n    node.target.peer = node.peer;\n    node.target.extraneous = false;\n    node = node.target;\n  }\n\n  node.edgesOut.forEach(({\n    peer,\n    optional,\n    dev,\n    to\n  }) => {\n    // if the dep is missing, then its flags are already maximally unset\n    if (!to) return; // everything with any kind of edge into it is not extraneous\n\n    to.extraneous = false; // devOptional is the *overlap* of the dev and optional tree.\n    // however, for convenience and to save an extra rewalk, we leave\n    // it set when we are in *either* tree, and then omit it from the\n    // package-lock if either dev or optional are set.\n\n    const unsetDevOpt = !node.devOptional && !node.dev && !node.optional && !dev && !optional; // if we are not in the devOpt tree, then we're also not in\n    // either the dev or opt trees\n\n    const unsetDev = unsetDevOpt || !node.dev && !dev;\n    const unsetOpt = unsetDevOpt || !node.optional && !optional;\n    const unsetPeer = !node.peer && !peer;\n    if (unsetPeer) unsetFlag(to, 'peer');\n    if (unsetDevOpt) unsetFlag(to, 'devOptional');\n    if (unsetDev) unsetFlag(to, 'dev');\n    if (unsetOpt) unsetFlag(to, 'optional');\n  });\n  return node;\n}; // typically a short walk, since it only traverses deps that\n// have the flag set.\n\n\nconst unsetFlag = (node, flag) => {\n  if (node[flag]) {\n    node[flag] = false;\n    depth({\n      tree: node,\n      visit: node => {\n        node.extraneous = node[flag] = false;\n        if (node.target) node.target.extraneous = node.target[flag] = false;\n      },\n      getChildren: node => [...(node.target || node).edgesOut.values()].filter(edge => edge.to && edge.to[flag] && (flag !== 'peer' && edge.type === 'peer' || edge.type === 'prod')).map(edge => edge.to)\n    });\n  }\n};\n\nmodule.exports = calcDepFlags;","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/node_modules/@npmcli/arborist/lib/calc-dep-flags.js"],"names":["depth","require","calcDepFlags","tree","resetRoot","dev","optional","devOptional","peer","ret","visit","node","calcDepFlagsStep","filter","getChildren","edgesOut","values","map","edge","to","extraneous","target","forEach","unsetDevOpt","unsetDev","unsetOpt","unsetPeer","unsetFlag","flag","type","module","exports"],"mappings":"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","sourcesContent":["const { depth } = require('treeverse')\n\nconst calcDepFlags = (tree, resetRoot = true) => {\n  if (resetRoot) {\n    tree.dev = false\n    tree.optional = false\n    tree.devOptional = false\n    tree.peer = false\n  }\n  const ret = depth({\n    tree,\n    visit: node => calcDepFlagsStep(node),\n    filter: node => node,\n    getChildren: (node, tree) => [...tree.edgesOut.values()].map(edge => edge.to),\n  })\n  return ret\n}\n\nconst calcDepFlagsStep = (node) => {\n  // This rewalk is necessary to handle cases where devDep and optional\n  // or normal dependency graphs overlap deep in the dep graph.\n  // Since we're only walking through deps that are not already flagged\n  // as non-dev/non-optional, it's typically a very shallow traversal\n  node.extraneous = false\n\n  // for links, map their hierarchy appropriately\n  if (node.target) {\n    node.target.dev = node.dev\n    node.target.optional = node.optional\n    node.target.devOptional = node.devOptional\n    node.target.peer = node.peer\n    node.target.extraneous = false\n    node = node.target\n  }\n\n  node.edgesOut.forEach(({peer, optional, dev, to}) => {\n    // if the dep is missing, then its flags are already maximally unset\n    if (!to)\n      return\n\n    // everything with any kind of edge into it is not extraneous\n    to.extraneous = false\n\n    // devOptional is the *overlap* of the dev and optional tree.\n    // however, for convenience and to save an extra rewalk, we leave\n    // it set when we are in *either* tree, and then omit it from the\n    // package-lock if either dev or optional are set.\n    const unsetDevOpt = !node.devOptional && !node.dev && !node.optional &&\n      !dev && !optional\n\n    // if we are not in the devOpt tree, then we're also not in\n    // either the dev or opt trees\n    const unsetDev = unsetDevOpt || !node.dev && !dev\n    const unsetOpt = unsetDevOpt ||\n      !node.optional && !optional\n    const unsetPeer = !node.peer && !peer\n\n    if (unsetPeer)\n      unsetFlag(to, 'peer')\n\n    if (unsetDevOpt)\n      unsetFlag(to, 'devOptional')\n\n    if (unsetDev)\n      unsetFlag(to, 'dev')\n\n    if (unsetOpt)\n      unsetFlag(to, 'optional')\n  })\n\n  return node\n}\n\n// typically a short walk, since it only traverses deps that\n// have the flag set.\nconst unsetFlag = (node, flag) => {\n  if (node[flag]) {\n    node[flag] = false\n    depth({\n      tree: node,\n      visit: node => {\n        node.extraneous = node[flag] = false\n        if (node.target)\n          node.target.extraneous = node.target[flag] = false\n      },\n      getChildren: node => [...(node.target || node).edgesOut.values()]\n        .filter(edge => edge.to && edge.to[flag] &&\n          (flag !== 'peer' && edge.type === 'peer' || edge.type === 'prod'))\n        .map(edge => edge.to),\n    })\n  }\n}\n\nmodule.exports = calcDepFlags\n"]},"metadata":{},"sourceType":"script"}
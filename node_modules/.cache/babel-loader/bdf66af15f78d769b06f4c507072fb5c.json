{"ast":null,"code":"// The goal here is to minimize both git workload and\n// the number of refs we download over the network.\n//\n// Every method ends up with the checked out working dir\n// at the specified ref, and resolves with the git sha.\n// Only certain whitelisted hosts get shallow cloning.\n// Many hosts (including GHE) don't always support it.\n// A failed shallow fetch takes a LOT longer than a full\n// fetch in most cases, so we skip it entirely.\n// Set opts.gitShallow = true/false to force this behavior\n// one way or the other.\nconst shallowHosts = new Set(['github.com', 'gist.github.com', 'gitlab.com', 'bitbucket.com', 'bitbucket.org']);\n\nconst {\n  parse\n} = require('url');\n\nconst {\n  basename,\n  resolve\n} = require('path');\n\nconst revs = require('./revs.js');\n\nconst spawn = require('./spawn.js');\n\nconst pickManifest = require('npm-pick-manifest');\n\nconst {\n  promisify\n} = require('util');\n\nconst fs = require('fs');\n\nconst mkdirp = require('mkdirp');\n\nmodule.exports = (repo, ref = 'HEAD', target = null,\n/* istanbul ignore next */\nopts = {}) => revs(repo, opts).then(revs => clone(repo, revs, ref, resolveRef(revs, ref, opts), target || defaultTarget(repo, opts.cwd), opts));\n\nconst maybeShallow = (repo, opts) => opts.gitShallow === false || opts.gitShallow ? opts.gitShallow : shallowHosts.has(parse(repo).host);\n\nconst isWindows = opts => (opts.fakePlatform || process.platform) === 'win32';\n\nconst defaultTarget = (repo,\n/* istanbul ignore next */\ncwd = process.cwd()) => resolve(cwd, basename(repo.replace(/[\\/\\\\]?\\.git$/, '')));\n\nconst clone = (repo, revs, ref, revDoc, target, opts) => !revDoc ? unresolved(repo, ref, target, opts) : revDoc.sha === revs.refs.HEAD.sha ? plain(repo, revDoc, target, opts) : revDoc.type === 'tag' || revDoc.type === 'branch' ? branch(repo, revDoc, target, opts) : other(repo, revDoc, target, opts);\n\nconst resolveRef = (revs, ref, opts) => {\n  const {\n    spec = {}\n  } = opts;\n  ref = spec.gitCommittish || ref;\n  return !revs ?\n  /* istanbul ignore next - will fail anyway, can't pull */\n  null : spec.gitRange ? pickManifest(revs, spec.gitRange, opts) : !ref ? revs.refs.HEAD : revs.refs[ref] ? revs.refs[ref] : revs.shas[ref] ? revs.refs[revs.shas[ref][0]] : null;\n}; // pull request or some other kind of advertised ref\n\n\nconst other = (repo, revDoc, target, opts) => {\n  const shallow = maybeShallow(repo, opts);\n  const fetchOrigin = ['fetch', 'origin', revDoc.rawRef].concat(shallow ? ['--depth=1'] : []);\n\n  const git = args => spawn(args, { ...opts,\n    cwd: target\n  });\n\n  return mkdirp(target).then(() => git(['init'])).then(() => isWindows(opts) ? git(['config', '--local', '--add', 'core.longpaths', 'true']) : null).then(() => git(['remote', 'add', 'origin', repo])).then(() => git(fetchOrigin)).then(() => git(['checkout', revDoc.sha])).then(() => updateSubmodules(target, opts)).then(() => revDoc.sha);\n}; // tag or branches.  use -b\n\n\nconst branch = (repo, revDoc, target, opts) => {\n  const args = ['clone', '-b', revDoc.ref, repo, target, '--recurse-submodules'];\n  if (maybeShallow(repo, opts)) args.push('--depth=1');\n  if (isWindows(opts)) args.push('--config', 'core.longpaths=true');\n  return spawn(args, opts).then(() => revDoc.sha);\n}; // just the head.  clone it\n\n\nconst plain = (repo, revDoc, target, opts) => {\n  const args = ['clone', repo, target, '--recurse-submodules'];\n  if (maybeShallow(repo, opts)) args.push('--depth=1');\n  if (isWindows(opts)) args.push('--config', 'core.longpaths=true');\n  return spawn(args, opts).then(() => revDoc.sha);\n};\n\nconst updateSubmodules = (target, opts) => new Promise(res => fs.stat(target + '/.gitmodules', er => res(er ? null : spawn(['submodule', 'update', '-q', '--init', '--recursive'], { ...opts,\n  cwd: target\n}))));\n\nconst unresolved = (repo, ref, target, opts) => {\n  // can't do this one shallowly, because the ref isn't advertised\n  // but we can avoid checking out the working dir twice, at least\n  const lp = isWindows(opts) ? ['--config', 'core.longpaths=true'] : [];\n  const cloneArgs = ['clone', '--mirror', '-q', repo, target + '/.git'];\n\n  const git = args => spawn(args, { ...opts,\n    cwd: target\n  });\n\n  return mkdirp(target).then(() => git(cloneArgs.concat(lp))).then(() => git(['init'])).then(() => git(['checkout', ref])).then(() => updateSubmodules(target, opts)).then(() => git(['rev-parse', '--revs-only', 'HEAD'])).then(({\n    stdout\n  }) => stdout.trim());\n};","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/node_modules/@npmcli/git/lib/clone.js"],"names":["shallowHosts","Set","parse","require","basename","resolve","revs","spawn","pickManifest","promisify","fs","mkdirp","module","exports","repo","ref","target","opts","then","clone","resolveRef","defaultTarget","cwd","maybeShallow","gitShallow","has","host","isWindows","fakePlatform","process","platform","replace","revDoc","unresolved","sha","refs","HEAD","plain","type","branch","other","spec","gitCommittish","gitRange","shas","shallow","fetchOrigin","rawRef","concat","git","args","updateSubmodules","push","Promise","res","stat","er","lp","cloneArgs","stdout","trim"],"mappings":"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","sourcesContent":["// The goal here is to minimize both git workload and\n// the number of refs we download over the network.\n//\n// Every method ends up with the checked out working dir\n// at the specified ref, and resolves with the git sha.\n\n// Only certain whitelisted hosts get shallow cloning.\n// Many hosts (including GHE) don't always support it.\n// A failed shallow fetch takes a LOT longer than a full\n// fetch in most cases, so we skip it entirely.\n// Set opts.gitShallow = true/false to force this behavior\n// one way or the other.\nconst shallowHosts = new Set([\n  'github.com',\n  'gist.github.com',\n  'gitlab.com',\n  'bitbucket.com',\n  'bitbucket.org',\n])\nconst { parse } = require('url')\nconst { basename, resolve } = require('path')\n\nconst revs = require('./revs.js')\nconst spawn = require('./spawn.js')\n\nconst pickManifest = require('npm-pick-manifest')\nconst { promisify } = require('util')\nconst fs = require('fs')\nconst mkdirp = require('mkdirp')\n\nmodule.exports = (repo, ref = 'HEAD', target = null, /* istanbul ignore next */ opts = {}) =>\n  revs(repo, opts).then(revs => clone(\n    repo,\n    revs,\n    ref,\n    resolveRef(revs, ref, opts),\n    target || defaultTarget(repo, opts.cwd),\n    opts\n  ))\n\nconst maybeShallow = (repo, opts) =>\n  opts.gitShallow === false || opts.gitShallow ? opts.gitShallow\n    : shallowHosts.has(parse(repo).host)\n\nconst isWindows = opts => (opts.fakePlatform || process.platform) === 'win32'\n\nconst defaultTarget = (repo, /* istanbul ignore next */ cwd = process.cwd()) =>\n  resolve(cwd, basename(repo.replace(/[\\/\\\\]?\\.git$/, '')))\n\nconst clone = (repo, revs, ref, revDoc, target, opts) =>\n  !revDoc ? unresolved(repo, ref, target, opts)\n    : revDoc.sha === revs.refs.HEAD.sha ? plain(repo, revDoc, target, opts)\n    : revDoc.type === 'tag' || revDoc.type === 'branch'\n      ? branch(repo, revDoc, target, opts)\n    : other(repo, revDoc, target, opts)\n\nconst resolveRef = (revs, ref, opts) => {\n  const { spec = {} } = opts\n  ref = spec.gitCommittish || ref\n  return !revs ? /* istanbul ignore next - will fail anyway, can't pull */ null\n    : spec.gitRange ? pickManifest(revs, spec.gitRange, opts)\n    : !ref ? revs.refs.HEAD\n    : revs.refs[ref] ? revs.refs[ref]\n    : revs.shas[ref] ? revs.refs[revs.shas[ref][0]]\n    : null\n}\n\n// pull request or some other kind of advertised ref\nconst other = (repo, revDoc, target, opts) => {\n  const shallow = maybeShallow(repo, opts)\n\n  const fetchOrigin = [ 'fetch', 'origin', revDoc.rawRef ]\n    .concat(shallow ? ['--depth=1'] : [])\n\n  const git = (args) => spawn(args, { ...opts, cwd: target })\n  return mkdirp(target)\n    .then(() => git(['init']))\n    .then(() => isWindows(opts)\n      ? git(['config', '--local', '--add', 'core.longpaths', 'true'])\n      : null)\n    .then(() => git(['remote', 'add', 'origin', repo]))\n    .then(() => git(fetchOrigin))\n    .then(() => git(['checkout', revDoc.sha]))\n    .then(() => updateSubmodules(target, opts))\n    .then(() => revDoc.sha)\n}\n\n// tag or branches.  use -b\nconst branch = (repo, revDoc, target, opts) => {\n  const args = [\n    'clone',\n    '-b',\n    revDoc.ref,\n    repo,\n    target,\n    '--recurse-submodules',\n  ]\n  if (maybeShallow(repo, opts))\n    args.push('--depth=1')\n  if (isWindows(opts))\n    args.push('--config', 'core.longpaths=true')\n  return spawn(args, opts).then(() => revDoc.sha)\n}\n\n// just the head.  clone it\nconst plain = (repo, revDoc, target, opts) => {\n  const args = [\n    'clone',\n    repo,\n    target,\n    '--recurse-submodules'\n  ]\n  if (maybeShallow(repo, opts))\n    args.push('--depth=1')\n  if (isWindows(opts))\n    args.push('--config', 'core.longpaths=true')\n  return spawn(args, opts).then(() => revDoc.sha)\n}\n\nconst updateSubmodules = (target, opts) => new Promise(res =>\n  fs.stat(target + '/.gitmodules', er => res(er ? null\n    : spawn([\n      'submodule',\n      'update',\n      '-q',\n      '--init',\n      '--recursive'\n    ], { ...opts, cwd: target }))))\n\nconst unresolved = (repo, ref, target, opts) => {\n  // can't do this one shallowly, because the ref isn't advertised\n  // but we can avoid checking out the working dir twice, at least\n  const lp = isWindows(opts) ? ['--config', 'core.longpaths=true'] : []\n  const cloneArgs = ['clone', '--mirror', '-q', repo, target + '/.git']\n  const git = (args) => spawn(args, { ...opts, cwd: target })\n  return mkdirp(target)\n    .then(() => git(cloneArgs.concat(lp)))\n    .then(() => git(['init']))\n    .then(() => git(['checkout', ref]))\n    .then(() => updateSubmodules(target, opts))\n    .then(() => git(['rev-parse', '--revs-only', 'HEAD']))\n    .then(({stdout}) => stdout.trim())\n}\n"]},"metadata":{},"sourceType":"script"}
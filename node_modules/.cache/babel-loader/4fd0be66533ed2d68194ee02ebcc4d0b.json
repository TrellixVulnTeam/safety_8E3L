{"ast":null,"code":"// mixin implementing the reify method\nconst onExit = require('../signal-handling.js');\n\nconst pacote = require('pacote');\n\nconst rpj = require('read-package-json-fast');\n\nconst {\n  updateDepSpec\n} = require('../dep-spec.js');\n\nconst AuditReport = require('../audit-report.js');\n\nconst {\n  subset\n} = require('semver');\n\nconst npa = require('npm-package-arg');\n\nconst {\n  dirname,\n  resolve,\n  relative\n} = require('path');\n\nconst {\n  depth: dfwalk\n} = require('treeverse');\n\nconst fs = require('fs');\n\nconst {\n  promisify\n} = require('util');\n\nconst symlink = promisify(fs.symlink);\n\nconst mkdirp = require('mkdirp-infer-owner');\n\nconst justMkdirp = require('mkdirp');\n\nconst moveFile = require('@npmcli/move-file');\n\nconst rimraf = promisify(require('rimraf'));\n\nconst packageContents = require('@npmcli/installed-package-contents');\n\nconst {\n  checkEngine,\n  checkPlatform\n} = require('npm-install-checks');\n\nconst treeCheck = require('../tree-check.js');\n\nconst relpath = require('../relpath.js');\n\nconst Diff = require('../diff.js');\n\nconst retirePath = require('../retire-path.js');\n\nconst promiseAllRejectLate = require('promise-all-reject-late');\n\nconst optionalSet = require('../optional-set.js');\n\nconst updateRootPackageJson = require('../update-root-package-json.js');\n\nconst calcDepFlags = require('../calc-dep-flags.js');\n\nconst _retiredPaths = Symbol('retiredPaths');\n\nconst _retiredUnchanged = Symbol('retiredUnchanged');\n\nconst _sparseTreeDirs = Symbol('sparseTreeDirs');\n\nconst _sparseTreeRoots = Symbol('sparseTreeRoots');\n\nconst _savePrefix = Symbol('savePrefix');\n\nconst _retireShallowNodes = Symbol.for('retireShallowNodes');\n\nconst _getBundlesByDepth = Symbol('getBundlesByDepth');\n\nconst _registryResolved = Symbol('registryResolved');\n\nconst _addNodeToTrashList = Symbol('addNodeToTrashList');\n\nconst _workspaces = Symbol.for('workspaces'); // shared by rebuild mixin\n\n\nconst _trashList = Symbol.for('trashList');\n\nconst _handleOptionalFailure = Symbol.for('handleOptionalFailure');\n\nconst _loadTrees = Symbol.for('loadTrees'); // shared symbols for swapping out when testing\n\n\nconst _diffTrees = Symbol.for('diffTrees');\n\nconst _createSparseTree = Symbol.for('createSparseTree');\n\nconst _loadShrinkwrapsAndUpdateTrees = Symbol.for('loadShrinkwrapsAndUpdateTrees');\n\nconst _shrinkwrapUnpacked = Symbol('shrinkwrapUnpacked');\n\nconst _reifyNode = Symbol.for('reifyNode');\n\nconst _extractOrLink = Symbol('extractOrLink'); // defined by rebuild mixin\n\n\nconst _checkBins = Symbol.for('checkBins');\n\nconst _symlink = Symbol('symlink');\n\nconst _warnDeprecated = Symbol('warnDeprecated');\n\nconst _loadAncientPackageDetails = Symbol('loadAncientPackageDetails');\n\nconst _loadBundlesAndUpdateTrees = Symbol.for('loadBundlesAndUpdateTrees');\n\nconst _submitQuickAudit = Symbol('submitQuickAudit');\n\nconst _awaitQuickAudit = Symbol('awaitQuickAudit');\n\nconst _unpackNewModules = Symbol.for('unpackNewModules');\n\nconst _moveContents = Symbol.for('moveContents');\n\nconst _moveBackRetiredUnchanged = Symbol.for('moveBackRetiredUnchanged');\n\nconst _build = Symbol.for('build');\n\nconst _removeTrash = Symbol.for('removeTrash');\n\nconst _renamePath = Symbol.for('renamePath');\n\nconst _rollbackRetireShallowNodes = Symbol.for('rollbackRetireShallowNodes');\n\nconst _rollbackCreateSparseTree = Symbol.for('rollbackCreateSparseTree');\n\nconst _rollbackMoveBackRetiredUnchanged = Symbol.for('rollbackMoveBackRetiredUnchanged');\n\nconst _saveIdealTree = Symbol.for('saveIdealTree');\n\nconst _saveLockFile = Symbol('saveLockFile');\n\nconst _copyIdealToActual = Symbol('copyIdealToActual');\n\nconst _addOmitsToTrashList = Symbol('addOmitsToTrashList');\n\nconst _packageLockOnly = Symbol('packageLockOnly');\n\nconst _dryRun = Symbol('dryRun');\n\nconst _validatePath = Symbol('validatePath');\n\nconst _reifyPackages = Symbol('reifyPackages');\n\nconst _omitDev = Symbol('omitDev');\n\nconst _omitOptional = Symbol('omitOptional');\n\nconst _omitPeer = Symbol('omitPeer');\n\nconst _global = Symbol.for('global'); // defined by Ideal mixin\n\n\nconst _pruneBundledMetadeps = Symbol.for('pruneBundledMetadeps');\n\nconst _resolvedAdd = Symbol.for('resolvedAdd');\n\nconst _usePackageLock = Symbol.for('usePackageLock');\n\nconst _formatPackageLock = Symbol.for('formatPackageLock');\n\nmodule.exports = cls => class Reifier extends cls {\n  constructor(options) {\n    super(options);\n    const {\n      savePrefix = '^',\n      packageLockOnly = false,\n      dryRun = false,\n      formatPackageLock = true\n    } = options;\n    this[_dryRun] = !!dryRun;\n    this[_packageLockOnly] = !!packageLockOnly;\n    this[_savePrefix] = savePrefix;\n    this[_formatPackageLock] = !!formatPackageLock;\n    this.diff = null;\n    this[_retiredPaths] = {};\n    this[_shrinkwrapUnpacked] = new Set();\n    this[_retiredUnchanged] = {};\n    this[_sparseTreeDirs] = new Set();\n    this[_sparseTreeRoots] = new Set();\n    this[_trashList] = new Set();\n  } // public method\n\n\n  async reify(options = {}) {\n    if (this[_packageLockOnly] && this[_global]) {\n      const er = new Error('cannot generate lockfile for global packages');\n      er.code = 'ESHRINKWRAPGLOBAL';\n      throw er;\n    }\n\n    const omit = new Set(options.omit || []);\n    this[_omitDev] = omit.has('dev');\n    this[_omitOptional] = omit.has('optional');\n    this[_omitPeer] = omit.has('peer'); // start tracker block\n\n    this.addTracker('reify');\n    process.emit('time', 'reify');\n    await this[_validatePath]().then(() => this[_loadTrees](options)).then(() => this[_diffTrees]()).then(() => this[_reifyPackages]()).then(() => this[_saveIdealTree](options)).then(() => this[_copyIdealToActual]()).then(() => this[_awaitQuickAudit]());\n    this.finishTracker('reify');\n    process.emit('timeEnd', 'reify');\n    return treeCheck(this.actualTree);\n  }\n\n  async [_validatePath]() {\n    // don't create missing dirs on dry runs\n    if (this[_packageLockOnly] || this[_dryRun]) return; // we do NOT want to set ownership on this folder, especially\n    // recursively, because it can have other side effects to do that\n    // in a project directory.  We just want to make it if it's missing.\n\n    await justMkdirp(resolve(this.path));\n  }\n\n  async [_reifyPackages]() {\n    // we don't submit the audit report or write to disk on dry runs\n    if (this[_dryRun]) return;\n\n    if (this[_packageLockOnly]) {\n      // we already have the complete tree, so just audit it now,\n      // and that's all we have to do here.\n      return this[_submitQuickAudit]();\n    } // ok, we're about to start touching the fs.  need to roll back\n    // if we get an early termination.\n\n\n    let reifyTerminated = null;\n    const removeHandler = onExit(({\n      signal\n    }) => {\n      // only call once.  if signal hits twice, we just terminate\n      removeHandler();\n      reifyTerminated = Object.assign(new Error('process terminated'), {\n        signal\n      });\n      return false;\n    }); // [rollbackfn, [...actions]]\n    // after each step, if the process was terminated, execute the rollback\n    // note that each rollback *also* calls the previous one when it's\n    // finished, and then the first one throws the error, so we only need\n    // a new rollback step when we have a new thing that must be done to\n    // revert the install.\n\n    const steps = [[_rollbackRetireShallowNodes, [_retireShallowNodes]], [_rollbackCreateSparseTree, [_createSparseTree, _addOmitsToTrashList, _loadShrinkwrapsAndUpdateTrees, _loadBundlesAndUpdateTrees, _submitQuickAudit, _unpackNewModules]], [_rollbackMoveBackRetiredUnchanged, [_moveBackRetiredUnchanged, _build]]];\n\n    for (const [rollback, actions] of steps) {\n      for (const action of actions) {\n        try {\n          await this[action]();\n          if (reifyTerminated) throw reifyTerminated;\n        } catch (er) {\n          await this[rollback](er);\n          /* istanbul ignore next - rollback throws, should never hit this */\n\n          throw er;\n        }\n      }\n    } // no rollback for this one, just exit with the error, since the\n    // install completed and can't be safely recovered at this point.\n\n\n    await this[_removeTrash]();\n    if (reifyTerminated) throw reifyTerminated; // done modifying the file system, no need to keep listening for sigs\n\n    removeHandler();\n  } // when doing a local install, we load everything and figure it all out.\n  // when doing a global install, we *only* care about the explicit requests.\n\n\n  [_loadTrees](options) {\n    process.emit('time', 'reify:loadTrees');\n    const bitOpt = { ...options,\n      complete: this[_packageLockOnly] || this[_dryRun]\n    }; // if we're only writing a package lock, then it doesn't matter what's here\n\n    if (this[_packageLockOnly]) {\n      return this.buildIdealTree(bitOpt).then(() => process.emit('timeEnd', 'reify:loadTrees'));\n    }\n\n    const actualOpt = this[_global] ? {\n      ignoreMissing: true,\n      global: true,\n      filter: (node, kid) => {\n        // if it's not the project root, and we have no explicit requests,\n        // then we're already into a nested dep, so we keep it\n        if (this.explicitRequests.size === 0 || !node.isProjectRoot) return true; // if we added it as an edgeOut, then we want it\n\n        if (this.idealTree.edgesOut.has(kid)) return true; // if it's an explicit request, then we want it\n\n        const hasExplicit = [...this.explicitRequests].some(edge => edge.name === kid);\n        if (hasExplicit) return true; // ignore the rest of the global install folder\n\n        return false;\n      }\n    } : {\n      ignoreMissing: true\n    };\n\n    if (!this[_global]) {\n      return Promise.all([this.loadActual(actualOpt), this.buildIdealTree(bitOpt)]).then(() => process.emit('timeEnd', 'reify:loadTrees'));\n    } // the global install space tends to have a lot of stuff in it.  don't\n    // load all of it, just what we care about.  we won't be saving a\n    // hidden lockfile in there anyway.  Note that we have to load ideal\n    // BEFORE loading actual, so that the actualOpt can use the\n    // explicitRequests which is set during buildIdealTree\n\n\n    return this.buildIdealTree(bitOpt).then(() => this.loadActual(actualOpt)).then(() => process.emit('timeEnd', 'reify:loadTrees'));\n  }\n\n  [_diffTrees]() {\n    if (this[_packageLockOnly]) return;\n    process.emit('time', 'reify:diffTrees'); // XXX if we have an existing diff already, there should be a way\n    // to just invalidate the parts that changed, but avoid walking the\n    // whole tree again.\n\n    const filterNodes = [];\n\n    if (this[_global] && this.explicitRequests.size) {\n      const idealTree = this.idealTree.target || this.idealTree;\n      const actualTree = this.actualTree.target || this.actualTree; // we ONLY are allowed to make changes in the global top-level\n      // children where there's an explicit request.\n\n      for (const {\n        name\n      } of this.explicitRequests) {\n        const ideal = idealTree.children.get(name);\n        if (ideal) filterNodes.push(ideal);\n        const actual = actualTree.children.get(name);\n        if (actual) filterNodes.push(actual);\n      }\n    } else {\n      for (const ws of this[_workspaces]) {\n        const ideal = this.idealTree.children.get(ws);\n        if (ideal) filterNodes.push(ideal);\n        const actual = this.actualTree.children.get(ws);\n        if (actual) filterNodes.push(actual);\n      }\n    } // find all the nodes that need to change between the actual\n    // and ideal trees.\n\n\n    this.diff = Diff.calculate({\n      filterNodes,\n      actual: this.actualTree,\n      ideal: this.idealTree\n    });\n\n    for (const node of this.diff.removed) {\n      // a node in a dep bundle will only be removed if its bundling dep\n      // is removed as well.  in which case, we don't have to delete it!\n      if (!node.inDepBundle) this[_addNodeToTrashList](node);\n    }\n\n    process.emit('timeEnd', 'reify:diffTrees');\n  } // add the node and all its bins to the list of things to be\n  // removed later on in the process.  optionally, also mark them\n  // as a retired paths, so that we move them out of the way and\n  // replace them when rolling back on failure.\n\n\n  [_addNodeToTrashList](node, retire) {\n    const paths = [node.path, ...node.binPaths];\n    const moves = this[_retiredPaths];\n    this.log.silly('reify', 'mark', retire ? 'retired' : 'deleted', paths);\n\n    for (const path of paths) {\n      if (retire) {\n        const retired = retirePath(path);\n        moves[path] = retired;\n\n        this[_trashList].add(retired);\n      } else this[_trashList].add(path);\n    }\n  } // move aside the shallowest nodes in the tree that have to be\n  // changed or removed, so that we can rollback if necessary.\n\n\n  [_retireShallowNodes]() {\n    process.emit('time', 'reify:retireShallow');\n    const moves = this[_retiredPaths] = {};\n\n    for (const diff of this.diff.children) {\n      if (diff.action === 'CHANGE' || diff.action === 'REMOVE') {\n        // we'll have to clean these up at the end, so add them to the list\n        this[_addNodeToTrashList](diff.actual, true);\n      }\n    }\n\n    this.log.silly('reify', 'moves', moves);\n    const movePromises = Object.entries(moves).map(([from, to]) => this[_renamePath](from, to));\n    return promiseAllRejectLate(movePromises).then(() => process.emit('timeEnd', 'reify:retireShallow'));\n  }\n\n  [_renamePath](from, to, didMkdirp = false) {\n    return moveFile(from, to).catch(er => {\n      // Occasionally an expected bin file might not exist in the package,\n      // or a shim/symlink might have been moved aside.  If we've already\n      // handled the most common cause of ENOENT (dir doesn't exist yet),\n      // then just ignore any ENOENT.\n      if (er.code === 'ENOENT') {\n        return didMkdirp ? null : mkdirp(dirname(to)).then(() => this[_renamePath](from, to, true));\n      } else if (er.code === 'EEXIST') return rimraf(to).then(() => moveFile(from, to));else throw er;\n    });\n  }\n\n  [_rollbackRetireShallowNodes](er) {\n    process.emit('time', 'reify:rollback:retireShallow');\n    const moves = this[_retiredPaths];\n    const movePromises = Object.entries(moves).map(([from, to]) => this[_renamePath](to, from));\n    return promiseAllRejectLate(movePromises) // ignore subsequent rollback errors\n    .catch(er => {}).then(() => process.emit('timeEnd', 'reify:rollback:retireShallow')).then(() => {\n      throw er;\n    });\n  } // adding to the trash list will skip reifying, and delete them\n  // if they are currently in the tree and otherwise untouched.\n\n\n  [_addOmitsToTrashList]() {\n    if (!this[_omitDev] && !this[_omitOptional] && !this[_omitPeer]) return;\n    process.emit('time', 'reify:trashOmits');\n\n    const filter = node => node.peer && this[_omitPeer] || node.dev && this[_omitDev] || node.optional && this[_omitOptional] || node.devOptional && this[_omitOptional] && this[_omitDev];\n\n    for (const node of this.idealTree.inventory.filter(filter)) this[_addNodeToTrashList](node);\n\n    process.emit('timeEnd', 'reify:trashOmits');\n  }\n\n  [_createSparseTree]() {\n    process.emit('time', 'reify:createSparse'); // if we call this fn again, we look for the previous list\n    // so that we can avoid making the same directory multiple times\n\n    const dirs = this.diff.leaves.filter(diff => {\n      return (diff.action === 'ADD' || diff.action === 'CHANGE') && !this[_sparseTreeDirs].has(diff.ideal.path);\n    }).map(diff => diff.ideal.path);\n    return promiseAllRejectLate(dirs.map(d => mkdirp(d))).then(made => {\n      made.forEach(made => this[_sparseTreeRoots].add(made));\n      dirs.forEach(dir => this[_sparseTreeDirs].add(dir));\n    }).then(() => process.emit('timeEnd', 'reify:createSparse'));\n  }\n\n  [_rollbackCreateSparseTree](er) {\n    process.emit('time', 'reify:rollback:createSparse'); // cut the roots of the sparse tree that were created, not the leaves\n\n    const roots = this[_sparseTreeRoots]; // also delete the moves that we retired, so that we can move them back\n\n    const failures = [];\n    const targets = [...roots, ...Object.keys(this[_retiredPaths])];\n    const unlinks = targets.map(path => rimraf(path).catch(er => failures.push([path, er])));\n    return promiseAllRejectLate(unlinks).then(() => {\n      if (failures.length) this.log.warn('cleanup', 'Failed to remove some directories', failures);\n    }).then(() => process.emit('timeEnd', 'reify:rollback:createSparse')).then(() => this[_rollbackRetireShallowNodes](er));\n  } // shrinkwrap nodes define their dependency branches with a file, so\n  // we need to unpack them, read that shrinkwrap file, and then update\n  // the tree by calling loadVirtual with the node as the root.\n\n\n  [_loadShrinkwrapsAndUpdateTrees]() {\n    const seen = this[_shrinkwrapUnpacked];\n    const shrinkwraps = this.diff.leaves.filter(d => (d.action === 'CHANGE' || d.action === 'ADD') && d.ideal.hasShrinkwrap && !seen.has(d.ideal) && !this[_trashList].has(d.ideal.path));\n    if (!shrinkwraps.length) return;\n    process.emit('time', 'reify:loadShrinkwraps');\n    const Arborist = this.constructor;\n    return promiseAllRejectLate(shrinkwraps.map(diff => {\n      const node = diff.ideal;\n      seen.add(node);\n      return this[_reifyNode](node);\n    })).then(nodes => promiseAllRejectLate(nodes.map(node => new Arborist({ ...this.options,\n      path: node.path\n    }).loadVirtual({\n      root: node\n    })))) // reload the diff and sparse tree because the ideal tree changed\n    .then(() => this[_diffTrees]()).then(() => this[_createSparseTree]()).then(() => this[_addOmitsToTrashList]()).then(() => this[_loadShrinkwrapsAndUpdateTrees]()).then(() => process.emit('timeEnd', 'reify:loadShrinkwraps'));\n  } // create a symlink for Links, extract for Nodes\n  // return the node object, since we usually want that\n  // handle optional dep failures here\n  // If node is in trash list, skip it\n  // If reifying fails, and the node is optional, add it and its optionalSet\n  // to the trash list\n  // Always return the node.\n\n\n  [_reifyNode](node) {\n    if (this[_trashList].has(node.path)) return node;\n    const timer = `reifyNode:${node.location}`;\n    process.emit('time', timer);\n    this.addTracker('reify', node.name, node.location);\n    const {\n      npmVersion,\n      nodeVersion\n    } = this.options;\n    const p = Promise.resolve().then(() => {\n      // when we reify an optional node, check the engine and platform\n      // first. be sure to ignore the --force and --engine-strict flags,\n      // since we always want to skip any optional packages we can't install.\n      // these checks throwing will result in a rollback and removal\n      // of the mismatches\n      if (node.optional) {\n        checkEngine(node.package, npmVersion, nodeVersion, false);\n        checkPlatform(node.package, false);\n      }\n    }).then(() => this[_checkBins](node)).then(() => this[_extractOrLink](node)).then(() => this[_warnDeprecated](node)).then(() => this[_loadAncientPackageDetails](node));\n    return this[_handleOptionalFailure](node, p).then(() => {\n      this.finishTracker('reify', node.name, node.location);\n      process.emit('timeEnd', timer);\n      return node;\n    });\n  }\n\n  [_extractOrLink](node) {\n    // in normal cases, node.resolved should *always* be set by now.\n    // however, it is possible when a lockfile is damaged, or very old,\n    // or in some other race condition bugs in npm v6, that a previously\n    // bundled dependency will have just a version, but no resolved value,\n    // and no 'bundled: true' setting.\n    // Do the best with what we have, or else remove it from the tree\n    // entirely, since we can't possibly reify it.\n    const res = node.resolved ? `${node.name}@${this[_registryResolved](node.resolved)}` : node.package.name && node.version ? `${node.package.name}@${node.version}` : null; // no idea what this thing is.  remove it from the tree.\n\n    if (!res) {\n      const warning = 'invalid or damaged lockfile detected\\n' + 'please re-try this operation once it completes\\n' + 'so that the damage can be corrected, or perform\\n' + 'a fresh install with no lockfile if the problem persists.';\n      this.log.warn('reify', warning);\n      this.log.verbose('reify', 'unrecognized node in tree', node.path);\n      node.parent = null;\n      node.fsParent = null;\n\n      this[_addNodeToTrashList](node);\n\n      return;\n    }\n\n    return node.isLink ? rimraf(node.path).then(() => this[_symlink](node)) : pacote.extract(res, node.path, { ...this.options,\n      resolved: node.resolved,\n      integrity: node.integrity\n    });\n  }\n\n  [_symlink](node) {\n    const dir = dirname(node.path);\n    const target = node.realpath;\n    const rel = relative(dir, target);\n    return symlink(rel, node.path, 'junction');\n  }\n\n  [_warnDeprecated](node) {\n    const {\n      _id,\n      deprecated\n    } = node.package;\n    if (deprecated) this.log.warn('deprecated', `${_id}: ${deprecated}`);\n  }\n\n  async [_loadAncientPackageDetails](node, forceReload = false) {\n    // If we're loading from a v1 lockfile, load details from the package.json\n    // that weren't recorded in the old format.\n    const {\n      meta\n    } = this.idealTree;\n    const ancient = meta.ancientLockfile;\n    const old = meta.loadedFromDisk && !(meta.originalLockfileVersion >= 2); // already replaced with the manifest if it's truly ancient\n\n    if (node.path && (forceReload || old && !ancient)) {\n      // XXX should have a shared location where package.json is read,\n      // so we don't ever read the same pj more than necessary.\n      let pkg;\n\n      try {\n        pkg = await rpj(node.path + '/package.json');\n      } catch (err) {}\n\n      if (pkg) {\n        node.package.bin = pkg.bin;\n        node.package.os = pkg.os;\n        node.package.cpu = pkg.cpu;\n        node.package.engines = pkg.engines;\n        meta.add(node);\n      }\n    }\n  } // if the node is optional, then the failure of the promise is nonfatal\n  // just add it and its optional set to the trash list.\n\n\n  [_handleOptionalFailure](node, p) {\n    return (node.optional ? p.catch(er => {\n      const set = optionalSet(node);\n\n      for (node of set) {\n        this.log.verbose('reify', 'failed optional dependency', node.path);\n\n        this[_addNodeToTrashList](node);\n      }\n    }) : p).then(() => node);\n  }\n\n  [_registryResolved](resolved) {\n    // the default registry url is a magic value meaning \"the currently\n    // configured registry\".\n    //\n    // XXX: use a magic string that isn't also a valid value, like\n    // ${REGISTRY} or something.  This has to be threaded through the\n    // Shrinkwrap and Node classes carefully, so for now, just treat\n    // the default reg as the magical animal that it has been.\n    return resolved && resolved.replace(/^https?:\\/\\/registry.npmjs.org\\//, this.registry);\n  } // bundles are *sort of* like shrinkwraps, in that the branch is defined\n  // by the contents of the package.  however, in their case, rather than\n  // shipping a virtual tree that must be reified, they ship an entire\n  // reified actual tree that must be unpacked and not modified.\n\n\n  [_loadBundlesAndUpdateTrees](depth = 0, bundlesByDepth = this[_getBundlesByDepth]()) {\n    if (depth === 0) process.emit('time', 'reify:loadBundles');\n    const maxBundleDepth = bundlesByDepth.get('maxBundleDepth');\n\n    if (depth > maxBundleDepth) {\n      // if we did something, then prune the tree and update the diffs\n      if (maxBundleDepth !== -1) {\n        this[_pruneBundledMetadeps](bundlesByDepth);\n\n        this[_diffTrees]();\n      }\n\n      process.emit('timeEnd', 'reify:loadBundles');\n      return;\n    } // skip any that have since been removed from the tree, eg by a\n    // shallower bundle overwriting them with a bundled meta-dep.\n\n\n    const set = (bundlesByDepth.get(depth) || []).filter(node => node.root === this.idealTree && !this[_trashList].has(node.path));\n    if (!set.length) return this[_loadBundlesAndUpdateTrees](depth + 1, bundlesByDepth); // extract all the nodes with bundles\n\n    return promiseAllRejectLate(set.map(node => this[_reifyNode](node))) // then load their unpacked children and move into the ideal tree\n    .then(nodes => promiseAllRejectLate(nodes.map(node => new this.constructor({ ...this.options,\n      path: node.path\n    }).loadActual({\n      root: node,\n      // don't transplant any sparse folders we created\n      transplantFilter: node => node.package._id\n    })))) // move onto the next level of bundled items\n    .then(() => this[_loadBundlesAndUpdateTrees](depth + 1, bundlesByDepth));\n  }\n\n  [_getBundlesByDepth]() {\n    const bundlesByDepth = new Map();\n    let maxBundleDepth = -1;\n    dfwalk({\n      tree: this.diff,\n      visit: diff => {\n        const node = diff.ideal;\n\n        if (node && !node.isProjectRoot && node.package.bundleDependencies && node.package.bundleDependencies.length) {\n          maxBundleDepth = Math.max(maxBundleDepth, node.depth);\n          if (!bundlesByDepth.has(node.depth)) bundlesByDepth.set(node.depth, [node]);else bundlesByDepth.get(node.depth).push(node);\n        }\n      },\n      getChildren: diff => diff.children\n    });\n    bundlesByDepth.set('maxBundleDepth', maxBundleDepth);\n    return bundlesByDepth;\n  } // https://github.com/npm/cli/issues/1597#issuecomment-667639545\n\n\n  [_pruneBundledMetadeps](bundlesByDepth) {\n    const bundleShadowed = new Set(); // create the list of nodes shadowed by children of bundlers\n\n    for (const bundles of bundlesByDepth.values()) {\n      // skip the 'maxBundleDepth' item\n      if (!Array.isArray(bundles)) continue;\n\n      for (const node of bundles) {\n        for (const name of node.children.keys()) {\n          const shadow = node.parent.resolve(name);\n          if (!shadow) continue;\n          bundleShadowed.add(shadow);\n          shadow.extraneous = true;\n        }\n      }\n    }\n\n    let changed = true;\n\n    while (changed) {\n      changed = false;\n\n      for (const shadow of bundleShadowed) {\n        if (!shadow.extraneous) {\n          bundleShadowed.delete(shadow);\n          continue;\n        }\n\n        for (const edge of shadow.edgesIn) {\n          if (!edge.from.extraneous) {\n            shadow.extraneous = false;\n            bundleShadowed.delete(shadow);\n            changed = true;\n          } else {\n            for (const shadDep of shadow.edgesOut.values()) {\n              /* istanbul ignore else - pretty unusual situation, just being\n               * defensive here. Would mean that a bundled dep has a dependency\n               * that is unmet. which, weird, but if you bundle it, we take\n               * whatever you put there and assume the publisher knows best. */\n              if (shadDep.to) bundleShadowed.add(shadDep.to);\n            }\n          }\n        }\n      }\n    }\n\n    for (const shadow of bundleShadowed) {\n      shadow.parent = null;\n\n      this[_addNodeToTrashList](shadow);\n    }\n  }\n\n  [_submitQuickAudit]() {\n    if (this.options.audit === false) return this.auditReport = null; // we submit the quick audit at this point in the process, as soon as\n    // we have all the deps resolved, so that it can overlap with the other\n    // actions as much as possible.  Stash the promise, which we resolve\n    // before finishing the reify() and returning the tree.  Thus, we do\n    // NOT return the promise, as the intent is for this to run in parallel\n    // with the reification, and be resolved at a later time.\n\n    process.emit('time', 'reify:audit');\n    this.auditReport = AuditReport.load(this.idealTree, this.options).then(res => {\n      process.emit('timeEnd', 'reify:audit');\n      this.auditReport = res;\n    });\n  } // return the promise if we're waiting for it, or the replaced result\n\n\n  [_awaitQuickAudit]() {\n    return this.auditReport;\n  } // ok!  actually unpack stuff into their target locations!\n  // The sparse tree has already been created, so we walk the diff\n  // kicking off each unpack job.  If any fail, we rimraf the sparse\n  // tree entirely and try to put everything back where it was.\n\n\n  [_unpackNewModules]() {\n    process.emit('time', 'reify:unpack');\n    const unpacks = [];\n    dfwalk({\n      tree: this.diff,\n      visit: diff => {\n        // no unpacking if we don't want to change this thing\n        if (diff.action !== 'CHANGE' && diff.action !== 'ADD') return;\n        const node = diff.ideal;\n        const bd = node.package.bundleDependencies;\n\n        const sw = this[_shrinkwrapUnpacked].has(node); // check whether we still need to unpack this one.\n        // test the inDepBundle last, since that's potentially a tree walk.\n\n\n        const doUnpack = node && // can't unpack if removed!\n        !node.isRoot && // root node already exists\n        !(bd && bd.length) && // already unpacked to read bundle\n        !sw && // already unpacked to read sw\n        !node.inDepBundle; // already unpacked by another dep's bundle\n\n        if (doUnpack) unpacks.push(this[_reifyNode](node));\n      },\n      getChildren: diff => diff.children\n    });\n    return promiseAllRejectLate(unpacks).then(() => process.emit('timeEnd', 'reify:unpack'));\n  } // This is the part where we move back the unchanging nodes that were\n  // the children of a node that did change.  If this fails, the rollback\n  // is a three-step process.  First, we try to move the retired unchanged\n  // nodes BACK to their retirement folders, then delete the sparse tree,\n  // then move everything out of retirement.\n\n\n  [_moveBackRetiredUnchanged]() {\n    // get a list of all unchanging children of any shallow retired nodes\n    // if they are not the ancestor of any node in the diff set, then the\n    // directory won't already exist, so just rename it over.\n    // This is sort of an inverse diff tree, of all the nodes where\n    // the actualTree and idealTree _don't_ differ, starting from the\n    // shallowest nodes that we moved aside in the first place.\n    process.emit('time', 'reify:unretire');\n    const moves = this[_retiredPaths];\n    this[_retiredUnchanged] = {};\n    return promiseAllRejectLate(this.diff.children.map(diff => {\n      const realFolder = (diff.actual || diff.ideal).path;\n      const retireFolder = moves[realFolder];\n      this[_retiredUnchanged][retireFolder] = [];\n      return promiseAllRejectLate(diff.unchanged.map(node => {\n        // no need to roll back links, since we'll just delete them anyway\n        if (node.isLink) return mkdirp(dirname(node.path)).then(() => this[_reifyNode](node)); // will have been moved/unpacked along with bundler\n\n        if (node.inDepBundle) return;\n\n        this[_retiredUnchanged][retireFolder].push(node);\n\n        const rel = relative(realFolder, node.path);\n        const fromPath = resolve(retireFolder, rel); // if it has bundleDependencies, then make node_modules.  otherwise\n        // skip it.\n\n        const bd = node.package.bundleDependencies;\n        const dir = bd && bd.length ? node.path + '/node_modules' : node.path;\n        return mkdirp(dir).then(() => this[_moveContents](node, fromPath));\n      }));\n    })).then(() => process.emit('timeEnd', 'reify:unretire'));\n  } // move the contents from the fromPath to the node.path\n\n\n  [_moveContents](node, fromPath) {\n    return packageContents({\n      path: fromPath,\n      depth: 1,\n      packageJsonCache: new Map([[fromPath + '/package.json', node.package]])\n    }).then(res => promiseAllRejectLate(res.map(path => {\n      const rel = relative(fromPath, path);\n      const to = resolve(node.path, rel);\n      return this[_renamePath](path, to);\n    })));\n  }\n\n  [_rollbackMoveBackRetiredUnchanged](er) {\n    const moves = this[_retiredPaths]; // flip the mapping around to go back\n\n    const realFolders = new Map(Object.entries(moves).map(([k, v]) => [v, k]));\n    const promises = Object.entries(this[_retiredUnchanged]).map(([retireFolder, nodes]) => promiseAllRejectLate(nodes.map(node => {\n      const realFolder = realFolders.get(retireFolder);\n      const rel = relative(realFolder, node.path);\n      const fromPath = resolve(retireFolder, rel);\n      return this[_moveContents]({ ...node,\n        path: fromPath\n      }, node.path);\n    })));\n    return promiseAllRejectLate(promises).then(() => this[_rollbackCreateSparseTree](er));\n  }\n\n  [_build]() {\n    process.emit('time', 'reify:build'); // for all the things being installed, run their appropriate scripts\n    // run in tip->root order, so as to be more likely to build a node's\n    // deps before attempting to build it itself\n\n    const nodes = [];\n    dfwalk({\n      tree: this.diff,\n      leave: diff => {\n        if (!diff.ideal.isProjectRoot) nodes.push(diff.ideal);\n      },\n      // process adds before changes, ignore removals\n      getChildren: diff => diff && diff.children,\n      filter: diff => diff.action === 'ADD' || diff.action === 'CHANGE'\n    });\n    return this.rebuild({\n      nodes,\n      handleOptionalFailure: true\n    }).then(() => process.emit('timeEnd', 'reify:build'));\n  } // the tree is pretty much built now, so it's cleanup time.\n  // remove the retired folders, and any deleted nodes\n  // If this fails, there isn't much we can do but tell the user about it.\n  // Thankfully, it's pretty unlikely that it'll fail, since rimraf is a tank.\n\n\n  [_removeTrash]() {\n    process.emit('time', 'reify:trash');\n    const promises = [];\n    const failures = [];\n\n    const rm = path => rimraf(path).catch(er => failures.push([path, er]));\n\n    for (const path of this[_trashList]) promises.push(rm(path));\n\n    return promiseAllRejectLate(promises).then(() => {\n      if (failures.length) this.log.warn('cleanup', 'Failed to remove some directories', failures);\n    }).then(() => process.emit('timeEnd', 'reify:trash'));\n  } // last but not least, we save the ideal tree metadata to the package-lock\n  // or shrinkwrap file, and any additions or removals to package.json\n\n\n  [_saveIdealTree](options) {\n    // the ideal tree is actualized now, hooray!\n    // it still contains all the references to optional nodes that were removed\n    // for install failures.  Those still end up in the shrinkwrap, so we\n    // save it first, then prune out the optional trash, and then return it.\n    // support save=false option\n    if (options.save === false || this[_global] || this[_dryRun]) return;\n    process.emit('time', 'reify:save'); // resolvedAdd is the list of user add requests, but with names added\n    // to things like git repos and tarball file/urls.  However, if the\n    // user requested 'foo@', and we have a foo@file:../foo, then we should\n    // end up saving the spec we actually used, not whatever they gave us.\n\n    if (this[_resolvedAdd].length) {\n      const root = this.idealTree;\n      const pkg = root.package;\n\n      for (const {\n        name\n      } of this[_resolvedAdd]) {\n        const req = npa.resolve(name, root.edgesOut.get(name).spec, root.realpath);\n        const {\n          rawSpec,\n          subSpec\n        } = req;\n        const spec = subSpec ? subSpec.rawSpec : rawSpec;\n        const child = root.children.get(name);\n\n        if (req.registry) {\n          const version = child.version;\n          const prefixRange = version ? this[_savePrefix] + version : '*'; // if we installed a range, then we save the range specified\n          // if it is not a subset of the ^x.y.z.  eg, installing a range\n          // of `1.x <1.2.3` will not be saved as `^1.2.0`, because that\n          // would allow versions outside the requested range.  Tags and\n          // specific versions save with the save-prefix.\n\n          const isRange = (subSpec || req).type === 'range';\n          const range = !isRange || subset(prefixRange, spec, {\n            loose: true\n          }) ? prefixRange : spec;\n          const pname = child.package.name;\n          const alias = name !== pname;\n          updateDepSpec(pkg, name, (alias ? `npm:${pname}@` : '') + range);\n        } else if (req.hosted) {\n          // save the git+https url if it has auth, otherwise shortcut\n          const h = req.hosted;\n          const opt = {\n            noCommittish: false\n          };\n          const save = h.https && h.auth ? `git+${h.https(opt)}` : h.shortcut(opt);\n          updateDepSpec(pkg, name, save);\n        } else if (req.type === 'directory' || req.type === 'file') {\n          // save the relative path in package.json\n          // Normally saveSpec is updated with the proper relative\n          // path already, but it's possible to specify a full absolute\n          // path initially, in which case we can end up with the wrong\n          // thing, so just get the ultimate fetchSpec and relativize it.\n          const p = req.fetchSpec.replace(/^file:/, '');\n          const rel = relpath(root.realpath, p);\n          updateDepSpec(pkg, name, `file:${rel}`);\n        } else updateDepSpec(pkg, name, req.saveSpec);\n      } // refresh the edges so they have the correct specs\n\n\n      this.idealTree.package = pkg;\n    } // preserve indentation, if possible\n\n\n    const {\n      [Symbol.for('indent')]: indent\n    } = this.idealTree.package;\n    const format = indent === undefined ? '  ' : indent;\n    const saveOpt = {\n      format: this[_formatPackageLock] && format ? format : this[_formatPackageLock]\n    };\n    return Promise.all([this[_saveLockFile](saveOpt), updateRootPackageJson(this.idealTree)]).then(() => process.emit('timeEnd', 'reify:save'));\n  }\n\n  async [_saveLockFile](saveOpt) {\n    if (!this[_usePackageLock]) return;\n    const {\n      meta\n    } = this.idealTree; // might have to update metadata for bins and stuff that gets lost\n\n    if (meta.loadedFromDisk && !(meta.originalLockfileVersion >= 2)) {\n      for (const node of this.idealTree.inventory.values()) await this[_loadAncientPackageDetails](node, true);\n    }\n\n    return meta.save(saveOpt);\n  }\n\n  async [_copyIdealToActual]() {\n    // clean up any trash that is still in the tree\n    for (const path of this[_trashList]) {\n      const loc = relpath(this.idealTree.realpath, path);\n      const node = this.idealTree.inventory.get(loc);\n      if (node && node.root === this.idealTree) node.parent = null;\n    } // if we filtered to only certain nodes, then anything ELSE needs\n    // to be untouched in the resulting actual tree, even if it differs\n    // in the idealTree.  Copy over anything that was in the actual and\n    // was not changed, delete anything in the ideal and not actual.\n    // Then we move the entire idealTree over to this.actualTree, and\n    // save the hidden lockfile.\n\n\n    if (this.diff && this.diff.filterSet.size) {\n      const {\n        filterSet\n      } = this.diff;\n      const seen = new Set();\n\n      for (const [loc, ideal] of this.idealTree.inventory.entries()) {\n        if (seen.has(loc)) continue;\n        seen.add(loc); // if it's an ideal node from the filter set, then skip it\n        // because we already made whatever changes were necessary\n\n        if (filterSet.has(ideal)) continue; // otherwise, if it's not in the actualTree, then it's not a thing\n        // that we actually added.  And if it IS in the actualTree, then\n        // it's something that we left untouched, so we need to record\n        // that.\n\n        const actual = this.actualTree.inventory.get(loc);\n        if (!actual) ideal.root = null;else {\n          if ([...actual.linksIn].some(link => filterSet.has(link))) {\n            seen.add(actual.location);\n            continue;\n          }\n\n          const {\n            realpath,\n            isLink\n          } = actual;\n          if (isLink && ideal.isLink && ideal.realpath === realpath) continue;else actual.root = this.idealTree;\n        }\n      } // now find any actual nodes that may not be present in the ideal\n      // tree, but were left behind by virtue of not being in the filter\n\n\n      for (const [loc, actual] of this.actualTree.inventory.entries()) {\n        if (seen.has(loc)) continue;\n        seen.add(loc);\n        if (filterSet.has(actual)) continue;\n        actual.root = this.idealTree;\n      } // prune out any tops that lack a linkIn\n\n\n      for (const top of this.idealTree.tops) {\n        if (top.linksIn.size === 0) top.root = null;\n      } // need to calculate dep flags, since nodes may have been marked\n      // as extraneous or otherwise incorrect during transit.\n\n\n      calcDepFlags(this.idealTree);\n    } // save the ideal's meta as a hidden lockfile after we actualize it\n\n\n    this.idealTree.meta.filename = this.idealTree.realpath + '/node_modules/.package-lock.json';\n    this.idealTree.meta.hiddenLockfile = true;\n    this.actualTree = this.idealTree;\n    this.idealTree = null;\n    if (!this[_global]) await this.actualTree.meta.save();\n  }\n\n};","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/node_modules/@npmcli/arborist/lib/arborist/reify.js"],"names":["onExit","require","pacote","rpj","updateDepSpec","AuditReport","subset","npa","dirname","resolve","relative","depth","dfwalk","fs","promisify","symlink","mkdirp","justMkdirp","moveFile","rimraf","packageContents","checkEngine","checkPlatform","treeCheck","relpath","Diff","retirePath","promiseAllRejectLate","optionalSet","updateRootPackageJson","calcDepFlags","_retiredPaths","Symbol","_retiredUnchanged","_sparseTreeDirs","_sparseTreeRoots","_savePrefix","_retireShallowNodes","for","_getBundlesByDepth","_registryResolved","_addNodeToTrashList","_workspaces","_trashList","_handleOptionalFailure","_loadTrees","_diffTrees","_createSparseTree","_loadShrinkwrapsAndUpdateTrees","_shrinkwrapUnpacked","_reifyNode","_extractOrLink","_checkBins","_symlink","_warnDeprecated","_loadAncientPackageDetails","_loadBundlesAndUpdateTrees","_submitQuickAudit","_awaitQuickAudit","_unpackNewModules","_moveContents","_moveBackRetiredUnchanged","_build","_removeTrash","_renamePath","_rollbackRetireShallowNodes","_rollbackCreateSparseTree","_rollbackMoveBackRetiredUnchanged","_saveIdealTree","_saveLockFile","_copyIdealToActual","_addOmitsToTrashList","_packageLockOnly","_dryRun","_validatePath","_reifyPackages","_omitDev","_omitOptional","_omitPeer","_global","_pruneBundledMetadeps","_resolvedAdd","_usePackageLock","_formatPackageLock","module","exports","cls","Reifier","constructor","options","savePrefix","packageLockOnly","dryRun","formatPackageLock","diff","Set","reify","er","Error","code","omit","has","addTracker","process","emit","then","finishTracker","actualTree","path","reifyTerminated","removeHandler","signal","Object","assign","steps","rollback","actions","action","bitOpt","complete","buildIdealTree","actualOpt","ignoreMissing","global","filter","node","kid","explicitRequests","size","isProjectRoot","idealTree","edgesOut","hasExplicit","some","edge","name","Promise","all","loadActual","filterNodes","target","ideal","children","get","push","actual","ws","calculate","removed","inDepBundle","retire","paths","binPaths","moves","log","silly","retired","add","movePromises","entries","map","from","to","didMkdirp","catch","peer","dev","optional","devOptional","inventory","dirs","leaves","d","made","forEach","dir","roots","failures","targets","keys","unlinks","length","warn","seen","shrinkwraps","hasShrinkwrap","Arborist","nodes","loadVirtual","root","timer","location","npmVersion","nodeVersion","p","package","res","resolved","version","warning","verbose","parent","fsParent","isLink","extract","integrity","realpath","rel","_id","deprecated","forceReload","meta","ancient","ancientLockfile","old","loadedFromDisk","originalLockfileVersion","pkg","err","bin","os","cpu","engines","set","replace","registry","bundlesByDepth","maxBundleDepth","transplantFilter","Map","tree","visit","bundleDependencies","Math","max","getChildren","bundleShadowed","bundles","values","Array","isArray","shadow","extraneous","changed","delete","edgesIn","shadDep","audit","auditReport","load","unpacks","bd","sw","doUnpack","isRoot","realFolder","retireFolder","unchanged","fromPath","packageJsonCache","realFolders","k","v","promises","leave","rebuild","handleOptionalFailure","rm","save","req","spec","rawSpec","subSpec","child","prefixRange","isRange","type","range","loose","pname","alias","hosted","h","opt","noCommittish","https","auth","shortcut","fetchSpec","saveSpec","indent","format","undefined","saveOpt","loc","filterSet","linksIn","link","top","tops","filename","hiddenLockfile"],"mappings":"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","sourcesContent":["// mixin implementing the reify method\n\nconst onExit = require('../signal-handling.js')\nconst pacote = require('pacote')\nconst rpj = require('read-package-json-fast')\nconst { updateDepSpec } = require('../dep-spec.js')\nconst AuditReport = require('../audit-report.js')\nconst {subset} = require('semver')\nconst npa = require('npm-package-arg')\n\nconst {dirname, resolve, relative} = require('path')\nconst {depth: dfwalk} = require('treeverse')\nconst fs = require('fs')\nconst {promisify} = require('util')\nconst symlink = promisify(fs.symlink)\nconst mkdirp = require('mkdirp-infer-owner')\nconst justMkdirp = require('mkdirp')\nconst moveFile = require('@npmcli/move-file')\nconst rimraf = promisify(require('rimraf'))\nconst packageContents = require('@npmcli/installed-package-contents')\nconst { checkEngine, checkPlatform } = require('npm-install-checks')\n\nconst treeCheck = require('../tree-check.js')\nconst relpath = require('../relpath.js')\nconst Diff = require('../diff.js')\nconst retirePath = require('../retire-path.js')\nconst promiseAllRejectLate = require('promise-all-reject-late')\nconst optionalSet = require('../optional-set.js')\nconst updateRootPackageJson = require('../update-root-package-json.js')\nconst calcDepFlags = require('../calc-dep-flags.js')\n\nconst _retiredPaths = Symbol('retiredPaths')\nconst _retiredUnchanged = Symbol('retiredUnchanged')\nconst _sparseTreeDirs = Symbol('sparseTreeDirs')\nconst _sparseTreeRoots = Symbol('sparseTreeRoots')\nconst _savePrefix = Symbol('savePrefix')\nconst _retireShallowNodes = Symbol.for('retireShallowNodes')\nconst _getBundlesByDepth = Symbol('getBundlesByDepth')\nconst _registryResolved = Symbol('registryResolved')\nconst _addNodeToTrashList = Symbol('addNodeToTrashList')\nconst _workspaces = Symbol.for('workspaces')\n\n// shared by rebuild mixin\nconst _trashList = Symbol.for('trashList')\nconst _handleOptionalFailure = Symbol.for('handleOptionalFailure')\nconst _loadTrees = Symbol.for('loadTrees')\n\n// shared symbols for swapping out when testing\nconst _diffTrees = Symbol.for('diffTrees')\nconst _createSparseTree = Symbol.for('createSparseTree')\nconst _loadShrinkwrapsAndUpdateTrees = Symbol.for('loadShrinkwrapsAndUpdateTrees')\nconst _shrinkwrapUnpacked = Symbol('shrinkwrapUnpacked')\nconst _reifyNode = Symbol.for('reifyNode')\nconst _extractOrLink = Symbol('extractOrLink')\n// defined by rebuild mixin\nconst _checkBins = Symbol.for('checkBins')\nconst _symlink = Symbol('symlink')\nconst _warnDeprecated = Symbol('warnDeprecated')\nconst _loadAncientPackageDetails = Symbol('loadAncientPackageDetails')\nconst _loadBundlesAndUpdateTrees = Symbol.for('loadBundlesAndUpdateTrees')\nconst _submitQuickAudit = Symbol('submitQuickAudit')\nconst _awaitQuickAudit = Symbol('awaitQuickAudit')\nconst _unpackNewModules = Symbol.for('unpackNewModules')\nconst _moveContents = Symbol.for('moveContents')\nconst _moveBackRetiredUnchanged = Symbol.for('moveBackRetiredUnchanged')\nconst _build = Symbol.for('build')\nconst _removeTrash = Symbol.for('removeTrash')\nconst _renamePath = Symbol.for('renamePath')\nconst _rollbackRetireShallowNodes = Symbol.for('rollbackRetireShallowNodes')\nconst _rollbackCreateSparseTree = Symbol.for('rollbackCreateSparseTree')\nconst _rollbackMoveBackRetiredUnchanged = Symbol.for('rollbackMoveBackRetiredUnchanged')\nconst _saveIdealTree = Symbol.for('saveIdealTree')\nconst _saveLockFile = Symbol('saveLockFile')\nconst _copyIdealToActual = Symbol('copyIdealToActual')\nconst _addOmitsToTrashList = Symbol('addOmitsToTrashList')\nconst _packageLockOnly = Symbol('packageLockOnly')\nconst _dryRun = Symbol('dryRun')\nconst _validatePath = Symbol('validatePath')\nconst _reifyPackages = Symbol('reifyPackages')\n\nconst _omitDev = Symbol('omitDev')\nconst _omitOptional = Symbol('omitOptional')\nconst _omitPeer = Symbol('omitPeer')\n\nconst _global = Symbol.for('global')\n\n// defined by Ideal mixin\nconst _pruneBundledMetadeps = Symbol.for('pruneBundledMetadeps')\nconst _resolvedAdd = Symbol.for('resolvedAdd')\nconst _usePackageLock = Symbol.for('usePackageLock')\nconst _formatPackageLock = Symbol.for('formatPackageLock')\n\nmodule.exports = cls => class Reifier extends cls {\n  constructor (options) {\n    super(options)\n\n    const {\n      savePrefix = '^',\n      packageLockOnly = false,\n      dryRun = false,\n      formatPackageLock = true,\n    } = options\n\n    this[_dryRun] = !!dryRun\n    this[_packageLockOnly] = !!packageLockOnly\n    this[_savePrefix] = savePrefix\n    this[_formatPackageLock] = !!formatPackageLock\n\n    this.diff = null\n    this[_retiredPaths] = {}\n    this[_shrinkwrapUnpacked] = new Set()\n    this[_retiredUnchanged] = {}\n    this[_sparseTreeDirs] = new Set()\n    this[_sparseTreeRoots] = new Set()\n    this[_trashList] = new Set()\n  }\n\n  // public method\n  async reify (options = {}) {\n    if (this[_packageLockOnly] && this[_global]) {\n      const er = new Error('cannot generate lockfile for global packages')\n      er.code = 'ESHRINKWRAPGLOBAL'\n      throw er\n    }\n\n    const omit = new Set(options.omit || [])\n    this[_omitDev] = omit.has('dev')\n    this[_omitOptional] = omit.has('optional')\n    this[_omitPeer] = omit.has('peer')\n\n    // start tracker block\n    this.addTracker('reify')\n    process.emit('time', 'reify')\n    await this[_validatePath]()\n      .then(() => this[_loadTrees](options))\n      .then(() => this[_diffTrees]())\n      .then(() => this[_reifyPackages]())\n      .then(() => this[_saveIdealTree](options))\n      .then(() => this[_copyIdealToActual]())\n      .then(() => this[_awaitQuickAudit]())\n\n    this.finishTracker('reify')\n    process.emit('timeEnd', 'reify')\n    return treeCheck(this.actualTree)\n  }\n\n  async [_validatePath] () {\n    // don't create missing dirs on dry runs\n    if (this[_packageLockOnly] || this[_dryRun])\n      return\n\n    // we do NOT want to set ownership on this folder, especially\n    // recursively, because it can have other side effects to do that\n    // in a project directory.  We just want to make it if it's missing.\n    await justMkdirp(resolve(this.path))\n  }\n\n  async [_reifyPackages] () {\n    // we don't submit the audit report or write to disk on dry runs\n    if (this[_dryRun])\n      return\n\n    if (this[_packageLockOnly]) {\n      // we already have the complete tree, so just audit it now,\n      // and that's all we have to do here.\n      return this[_submitQuickAudit]()\n    }\n\n    // ok, we're about to start touching the fs.  need to roll back\n    // if we get an early termination.\n    let reifyTerminated = null\n    const removeHandler = onExit(({signal}) => {\n      // only call once.  if signal hits twice, we just terminate\n      removeHandler()\n      reifyTerminated = Object.assign(new Error('process terminated'), {\n        signal,\n      })\n      return false\n    })\n\n    // [rollbackfn, [...actions]]\n    // after each step, if the process was terminated, execute the rollback\n    // note that each rollback *also* calls the previous one when it's\n    // finished, and then the first one throws the error, so we only need\n    // a new rollback step when we have a new thing that must be done to\n    // revert the install.\n    const steps = [\n      [_rollbackRetireShallowNodes, [\n        _retireShallowNodes,\n      ]],\n      [_rollbackCreateSparseTree, [\n        _createSparseTree,\n        _addOmitsToTrashList,\n        _loadShrinkwrapsAndUpdateTrees,\n        _loadBundlesAndUpdateTrees,\n        _submitQuickAudit,\n        _unpackNewModules,\n      ]],\n      [_rollbackMoveBackRetiredUnchanged, [\n        _moveBackRetiredUnchanged,\n        _build,\n      ]],\n    ]\n    for (const [rollback, actions] of steps) {\n      for (const action of actions) {\n        try {\n          await this[action]()\n          if (reifyTerminated)\n            throw reifyTerminated\n        } catch (er) {\n          await this[rollback](er)\n          /* istanbul ignore next - rollback throws, should never hit this */\n          throw er\n        }\n      }\n    }\n\n    // no rollback for this one, just exit with the error, since the\n    // install completed and can't be safely recovered at this point.\n    await this[_removeTrash]()\n    if (reifyTerminated)\n      throw reifyTerminated\n\n    // done modifying the file system, no need to keep listening for sigs\n    removeHandler()\n  }\n\n  // when doing a local install, we load everything and figure it all out.\n  // when doing a global install, we *only* care about the explicit requests.\n  [_loadTrees] (options) {\n    process.emit('time', 'reify:loadTrees')\n    const bitOpt = {\n      ...options,\n      complete: this[_packageLockOnly] || this[_dryRun],\n    }\n\n    // if we're only writing a package lock, then it doesn't matter what's here\n    if (this[_packageLockOnly]) {\n      return this.buildIdealTree(bitOpt)\n        .then(() => process.emit('timeEnd', 'reify:loadTrees'))\n    }\n\n    const actualOpt = this[_global] ? {\n      ignoreMissing: true,\n      global: true,\n      filter: (node, kid) => {\n        // if it's not the project root, and we have no explicit requests,\n        // then we're already into a nested dep, so we keep it\n        if (this.explicitRequests.size === 0 || !node.isProjectRoot)\n          return true\n\n        // if we added it as an edgeOut, then we want it\n        if (this.idealTree.edgesOut.has(kid))\n          return true\n\n        // if it's an explicit request, then we want it\n        const hasExplicit = [...this.explicitRequests]\n          .some(edge => edge.name === kid)\n        if (hasExplicit)\n          return true\n\n        // ignore the rest of the global install folder\n        return false\n      },\n    } : { ignoreMissing: true }\n\n    if (!this[_global]) {\n      return Promise.all([this.loadActual(actualOpt), this.buildIdealTree(bitOpt)])\n        .then(() => process.emit('timeEnd', 'reify:loadTrees'))\n    }\n\n    // the global install space tends to have a lot of stuff in it.  don't\n    // load all of it, just what we care about.  we won't be saving a\n    // hidden lockfile in there anyway.  Note that we have to load ideal\n    // BEFORE loading actual, so that the actualOpt can use the\n    // explicitRequests which is set during buildIdealTree\n    return this.buildIdealTree(bitOpt)\n      .then(() => this.loadActual(actualOpt))\n      .then(() => process.emit('timeEnd', 'reify:loadTrees'))\n  }\n\n  [_diffTrees] () {\n    if (this[_packageLockOnly])\n      return\n\n    process.emit('time', 'reify:diffTrees')\n    // XXX if we have an existing diff already, there should be a way\n    // to just invalidate the parts that changed, but avoid walking the\n    // whole tree again.\n\n    const filterNodes = []\n    if (this[_global] && this.explicitRequests.size) {\n      const idealTree = this.idealTree.target || this.idealTree\n      const actualTree = this.actualTree.target || this.actualTree\n      // we ONLY are allowed to make changes in the global top-level\n      // children where there's an explicit request.\n      for (const { name } of this.explicitRequests) {\n        const ideal = idealTree.children.get(name)\n        if (ideal)\n          filterNodes.push(ideal)\n        const actual = actualTree.children.get(name)\n        if (actual)\n          filterNodes.push(actual)\n      }\n    } else {\n      for (const ws of this[_workspaces]) {\n        const ideal = this.idealTree.children.get(ws)\n        if (ideal)\n          filterNodes.push(ideal)\n        const actual = this.actualTree.children.get(ws)\n        if (actual)\n          filterNodes.push(actual)\n      }\n    }\n\n    // find all the nodes that need to change between the actual\n    // and ideal trees.\n    this.diff = Diff.calculate({\n      filterNodes,\n      actual: this.actualTree,\n      ideal: this.idealTree,\n    })\n\n    for (const node of this.diff.removed) {\n      // a node in a dep bundle will only be removed if its bundling dep\n      // is removed as well.  in which case, we don't have to delete it!\n      if (!node.inDepBundle)\n        this[_addNodeToTrashList](node)\n    }\n    process.emit('timeEnd', 'reify:diffTrees')\n  }\n\n  // add the node and all its bins to the list of things to be\n  // removed later on in the process.  optionally, also mark them\n  // as a retired paths, so that we move them out of the way and\n  // replace them when rolling back on failure.\n  [_addNodeToTrashList] (node, retire) {\n    const paths = [node.path, ...node.binPaths]\n    const moves = this[_retiredPaths]\n    this.log.silly('reify', 'mark', retire ? 'retired' : 'deleted', paths)\n    for (const path of paths) {\n      if (retire) {\n        const retired = retirePath(path)\n        moves[path] = retired\n        this[_trashList].add(retired)\n      } else\n        this[_trashList].add(path)\n    }\n  }\n\n  // move aside the shallowest nodes in the tree that have to be\n  // changed or removed, so that we can rollback if necessary.\n  [_retireShallowNodes] () {\n    process.emit('time', 'reify:retireShallow')\n    const moves = this[_retiredPaths] = {}\n    for (const diff of this.diff.children) {\n      if (diff.action === 'CHANGE' || diff.action === 'REMOVE') {\n        // we'll have to clean these up at the end, so add them to the list\n        this[_addNodeToTrashList](diff.actual, true)\n      }\n    }\n    this.log.silly('reify', 'moves', moves)\n    const movePromises = Object.entries(moves)\n      .map(([from, to]) => this[_renamePath](from, to))\n    return promiseAllRejectLate(movePromises)\n      .then(() => process.emit('timeEnd', 'reify:retireShallow'))\n  }\n\n  [_renamePath] (from, to, didMkdirp = false) {\n    return moveFile(from, to)\n      .catch(er => {\n        // Occasionally an expected bin file might not exist in the package,\n        // or a shim/symlink might have been moved aside.  If we've already\n        // handled the most common cause of ENOENT (dir doesn't exist yet),\n        // then just ignore any ENOENT.\n        if (er.code === 'ENOENT') {\n          return didMkdirp ? null : mkdirp(dirname(to)).then(() =>\n            this[_renamePath](from, to, true))\n        } else if (er.code === 'EEXIST')\n          return rimraf(to).then(() => moveFile(from, to))\n        else\n          throw er\n      })\n  }\n\n  [_rollbackRetireShallowNodes] (er) {\n    process.emit('time', 'reify:rollback:retireShallow')\n    const moves = this[_retiredPaths]\n    const movePromises = Object.entries(moves)\n      .map(([from, to]) => this[_renamePath](to, from))\n    return promiseAllRejectLate(movePromises)\n      // ignore subsequent rollback errors\n      .catch(er => {})\n      .then(() => process.emit('timeEnd', 'reify:rollback:retireShallow'))\n      .then(() => {\n        throw er\n      })\n  }\n\n  // adding to the trash list will skip reifying, and delete them\n  // if they are currently in the tree and otherwise untouched.\n  [_addOmitsToTrashList] () {\n    if (!this[_omitDev] && !this[_omitOptional] && !this[_omitPeer])\n      return\n\n    process.emit('time', 'reify:trashOmits')\n    const filter = node =>\n      node.peer && this[_omitPeer] ||\n      node.dev && this[_omitDev] ||\n      node.optional && this[_omitOptional] ||\n      node.devOptional && this[_omitOptional] && this[_omitDev]\n\n    for (const node of this.idealTree.inventory.filter(filter))\n      this[_addNodeToTrashList](node)\n\n    process.emit('timeEnd', 'reify:trashOmits')\n  }\n\n  [_createSparseTree] () {\n    process.emit('time', 'reify:createSparse')\n    // if we call this fn again, we look for the previous list\n    // so that we can avoid making the same directory multiple times\n    const dirs = this.diff.leaves\n      .filter(diff => {\n        return (diff.action === 'ADD' || diff.action === 'CHANGE') &&\n          !this[_sparseTreeDirs].has(diff.ideal.path)\n      })\n      .map(diff => diff.ideal.path)\n\n    return promiseAllRejectLate(dirs.map(d => mkdirp(d)))\n      .then(made => {\n        made.forEach(made => this[_sparseTreeRoots].add(made))\n        dirs.forEach(dir => this[_sparseTreeDirs].add(dir))\n      })\n      .then(() => process.emit('timeEnd', 'reify:createSparse'))\n  }\n\n  [_rollbackCreateSparseTree] (er) {\n    process.emit('time', 'reify:rollback:createSparse')\n    // cut the roots of the sparse tree that were created, not the leaves\n    const roots = this[_sparseTreeRoots]\n    // also delete the moves that we retired, so that we can move them back\n    const failures = []\n    const targets = [...roots, ...Object.keys(this[_retiredPaths])]\n    const unlinks = targets\n      .map(path => rimraf(path).catch(er => failures.push([path, er])))\n    return promiseAllRejectLate(unlinks)\n      .then(() => {\n        if (failures.length)\n          this.log.warn('cleanup', 'Failed to remove some directories', failures)\n      })\n      .then(() => process.emit('timeEnd', 'reify:rollback:createSparse'))\n      .then(() => this[_rollbackRetireShallowNodes](er))\n  }\n\n  // shrinkwrap nodes define their dependency branches with a file, so\n  // we need to unpack them, read that shrinkwrap file, and then update\n  // the tree by calling loadVirtual with the node as the root.\n  [_loadShrinkwrapsAndUpdateTrees] () {\n    const seen = this[_shrinkwrapUnpacked]\n    const shrinkwraps = this.diff.leaves\n      .filter(d => (d.action === 'CHANGE' || d.action === 'ADD') &&\n        d.ideal.hasShrinkwrap && !seen.has(d.ideal) &&\n        !this[_trashList].has(d.ideal.path))\n\n    if (!shrinkwraps.length)\n      return\n\n    process.emit('time', 'reify:loadShrinkwraps')\n\n    const Arborist = this.constructor\n    return promiseAllRejectLate(shrinkwraps.map(diff => {\n      const node = diff.ideal\n      seen.add(node)\n      return this[_reifyNode](node)\n    }))\n      .then(nodes => promiseAllRejectLate(nodes.map(node => new Arborist({\n        ...this.options,\n        path: node.path,\n      }).loadVirtual({ root: node }))))\n      // reload the diff and sparse tree because the ideal tree changed\n      .then(() => this[_diffTrees]())\n      .then(() => this[_createSparseTree]())\n      .then(() => this[_addOmitsToTrashList]())\n      .then(() => this[_loadShrinkwrapsAndUpdateTrees]())\n      .then(() => process.emit('timeEnd', 'reify:loadShrinkwraps'))\n  }\n\n  // create a symlink for Links, extract for Nodes\n  // return the node object, since we usually want that\n  // handle optional dep failures here\n  // If node is in trash list, skip it\n  // If reifying fails, and the node is optional, add it and its optionalSet\n  // to the trash list\n  // Always return the node.\n  [_reifyNode] (node) {\n    if (this[_trashList].has(node.path))\n      return node\n\n    const timer = `reifyNode:${node.location}`\n    process.emit('time', timer)\n    this.addTracker('reify', node.name, node.location)\n\n    const { npmVersion, nodeVersion } = this.options\n    const p = Promise.resolve()\n      .then(() => {\n        // when we reify an optional node, check the engine and platform\n        // first. be sure to ignore the --force and --engine-strict flags,\n        // since we always want to skip any optional packages we can't install.\n        // these checks throwing will result in a rollback and removal\n        // of the mismatches\n        if (node.optional) {\n          checkEngine(node.package, npmVersion, nodeVersion, false)\n          checkPlatform(node.package, false)\n        }\n      })\n      .then(() => this[_checkBins](node))\n      .then(() => this[_extractOrLink](node))\n      .then(() => this[_warnDeprecated](node))\n      .then(() => this[_loadAncientPackageDetails](node))\n\n    return this[_handleOptionalFailure](node, p)\n      .then(() => {\n        this.finishTracker('reify', node.name, node.location)\n        process.emit('timeEnd', timer)\n        return node\n      })\n  }\n\n  [_extractOrLink] (node) {\n    // in normal cases, node.resolved should *always* be set by now.\n    // however, it is possible when a lockfile is damaged, or very old,\n    // or in some other race condition bugs in npm v6, that a previously\n    // bundled dependency will have just a version, but no resolved value,\n    // and no 'bundled: true' setting.\n    // Do the best with what we have, or else remove it from the tree\n    // entirely, since we can't possibly reify it.\n    const res = node.resolved ? `${node.name}@${this[_registryResolved](node.resolved)}`\n      : node.package.name && node.version\n        ? `${node.package.name}@${node.version}`\n        : null\n\n    // no idea what this thing is.  remove it from the tree.\n    if (!res) {\n      const warning = 'invalid or damaged lockfile detected\\n' +\n        'please re-try this operation once it completes\\n' +\n        'so that the damage can be corrected, or perform\\n' +\n        'a fresh install with no lockfile if the problem persists.'\n      this.log.warn('reify', warning)\n      this.log.verbose('reify', 'unrecognized node in tree', node.path)\n      node.parent = null\n      node.fsParent = null\n      this[_addNodeToTrashList](node)\n      return\n    }\n\n    return node.isLink\n      ? rimraf(node.path).then(() => this[_symlink](node))\n      : pacote.extract(res, node.path, {\n        ...this.options,\n        resolved: node.resolved,\n        integrity: node.integrity,\n      })\n  }\n\n  [_symlink] (node) {\n    const dir = dirname(node.path)\n    const target = node.realpath\n    const rel = relative(dir, target)\n    return symlink(rel, node.path, 'junction')\n  }\n\n  [_warnDeprecated] (node) {\n    const {_id, deprecated} = node.package\n    if (deprecated)\n      this.log.warn('deprecated', `${_id}: ${deprecated}`)\n  }\n\n  async [_loadAncientPackageDetails] (node, forceReload = false) {\n    // If we're loading from a v1 lockfile, load details from the package.json\n    // that weren't recorded in the old format.\n    const {meta} = this.idealTree\n    const ancient = meta.ancientLockfile\n    const old = meta.loadedFromDisk && !(meta.originalLockfileVersion >= 2)\n\n    // already replaced with the manifest if it's truly ancient\n    if (node.path && (forceReload || (old && !ancient))) {\n      // XXX should have a shared location where package.json is read,\n      // so we don't ever read the same pj more than necessary.\n      let pkg\n      try {\n        pkg = await rpj(node.path + '/package.json')\n      } catch (err) {}\n\n      if (pkg) {\n        node.package.bin = pkg.bin\n        node.package.os = pkg.os\n        node.package.cpu = pkg.cpu\n        node.package.engines = pkg.engines\n        meta.add(node)\n      }\n    }\n  }\n\n  // if the node is optional, then the failure of the promise is nonfatal\n  // just add it and its optional set to the trash list.\n  [_handleOptionalFailure] (node, p) {\n    return (node.optional ? p.catch(er => {\n      const set = optionalSet(node)\n      for (node of set) {\n        this.log.verbose('reify', 'failed optional dependency', node.path)\n        this[_addNodeToTrashList](node)\n      }\n    }) : p).then(() => node)\n  }\n\n  [_registryResolved] (resolved) {\n    // the default registry url is a magic value meaning \"the currently\n    // configured registry\".\n    //\n    // XXX: use a magic string that isn't also a valid value, like\n    // ${REGISTRY} or something.  This has to be threaded through the\n    // Shrinkwrap and Node classes carefully, so for now, just treat\n    // the default reg as the magical animal that it has been.\n    return resolved && resolved\n      .replace(/^https?:\\/\\/registry.npmjs.org\\//, this.registry)\n  }\n\n  // bundles are *sort of* like shrinkwraps, in that the branch is defined\n  // by the contents of the package.  however, in their case, rather than\n  // shipping a virtual tree that must be reified, they ship an entire\n  // reified actual tree that must be unpacked and not modified.\n  [_loadBundlesAndUpdateTrees] (\n    depth = 0, bundlesByDepth = this[_getBundlesByDepth]()\n  ) {\n    if (depth === 0)\n      process.emit('time', 'reify:loadBundles')\n    const maxBundleDepth = bundlesByDepth.get('maxBundleDepth')\n    if (depth > maxBundleDepth) {\n      // if we did something, then prune the tree and update the diffs\n      if (maxBundleDepth !== -1) {\n        this[_pruneBundledMetadeps](bundlesByDepth)\n        this[_diffTrees]()\n      }\n      process.emit('timeEnd', 'reify:loadBundles')\n      return\n    }\n\n    // skip any that have since been removed from the tree, eg by a\n    // shallower bundle overwriting them with a bundled meta-dep.\n    const set = (bundlesByDepth.get(depth) || [])\n      .filter(node => node.root === this.idealTree &&\n        !this[_trashList].has(node.path))\n\n    if (!set.length)\n      return this[_loadBundlesAndUpdateTrees](depth + 1, bundlesByDepth)\n\n    // extract all the nodes with bundles\n    return promiseAllRejectLate(set.map(node => this[_reifyNode](node)))\n    // then load their unpacked children and move into the ideal tree\n      .then(nodes =>\n        promiseAllRejectLate(nodes.map(node => new this.constructor({\n          ...this.options,\n          path: node.path,\n        }).loadActual({\n          root: node,\n          // don't transplant any sparse folders we created\n          transplantFilter: node => node.package._id,\n        }))))\n    // move onto the next level of bundled items\n      .then(() => this[_loadBundlesAndUpdateTrees](depth + 1, bundlesByDepth))\n  }\n\n  [_getBundlesByDepth] () {\n    const bundlesByDepth = new Map()\n    let maxBundleDepth = -1\n    dfwalk({\n      tree: this.diff,\n      visit: diff => {\n        const node = diff.ideal\n        if (node && !node.isProjectRoot && node.package.bundleDependencies &&\n            node.package.bundleDependencies.length) {\n          maxBundleDepth = Math.max(maxBundleDepth, node.depth)\n          if (!bundlesByDepth.has(node.depth))\n            bundlesByDepth.set(node.depth, [node])\n          else\n            bundlesByDepth.get(node.depth).push(node)\n        }\n      },\n      getChildren: diff => diff.children,\n    })\n\n    bundlesByDepth.set('maxBundleDepth', maxBundleDepth)\n    return bundlesByDepth\n  }\n\n  // https://github.com/npm/cli/issues/1597#issuecomment-667639545\n  [_pruneBundledMetadeps] (bundlesByDepth) {\n    const bundleShadowed = new Set()\n    // create the list of nodes shadowed by children of bundlers\n    for (const bundles of bundlesByDepth.values()) {\n      // skip the 'maxBundleDepth' item\n      if (!Array.isArray(bundles))\n        continue\n      for (const node of bundles) {\n        for (const name of node.children.keys()) {\n          const shadow = node.parent.resolve(name)\n          if (!shadow)\n            continue\n          bundleShadowed.add(shadow)\n          shadow.extraneous = true\n        }\n      }\n    }\n    let changed = true\n    while (changed) {\n      changed = false\n      for (const shadow of bundleShadowed) {\n        if (!shadow.extraneous) {\n          bundleShadowed.delete(shadow)\n          continue\n        }\n\n        for (const edge of shadow.edgesIn) {\n          if (!edge.from.extraneous) {\n            shadow.extraneous = false\n            bundleShadowed.delete(shadow)\n            changed = true\n          } else {\n            for (const shadDep of shadow.edgesOut.values()) {\n              /* istanbul ignore else - pretty unusual situation, just being\n               * defensive here. Would mean that a bundled dep has a dependency\n               * that is unmet. which, weird, but if you bundle it, we take\n               * whatever you put there and assume the publisher knows best. */\n              if (shadDep.to)\n                bundleShadowed.add(shadDep.to)\n            }\n          }\n        }\n      }\n    }\n    for (const shadow of bundleShadowed) {\n      shadow.parent = null\n      this[_addNodeToTrashList](shadow)\n    }\n  }\n\n  [_submitQuickAudit] () {\n    if (this.options.audit === false)\n      return this.auditReport = null\n\n    // we submit the quick audit at this point in the process, as soon as\n    // we have all the deps resolved, so that it can overlap with the other\n    // actions as much as possible.  Stash the promise, which we resolve\n    // before finishing the reify() and returning the tree.  Thus, we do\n    // NOT return the promise, as the intent is for this to run in parallel\n    // with the reification, and be resolved at a later time.\n    process.emit('time', 'reify:audit')\n\n    this.auditReport = AuditReport.load(this.idealTree, this.options)\n      .then(res => {\n        process.emit('timeEnd', 'reify:audit')\n        this.auditReport = res\n      })\n  }\n\n  // return the promise if we're waiting for it, or the replaced result\n  [_awaitQuickAudit] () {\n    return this.auditReport\n  }\n\n  // ok!  actually unpack stuff into their target locations!\n  // The sparse tree has already been created, so we walk the diff\n  // kicking off each unpack job.  If any fail, we rimraf the sparse\n  // tree entirely and try to put everything back where it was.\n  [_unpackNewModules] () {\n    process.emit('time', 'reify:unpack')\n    const unpacks = []\n    dfwalk({\n      tree: this.diff,\n      visit: diff => {\n        // no unpacking if we don't want to change this thing\n        if (diff.action !== 'CHANGE' && diff.action !== 'ADD')\n          return\n\n        const node = diff.ideal\n        const bd = node.package.bundleDependencies\n        const sw = this[_shrinkwrapUnpacked].has(node)\n\n        // check whether we still need to unpack this one.\n        // test the inDepBundle last, since that's potentially a tree walk.\n        const doUnpack = node && // can't unpack if removed!\n          !node.isRoot && // root node already exists\n          !(bd && bd.length) && // already unpacked to read bundle\n          !sw && // already unpacked to read sw\n          !node.inDepBundle // already unpacked by another dep's bundle\n\n        if (doUnpack)\n          unpacks.push(this[_reifyNode](node))\n      },\n      getChildren: diff => diff.children,\n    })\n    return promiseAllRejectLate(unpacks)\n      .then(() => process.emit('timeEnd', 'reify:unpack'))\n  }\n\n  // This is the part where we move back the unchanging nodes that were\n  // the children of a node that did change.  If this fails, the rollback\n  // is a three-step process.  First, we try to move the retired unchanged\n  // nodes BACK to their retirement folders, then delete the sparse tree,\n  // then move everything out of retirement.\n  [_moveBackRetiredUnchanged] () {\n    // get a list of all unchanging children of any shallow retired nodes\n    // if they are not the ancestor of any node in the diff set, then the\n    // directory won't already exist, so just rename it over.\n    // This is sort of an inverse diff tree, of all the nodes where\n    // the actualTree and idealTree _don't_ differ, starting from the\n    // shallowest nodes that we moved aside in the first place.\n    process.emit('time', 'reify:unretire')\n    const moves = this[_retiredPaths]\n    this[_retiredUnchanged] = {}\n    return promiseAllRejectLate(this.diff.children.map(diff => {\n      const realFolder = (diff.actual || diff.ideal).path\n      const retireFolder = moves[realFolder]\n      this[_retiredUnchanged][retireFolder] = []\n      return promiseAllRejectLate(diff.unchanged.map(node => {\n        // no need to roll back links, since we'll just delete them anyway\n        if (node.isLink)\n          return mkdirp(dirname(node.path)).then(() => this[_reifyNode](node))\n\n        // will have been moved/unpacked along with bundler\n        if (node.inDepBundle)\n          return\n\n        this[_retiredUnchanged][retireFolder].push(node)\n\n        const rel = relative(realFolder, node.path)\n        const fromPath = resolve(retireFolder, rel)\n        // if it has bundleDependencies, then make node_modules.  otherwise\n        // skip it.\n        const bd = node.package.bundleDependencies\n        const dir = bd && bd.length ? node.path + '/node_modules' : node.path\n        return mkdirp(dir).then(() => this[_moveContents](node, fromPath))\n      }))\n    }))\n      .then(() => process.emit('timeEnd', 'reify:unretire'))\n  }\n\n  // move the contents from the fromPath to the node.path\n  [_moveContents] (node, fromPath) {\n    return packageContents({\n      path: fromPath,\n      depth: 1,\n      packageJsonCache: new Map([[fromPath + '/package.json', node.package]]),\n    }).then(res => promiseAllRejectLate(res.map(path => {\n      const rel = relative(fromPath, path)\n      const to = resolve(node.path, rel)\n      return this[_renamePath](path, to)\n    })))\n  }\n\n  [_rollbackMoveBackRetiredUnchanged] (er) {\n    const moves = this[_retiredPaths]\n    // flip the mapping around to go back\n    const realFolders = new Map(Object.entries(moves).map(([k, v]) => [v, k]))\n    const promises = Object.entries(this[_retiredUnchanged])\n      .map(([retireFolder, nodes]) => promiseAllRejectLate(nodes.map(node => {\n        const realFolder = realFolders.get(retireFolder)\n        const rel = relative(realFolder, node.path)\n        const fromPath = resolve(retireFolder, rel)\n        return this[_moveContents]({ ...node, path: fromPath }, node.path)\n      })))\n    return promiseAllRejectLate(promises)\n      .then(() => this[_rollbackCreateSparseTree](er))\n  }\n\n  [_build] () {\n    process.emit('time', 'reify:build')\n\n    // for all the things being installed, run their appropriate scripts\n    // run in tip->root order, so as to be more likely to build a node's\n    // deps before attempting to build it itself\n    const nodes = []\n    dfwalk({\n      tree: this.diff,\n      leave: diff => {\n        if (!diff.ideal.isProjectRoot)\n          nodes.push(diff.ideal)\n      },\n      // process adds before changes, ignore removals\n      getChildren: diff => diff && diff.children,\n      filter: diff => diff.action === 'ADD' || diff.action === 'CHANGE',\n    })\n\n    return this.rebuild({ nodes, handleOptionalFailure: true })\n      .then(() => process.emit('timeEnd', 'reify:build'))\n  }\n\n  // the tree is pretty much built now, so it's cleanup time.\n  // remove the retired folders, and any deleted nodes\n  // If this fails, there isn't much we can do but tell the user about it.\n  // Thankfully, it's pretty unlikely that it'll fail, since rimraf is a tank.\n  [_removeTrash] () {\n    process.emit('time', 'reify:trash')\n    const promises = []\n    const failures = []\n    const rm = path => rimraf(path).catch(er => failures.push([path, er]))\n\n    for (const path of this[_trashList])\n      promises.push(rm(path))\n\n    return promiseAllRejectLate(promises).then(() => {\n      if (failures.length)\n        this.log.warn('cleanup', 'Failed to remove some directories', failures)\n    })\n      .then(() => process.emit('timeEnd', 'reify:trash'))\n  }\n\n  // last but not least, we save the ideal tree metadata to the package-lock\n  // or shrinkwrap file, and any additions or removals to package.json\n  [_saveIdealTree] (options) {\n    // the ideal tree is actualized now, hooray!\n    // it still contains all the references to optional nodes that were removed\n    // for install failures.  Those still end up in the shrinkwrap, so we\n    // save it first, then prune out the optional trash, and then return it.\n\n    // support save=false option\n    if (options.save === false || this[_global] || this[_dryRun])\n      return\n\n    process.emit('time', 'reify:save')\n\n    // resolvedAdd is the list of user add requests, but with names added\n    // to things like git repos and tarball file/urls.  However, if the\n    // user requested 'foo@', and we have a foo@file:../foo, then we should\n    // end up saving the spec we actually used, not whatever they gave us.\n    if (this[_resolvedAdd].length) {\n      const root = this.idealTree\n      const pkg = root.package\n      for (const { name } of this[_resolvedAdd]) {\n        const req = npa.resolve(name, root.edgesOut.get(name).spec, root.realpath)\n        const {rawSpec, subSpec} = req\n\n        const spec = subSpec ? subSpec.rawSpec : rawSpec\n        const child = root.children.get(name)\n\n        if (req.registry) {\n          const version = child.version\n          const prefixRange = version ? this[_savePrefix] + version : '*'\n          // if we installed a range, then we save the range specified\n          // if it is not a subset of the ^x.y.z.  eg, installing a range\n          // of `1.x <1.2.3` will not be saved as `^1.2.0`, because that\n          // would allow versions outside the requested range.  Tags and\n          // specific versions save with the save-prefix.\n          const isRange = (subSpec || req).type === 'range'\n          const range = !isRange || subset(prefixRange, spec, { loose: true })\n            ? prefixRange : spec\n          const pname = child.package.name\n          const alias = name !== pname\n          updateDepSpec(pkg, name, (alias ? `npm:${pname}@` : '') + range)\n        } else if (req.hosted) {\n          // save the git+https url if it has auth, otherwise shortcut\n          const h = req.hosted\n          const opt = { noCommittish: false }\n          const save = h.https && h.auth ? `git+${h.https(opt)}`\n            : h.shortcut(opt)\n          updateDepSpec(pkg, name, save)\n        } else if (req.type === 'directory' || req.type === 'file') {\n          // save the relative path in package.json\n          // Normally saveSpec is updated with the proper relative\n          // path already, but it's possible to specify a full absolute\n          // path initially, in which case we can end up with the wrong\n          // thing, so just get the ultimate fetchSpec and relativize it.\n          const p = req.fetchSpec.replace(/^file:/, '')\n          const rel = relpath(root.realpath, p)\n          updateDepSpec(pkg, name, `file:${rel}`)\n        } else\n          updateDepSpec(pkg, name, req.saveSpec)\n      }\n\n      // refresh the edges so they have the correct specs\n      this.idealTree.package = pkg\n    }\n\n    // preserve indentation, if possible\n    const {\n      [Symbol.for('indent')]: indent,\n    } = this.idealTree.package\n    const format = indent === undefined ? '  ' : indent\n\n    const saveOpt = {\n      format: (this[_formatPackageLock] && format) ? format\n      : this[_formatPackageLock],\n    }\n\n    return Promise.all([\n      this[_saveLockFile](saveOpt),\n      updateRootPackageJson(this.idealTree),\n    ]).then(() => process.emit('timeEnd', 'reify:save'))\n  }\n\n  async [_saveLockFile] (saveOpt) {\n    if (!this[_usePackageLock])\n      return\n\n    const { meta } = this.idealTree\n\n    // might have to update metadata for bins and stuff that gets lost\n    if (meta.loadedFromDisk && !(meta.originalLockfileVersion >= 2)) {\n      for (const node of this.idealTree.inventory.values())\n        await this[_loadAncientPackageDetails](node, true)\n    }\n\n    return meta.save(saveOpt)\n  }\n\n  async [_copyIdealToActual] () {\n    // clean up any trash that is still in the tree\n    for (const path of this[_trashList]) {\n      const loc = relpath(this.idealTree.realpath, path)\n      const node = this.idealTree.inventory.get(loc)\n      if (node && node.root === this.idealTree)\n        node.parent = null\n    }\n\n    // if we filtered to only certain nodes, then anything ELSE needs\n    // to be untouched in the resulting actual tree, even if it differs\n    // in the idealTree.  Copy over anything that was in the actual and\n    // was not changed, delete anything in the ideal and not actual.\n    // Then we move the entire idealTree over to this.actualTree, and\n    // save the hidden lockfile.\n    if (this.diff && this.diff.filterSet.size) {\n      const { filterSet } = this.diff\n      const seen = new Set()\n      for (const [loc, ideal] of this.idealTree.inventory.entries()) {\n        if (seen.has(loc))\n          continue\n        seen.add(loc)\n\n        // if it's an ideal node from the filter set, then skip it\n        // because we already made whatever changes were necessary\n        if (filterSet.has(ideal))\n          continue\n\n        // otherwise, if it's not in the actualTree, then it's not a thing\n        // that we actually added.  And if it IS in the actualTree, then\n        // it's something that we left untouched, so we need to record\n        // that.\n        const actual = this.actualTree.inventory.get(loc)\n        if (!actual)\n          ideal.root = null\n        else {\n          if ([...actual.linksIn].some(link => filterSet.has(link))) {\n            seen.add(actual.location)\n            continue\n          }\n          const { realpath, isLink } = actual\n          if (isLink && ideal.isLink && ideal.realpath === realpath)\n            continue\n          else\n            actual.root = this.idealTree\n        }\n      }\n\n      // now find any actual nodes that may not be present in the ideal\n      // tree, but were left behind by virtue of not being in the filter\n      for (const [loc, actual] of this.actualTree.inventory.entries()) {\n        if (seen.has(loc))\n          continue\n        seen.add(loc)\n        if (filterSet.has(actual))\n          continue\n        actual.root = this.idealTree\n      }\n\n      // prune out any tops that lack a linkIn\n      for (const top of this.idealTree.tops) {\n        if (top.linksIn.size === 0)\n          top.root = null\n      }\n\n      // need to calculate dep flags, since nodes may have been marked\n      // as extraneous or otherwise incorrect during transit.\n      calcDepFlags(this.idealTree)\n    }\n\n    // save the ideal's meta as a hidden lockfile after we actualize it\n    this.idealTree.meta.filename =\n      this.idealTree.realpath + '/node_modules/.package-lock.json'\n    this.idealTree.meta.hiddenLockfile = true\n\n    this.actualTree = this.idealTree\n    this.idealTree = null\n\n    if (!this[_global])\n      await this.actualTree.meta.save()\n  }\n}\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"'use strict';\n\nconst errors = require('./errors.js');\n\nconst LRU = require('lru-cache');\n\nconst {\n  Response\n} = require('minipass-fetch');\n\nconst defaultOpts = require('./default-opts.js');\n\nmodule.exports = checkResponse;\n\nfunction checkResponse(method, res, registry, startTime, opts_ = {}) {\n  const opts = { ...defaultOpts,\n    ...opts_\n  };\n  if (res.headers.has('npm-notice') && !res.headers.has('x-local-cache')) opts.log.notice('', res.headers.get('npm-notice'));\n  checkWarnings(res, registry, opts);\n\n  if (res.status >= 400) {\n    logRequest(method, res, startTime, opts);\n    return checkErrors(method, res, startTime, opts);\n  } else {\n    res.body.on('end', () => logRequest(method, res, startTime, opts));\n\n    if (opts.ignoreBody) {\n      res.body.resume();\n      return new Response(null, res);\n    }\n\n    return res;\n  }\n}\n\nfunction logRequest(method, res, startTime, opts) {\n  const elapsedTime = Date.now() - startTime;\n  const attempt = res.headers.get('x-fetch-attempts');\n  const attemptStr = attempt && attempt > 1 ? ` attempt #${attempt}` : '';\n  const cacheStr = res.headers.get('x-local-cache') ? ' (from cache)' : '';\n  let urlStr;\n\n  try {\n    const {\n      URL\n    } = require('url');\n\n    const url = new URL(res.url);\n    if (url.password) url.password = '***';\n    urlStr = url.toString();\n  } catch (er) {\n    urlStr = res.url;\n  }\n\n  opts.log.http('fetch', `${method.toUpperCase()} ${res.status} ${urlStr} ${elapsedTime}ms${attemptStr}${cacheStr}`);\n}\n\nconst WARNING_REGEXP = /^\\s*(\\d{3})\\s+(\\S+)\\s+\"(.*)\"\\s+\"([^\"]+)\"/;\nconst BAD_HOSTS = new LRU({\n  max: 50\n});\n\nfunction checkWarnings(res, registry, opts) {\n  if (res.headers.has('warning') && !BAD_HOSTS.has(registry)) {\n    const warnings = {}; // note: headers.raw() will preserve case, so we might have a\n    // key on the object like 'WaRnInG' if that was used first\n\n    for (const [key, value] of Object.entries(res.headers.raw())) {\n      if (key.toLowerCase() !== 'warning') continue;\n      value.forEach(w => {\n        const match = w.match(WARNING_REGEXP);\n\n        if (match) {\n          warnings[match[1]] = {\n            code: match[1],\n            host: match[2],\n            message: match[3],\n            date: new Date(match[4])\n          };\n        }\n      });\n    }\n\n    BAD_HOSTS.set(registry, true);\n\n    if (warnings['199']) {\n      if (warnings['199'].message.match(/ENOTFOUND/)) opts.log.warn('registry', `Using stale data from ${registry} because the host is inaccessible -- are you offline?`);else opts.log.warn('registry', `Unexpected warning for ${registry}: ${warnings['199'].message}`);\n    }\n\n    if (warnings['111']) {\n      // 111 Revalidation failed -- we're using stale data\n      opts.log.warn('registry', `Using stale data from ${registry} due to a request error during revalidation.`);\n    }\n  }\n}\n\nfunction checkErrors(method, res, startTime, opts) {\n  return res.buffer().catch(() => null).then(body => {\n    let parsed = body;\n\n    try {\n      parsed = JSON.parse(body.toString('utf8'));\n    } catch (e) {}\n\n    if (res.status === 401 && res.headers.get('www-authenticate')) {\n      const auth = res.headers.get('www-authenticate').split(/,\\s*/).map(s => s.toLowerCase());\n\n      if (auth.indexOf('ipaddress') !== -1) {\n        throw new errors.HttpErrorAuthIPAddress(method, res, parsed, opts.spec);\n      } else if (auth.indexOf('otp') !== -1) {\n        throw new errors.HttpErrorAuthOTP(method, res, parsed, opts.spec);\n      } else {\n        throw new errors.HttpErrorAuthUnknown(method, res, parsed, opts.spec);\n      }\n    } else if (res.status === 401 && body != null && /one-time pass/.test(body.toString('utf8'))) {\n      // Heuristic for malformed OTP responses that don't include the www-authenticate header.\n      throw new errors.HttpErrorAuthOTP(method, res, parsed, opts.spec);\n    } else {\n      throw new errors.HttpErrorGeneral(method, res, parsed, opts.spec);\n    }\n  });\n}","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/node_modules/npm-registry-fetch/check-response.js"],"names":["errors","require","LRU","Response","defaultOpts","module","exports","checkResponse","method","res","registry","startTime","opts_","opts","headers","has","log","notice","get","checkWarnings","status","logRequest","checkErrors","body","on","ignoreBody","resume","elapsedTime","Date","now","attempt","attemptStr","cacheStr","urlStr","URL","url","password","toString","er","http","toUpperCase","WARNING_REGEXP","BAD_HOSTS","max","warnings","key","value","Object","entries","raw","toLowerCase","forEach","w","match","code","host","message","date","set","warn","buffer","catch","then","parsed","JSON","parse","e","auth","split","map","s","indexOf","HttpErrorAuthIPAddress","spec","HttpErrorAuthOTP","HttpErrorAuthUnknown","test","HttpErrorGeneral"],"mappings":"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","sourcesContent":["'use strict'\n\nconst errors = require('./errors.js')\nconst LRU = require('lru-cache')\nconst { Response } = require('minipass-fetch')\nconst defaultOpts = require('./default-opts.js')\n\nmodule.exports = checkResponse\nfunction checkResponse (method, res, registry, startTime, opts_ = {}) {\n  const opts = { ...defaultOpts, ...opts_ }\n  if (res.headers.has('npm-notice') && !res.headers.has('x-local-cache'))\n    opts.log.notice('', res.headers.get('npm-notice'))\n\n  checkWarnings(res, registry, opts)\n  if (res.status >= 400) {\n    logRequest(method, res, startTime, opts)\n    return checkErrors(method, res, startTime, opts)\n  } else {\n    res.body.on('end', () => logRequest(method, res, startTime, opts))\n    if (opts.ignoreBody) {\n      res.body.resume()\n      return new Response(null, res)\n    }\n    return res\n  }\n}\n\nfunction logRequest (method, res, startTime, opts) {\n  const elapsedTime = Date.now() - startTime\n  const attempt = res.headers.get('x-fetch-attempts')\n  const attemptStr = attempt && attempt > 1 ? ` attempt #${attempt}` : ''\n  const cacheStr = res.headers.get('x-local-cache') ? ' (from cache)' : ''\n\n  let urlStr\n  try {\n    const { URL } = require('url')\n    const url = new URL(res.url)\n    if (url.password)\n      url.password = '***'\n\n    urlStr = url.toString()\n  } catch (er) {\n    urlStr = res.url\n  }\n\n  opts.log.http(\n    'fetch',\n    `${method.toUpperCase()} ${res.status} ${urlStr} ${elapsedTime}ms${attemptStr}${cacheStr}`\n  )\n}\n\nconst WARNING_REGEXP = /^\\s*(\\d{3})\\s+(\\S+)\\s+\"(.*)\"\\s+\"([^\"]+)\"/\nconst BAD_HOSTS = new LRU({ max: 50 })\n\nfunction checkWarnings (res, registry, opts) {\n  if (res.headers.has('warning') && !BAD_HOSTS.has(registry)) {\n    const warnings = {}\n    // note: headers.raw() will preserve case, so we might have a\n    // key on the object like 'WaRnInG' if that was used first\n    for (const [key, value] of Object.entries(res.headers.raw())) {\n      if (key.toLowerCase() !== 'warning')\n        continue\n      value.forEach(w => {\n        const match = w.match(WARNING_REGEXP)\n        if (match) {\n          warnings[match[1]] = {\n            code: match[1],\n            host: match[2],\n            message: match[3],\n            date: new Date(match[4]),\n          }\n        }\n      })\n    }\n    BAD_HOSTS.set(registry, true)\n    if (warnings['199']) {\n      if (warnings['199'].message.match(/ENOTFOUND/))\n        opts.log.warn('registry', `Using stale data from ${registry} because the host is inaccessible -- are you offline?`)\n      else\n        opts.log.warn('registry', `Unexpected warning for ${registry}: ${warnings['199'].message}`)\n    }\n    if (warnings['111']) {\n      // 111 Revalidation failed -- we're using stale data\n      opts.log.warn(\n        'registry',\n        `Using stale data from ${registry} due to a request error during revalidation.`\n      )\n    }\n  }\n}\n\nfunction checkErrors (method, res, startTime, opts) {\n  return res.buffer()\n    .catch(() => null)\n    .then(body => {\n      let parsed = body\n      try {\n        parsed = JSON.parse(body.toString('utf8'))\n      } catch (e) {}\n      if (res.status === 401 && res.headers.get('www-authenticate')) {\n        const auth = res.headers.get('www-authenticate')\n          .split(/,\\s*/)\n          .map(s => s.toLowerCase())\n        if (auth.indexOf('ipaddress') !== -1) {\n          throw new errors.HttpErrorAuthIPAddress(\n            method, res, parsed, opts.spec\n          )\n        } else if (auth.indexOf('otp') !== -1) {\n          throw new errors.HttpErrorAuthOTP(\n            method, res, parsed, opts.spec\n          )\n        } else {\n          throw new errors.HttpErrorAuthUnknown(\n            method, res, parsed, opts.spec\n          )\n        }\n      } else if (res.status === 401 && body != null && /one-time pass/.test(body.toString('utf8'))) {\n        // Heuristic for malformed OTP responses that don't include the www-authenticate header.\n        throw new errors.HttpErrorAuthOTP(\n          method, res, parsed, opts.spec\n        )\n      } else {\n        throw new errors.HttpErrorGeneral(\n          method, res, parsed, opts.spec\n        )\n      }\n    })\n}\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"const types = ['peerDependencies', 'devDependencies', 'optionalDependencies', 'dependencies'];\n\nconst findType = (pkg, name) => {\n  for (const t of types) {\n    if (pkg[t] && typeof pkg[t] === 'object' && pkg[t][name] !== undefined) return t;\n  }\n\n  return 'dependencies';\n}; // given a dep name and spec, update it wherever it exists in\n// the manifest, or add the spec to 'dependencies' if not found.\n\n\nconst updateDepSpec = (pkg, name, newSpec) => {\n  const type = findType(pkg, name);\n  pkg[type] = pkg[type] || {};\n  pkg[type][name] = newSpec;\n  return pkg;\n}; // sort alphabetically all types of deps for a given package\n\n\nconst orderDeps = pkg => {\n  for (const type of types) {\n    if (pkg && pkg[type]) {\n      pkg[type] = Object.keys(pkg[type]).sort((a, b) => a.localeCompare(b)).reduce((res, key) => {\n        res[key] = pkg[type][key];\n        return res;\n      }, {});\n    }\n  }\n\n  return pkg;\n};\n\nmodule.exports = {\n  orderDeps,\n  updateDepSpec\n};","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/node_modules/@npmcli/arborist/lib/dep-spec.js"],"names":["types","findType","pkg","name","t","undefined","updateDepSpec","newSpec","type","orderDeps","Object","keys","sort","a","b","localeCompare","reduce","res","key","module","exports"],"mappings":"AAAA,MAAMA,KAAK,GAAG,CACZ,kBADY,EAEZ,iBAFY,EAGZ,sBAHY,EAIZ,cAJY,CAAd;;AAOA,MAAMC,QAAQ,GAAG,CAACC,GAAD,EAAMC,IAAN,KAAe;AAC9B,OAAK,MAAMC,CAAX,IAAgBJ,KAAhB,EAAuB;AACrB,QAAIE,GAAG,CAACE,CAAD,CAAH,IAAU,OAAOF,GAAG,CAACE,CAAD,CAAV,KAAkB,QAA5B,IAAwCF,GAAG,CAACE,CAAD,CAAH,CAAOD,IAAP,MAAiBE,SAA7D,EACE,OAAOD,CAAP;AACH;;AACD,SAAO,cAAP;AACD,CAND,C,CAQA;AACA;;;AACA,MAAME,aAAa,GAAG,CAACJ,GAAD,EAAMC,IAAN,EAAYI,OAAZ,KAAwB;AAC5C,QAAMC,IAAI,GAAGP,QAAQ,CAACC,GAAD,EAAMC,IAAN,CAArB;AACAD,EAAAA,GAAG,CAACM,IAAD,CAAH,GAAYN,GAAG,CAACM,IAAD,CAAH,IAAa,EAAzB;AACAN,EAAAA,GAAG,CAACM,IAAD,CAAH,CAAUL,IAAV,IAAkBI,OAAlB;AACA,SAAOL,GAAP;AACD,CALD,C,CAOA;;;AACA,MAAMO,SAAS,GAAIP,GAAD,IAAS;AACzB,OAAK,MAAMM,IAAX,IAAmBR,KAAnB,EAA0B;AACxB,QAAIE,GAAG,IAAIA,GAAG,CAACM,IAAD,CAAd,EAAsB;AACpBN,MAAAA,GAAG,CAACM,IAAD,CAAH,GAAYE,MAAM,CAACC,IAAP,CAAYT,GAAG,CAACM,IAAD,CAAf,EACTI,IADS,CACJ,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,CAACE,aAAF,CAAgBD,CAAhB,CADN,EAETE,MAFS,CAEF,CAACC,GAAD,EAAMC,GAAN,KAAc;AACpBD,QAAAA,GAAG,CAACC,GAAD,CAAH,GAAWhB,GAAG,CAACM,IAAD,CAAH,CAAUU,GAAV,CAAX;AACA,eAAOD,GAAP;AACD,OALS,EAKP,EALO,CAAZ;AAMD;AACF;;AACD,SAAOf,GAAP;AACD,CAZD;;AAcAiB,MAAM,CAACC,OAAP,GAAiB;AACfX,EAAAA,SADe;AAEfH,EAAAA;AAFe,CAAjB","sourcesContent":["const types = [\n  'peerDependencies',\n  'devDependencies',\n  'optionalDependencies',\n  'dependencies',\n]\n\nconst findType = (pkg, name) => {\n  for (const t of types) {\n    if (pkg[t] && typeof pkg[t] === 'object' && pkg[t][name] !== undefined)\n      return t\n  }\n  return 'dependencies'\n}\n\n// given a dep name and spec, update it wherever it exists in\n// the manifest, or add the spec to 'dependencies' if not found.\nconst updateDepSpec = (pkg, name, newSpec) => {\n  const type = findType(pkg, name)\n  pkg[type] = pkg[type] || {}\n  pkg[type][name] = newSpec\n  return pkg\n}\n\n// sort alphabetically all types of deps for a given package\nconst orderDeps = (pkg) => {\n  for (const type of types) {\n    if (pkg && pkg[type]) {\n      pkg[type] = Object.keys(pkg[type])\n        .sort((a, b) => a.localeCompare(b))\n        .reduce((res, key) => {\n          res[key] = pkg[type][key]\n          return res\n        }, {})\n    }\n  }\n  return pkg\n}\n\nmodule.exports = {\n  orderDeps,\n  updateDepSpec,\n}\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"// add and remove dependency specs to/from pkg manifest\nconst removeFromOthers = (name, type, pkg) => {\n  const others = new Set(['dependencies', 'optionalDependencies', 'devDependencies', 'peerDependenciesMeta', 'peerDependencies']);\n\n  switch (type) {\n    case 'prod':\n      others.delete('dependencies');\n      break;\n\n    case 'dev':\n      others.delete('devDependencies');\n      others.delete('peerDependencies');\n      others.delete('peerDependenciesMeta');\n      break;\n\n    case 'optional':\n      others.delete('optionalDependencies');\n      break;\n\n    case 'peer':\n    case 'peerOptional':\n      others.delete('devDependencies');\n      others.delete('peerDependencies');\n      others.delete('peerDependenciesMeta');\n      break;\n  }\n\n  for (const other of others) deleteSubKey(pkg, other, name);\n};\n\nconst add = ({\n  pkg,\n  add,\n  saveBundle,\n  saveType\n}) => {\n  for (const spec of add) addSingle({\n    pkg,\n    spec,\n    saveBundle,\n    saveType\n  });\n\n  return pkg;\n};\n\nconst addSingle = ({\n  pkg,\n  spec,\n  saveBundle,\n  saveType\n}) => {\n  if (!saveType) saveType = getSaveType(pkg, spec);\n  const {\n    name,\n    rawSpec\n  } = spec;\n  removeFromOthers(name, saveType, pkg);\n  const type = saveType === 'prod' ? 'dependencies' : saveType === 'optional' ? 'optionalDependencies' : saveType === 'peer' || saveType === 'peerOptional' ? 'peerDependencies' : saveType === 'dev' ? 'devDependencies' :\n  /* istanbul ignore next */\n  null;\n  pkg[type] = pkg[type] || {};\n  if (rawSpec !== '' || pkg[type][name] === undefined) pkg[type][name] = rawSpec || '*';\n\n  if (saveType === 'peer' || saveType === 'peerOptional') {\n    const pdm = pkg.peerDependenciesMeta || {};\n    if (saveType === 'peer' && pdm[name] && pdm[name].optional) pdm[name].optional = false;else if (saveType === 'peerOptional') {\n      pdm[name] = pdm[name] || {};\n      pdm[name].optional = true;\n      pkg.peerDependenciesMeta = pdm;\n    } // peerDeps are often also a devDep, so that they can be tested when\n    // using package managers that don't auto-install peer deps\n\n    if (pkg.devDependencies && pkg.devDependencies[name] !== undefined) pkg.devDependencies[name] = pkg.peerDependencies[name];\n  }\n\n  if (saveBundle && saveType !== 'peer' && saveType !== 'peerOptional') {\n    // keep it sorted, keep it unique\n    const bd = new Set(pkg.bundleDependencies || []);\n    bd.add(spec.name);\n    pkg.bundleDependencies = [...bd].sort((a, b) => a.localeCompare(b));\n  }\n};\n\nconst getSaveType = (pkg, spec) => {\n  const {\n    name\n  } = spec;\n  const {\n    // these names are so lonnnnngggg\n    devDependencies: devDeps,\n    optionalDependencies: optDeps,\n    peerDependencies: peerDeps,\n    peerDependenciesMeta: peerDepsMeta\n  } = pkg;\n\n  if (peerDeps && peerDeps[name] !== undefined) {\n    if (peerDepsMeta && peerDepsMeta[name] && peerDepsMeta[name].optional) return 'peerOptional';else return 'peer';\n  } else if (devDeps && devDeps[name] !== undefined) return 'dev';else if (optDeps && optDeps[name] !== undefined) return 'optional';else return 'prod';\n};\n\nconst deleteSubKey = (obj, k, sk) => {\n  if (obj[k]) {\n    delete obj[k][sk];\n    if (!Object.keys(obj[k]).length) delete obj[k];\n  }\n};\n\nconst rm = (pkg, rm) => {\n  for (const type of ['dependencies', 'optionalDependencies', 'peerDependencies', 'peerDependenciesMeta', 'devDependencies']) {\n    for (const name of rm) deleteSubKey(pkg, type, name);\n  }\n\n  if (pkg.bundleDependencies) {\n    pkg.bundleDependencies = pkg.bundleDependencies.filter(name => !rm.includes(name));\n    if (!pkg.bundleDependencies.length) delete pkg.bundleDependencies;\n  }\n\n  return pkg;\n};\n\nmodule.exports = {\n  add,\n  rm\n};","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/node_modules/@npmcli/arborist/lib/add-rm-pkg-deps.js"],"names":["removeFromOthers","name","type","pkg","others","Set","delete","other","deleteSubKey","add","saveBundle","saveType","spec","addSingle","getSaveType","rawSpec","undefined","pdm","peerDependenciesMeta","optional","devDependencies","peerDependencies","bd","bundleDependencies","sort","a","b","localeCompare","devDeps","optionalDependencies","optDeps","peerDeps","peerDepsMeta","obj","k","sk","Object","keys","length","rm","filter","includes","module","exports"],"mappings":"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","sourcesContent":["// add and remove dependency specs to/from pkg manifest\n\nconst removeFromOthers = (name, type, pkg) => {\n  const others = new Set([\n    'dependencies',\n    'optionalDependencies',\n    'devDependencies',\n    'peerDependenciesMeta',\n    'peerDependencies',\n  ])\n\n  switch (type) {\n    case 'prod':\n      others.delete('dependencies')\n      break\n    case 'dev':\n      others.delete('devDependencies')\n      others.delete('peerDependencies')\n      others.delete('peerDependenciesMeta')\n      break\n    case 'optional':\n      others.delete('optionalDependencies')\n      break\n    case 'peer':\n    case 'peerOptional':\n      others.delete('devDependencies')\n      others.delete('peerDependencies')\n      others.delete('peerDependenciesMeta')\n      break\n  }\n\n  for (const other of others)\n    deleteSubKey(pkg, other, name)\n}\n\nconst add = ({pkg, add, saveBundle, saveType}) => {\n  for (const spec of add)\n    addSingle({pkg, spec, saveBundle, saveType})\n\n  return pkg\n}\n\nconst addSingle = ({pkg, spec, saveBundle, saveType}) => {\n  if (!saveType)\n    saveType = getSaveType(pkg, spec)\n\n  const { name, rawSpec } = spec\n  removeFromOthers(name, saveType, pkg)\n  const type = saveType === 'prod' ? 'dependencies'\n    : saveType === 'optional' ? 'optionalDependencies'\n    : saveType === 'peer' || saveType === 'peerOptional' ? 'peerDependencies'\n    : saveType === 'dev' ? 'devDependencies'\n    : /* istanbul ignore next */ null\n\n  pkg[type] = pkg[type] || {}\n  if (rawSpec !== '' || pkg[type][name] === undefined)\n    pkg[type][name] = rawSpec || '*'\n\n  if (saveType === 'peer' || saveType === 'peerOptional') {\n    const pdm = pkg.peerDependenciesMeta || {}\n    if (saveType === 'peer' && pdm[name] && pdm[name].optional)\n      pdm[name].optional = false\n    else if (saveType === 'peerOptional') {\n      pdm[name] = pdm[name] || {}\n      pdm[name].optional = true\n      pkg.peerDependenciesMeta = pdm\n    }\n    // peerDeps are often also a devDep, so that they can be tested when\n    // using package managers that don't auto-install peer deps\n    if (pkg.devDependencies && pkg.devDependencies[name] !== undefined)\n      pkg.devDependencies[name] = pkg.peerDependencies[name]\n  }\n\n  if (saveBundle && saveType !== 'peer' && saveType !== 'peerOptional') {\n    // keep it sorted, keep it unique\n    const bd = new Set(pkg.bundleDependencies || [])\n    bd.add(spec.name)\n    pkg.bundleDependencies = [...bd].sort((a, b) => a.localeCompare(b))\n  }\n}\n\nconst getSaveType = (pkg, spec) => {\n  const {name} = spec\n  const {\n    // these names are so lonnnnngggg\n    devDependencies: devDeps,\n    optionalDependencies: optDeps,\n    peerDependencies: peerDeps,\n    peerDependenciesMeta: peerDepsMeta,\n  } = pkg\n\n  if (peerDeps && peerDeps[name] !== undefined) {\n    if (peerDepsMeta && peerDepsMeta[name] && peerDepsMeta[name].optional)\n      return 'peerOptional'\n    else\n      return 'peer'\n  } else if (devDeps && devDeps[name] !== undefined)\n    return 'dev'\n  else if (optDeps && optDeps[name] !== undefined)\n    return 'optional'\n  else\n    return 'prod'\n}\n\nconst deleteSubKey = (obj, k, sk) => {\n  if (obj[k]) {\n    delete obj[k][sk]\n    if (!Object.keys(obj[k]).length)\n      delete obj[k]\n  }\n}\n\nconst rm = (pkg, rm) => {\n  for (const type of [\n    'dependencies',\n    'optionalDependencies',\n    'peerDependencies',\n    'peerDependenciesMeta',\n    'devDependencies',\n  ]) {\n    for (const name of rm)\n      deleteSubKey(pkg, type, name)\n  }\n  if (pkg.bundleDependencies) {\n    pkg.bundleDependencies = pkg.bundleDependencies\n      .filter(name => !rm.includes(name))\n    if (!pkg.bundleDependencies.length)\n      delete pkg.bundleDependencies\n  }\n  return pkg\n}\n\nmodule.exports = { add, rm }\n"]},"metadata":{},"sourceType":"script"}
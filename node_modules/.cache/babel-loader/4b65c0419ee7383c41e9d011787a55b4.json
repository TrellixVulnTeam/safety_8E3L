{"ast":null,"code":"// mixin providing the loadVirtual method\nconst {\n  resolve\n} = require('path');\n\nconst nameFromFolder = require('@npmcli/name-from-folder');\n\nconst consistentResolve = require('../consistent-resolve.js');\n\nconst Shrinkwrap = require('../shrinkwrap.js');\n\nconst Node = require('../node.js');\n\nconst Link = require('../link.js');\n\nconst relpath = require('../relpath.js');\n\nconst calcDepFlags = require('../calc-dep-flags.js');\n\nconst rpj = require('read-package-json-fast');\n\nconst treeCheck = require('../tree-check.js');\n\nconst loadFromShrinkwrap = Symbol('loadFromShrinkwrap');\nconst resolveNodes = Symbol('resolveNodes');\nconst resolveLinks = Symbol('resolveLinks');\nconst assignBundles = Symbol('assignBundles');\nconst loadRoot = Symbol('loadRoot');\nconst loadNode = Symbol('loadVirtualNode');\nconst loadLink = Symbol('loadVirtualLink');\nconst loadWorkspaces = Symbol.for('loadWorkspaces');\nconst loadWorkspacesVirtual = Symbol.for('loadWorkspacesVirtual');\nconst flagsSuspect = Symbol.for('flagsSuspect');\nconst reCalcDepFlags = Symbol('reCalcDepFlags');\nconst checkRootEdges = Symbol('checkRootEdges');\nconst rootOptionProvided = Symbol('rootOptionProvided');\n\nconst depsToEdges = (type, deps) => Object.entries(deps).map(d => [type, ...d]);\n\nmodule.exports = cls => class VirtualLoader extends cls {\n  constructor(options) {\n    super(options); // the virtual tree we load from a shrinkwrap\n\n    this.virtualTree = options.virtualTree;\n    this[flagsSuspect] = false;\n  } // public method\n\n\n  async loadVirtual(options = {}) {\n    if (this.virtualTree) return this.virtualTree; // allow the user to set reify options on the ctor as well.\n    // XXX: deprecate separate reify() options object.\n\n    options = { ...this.options,\n      ...options\n    };\n\n    if (options.root && options.root.meta) {\n      await this[loadFromShrinkwrap](options.root.meta, options.root);\n      return treeCheck(this.virtualTree);\n    }\n\n    const s = await Shrinkwrap.load({\n      path: this.path\n    });\n\n    if (!s.loadedFromDisk && !options.root) {\n      const er = new Error('loadVirtual requires existing shrinkwrap file');\n      throw Object.assign(er, {\n        code: 'ENOLOCK'\n      });\n    } // when building the ideal tree, we pass in a root node to this function\n    // otherwise, load it from the root package json or the lockfile\n\n\n    const {\n      root = await this[loadRoot](s)\n    } = options;\n    this[rootOptionProvided] = options.root;\n    await this[loadFromShrinkwrap](s, root);\n    return treeCheck(this.virtualTree);\n  }\n\n  async [loadRoot](s) {\n    const pj = this.path + '/package.json';\n    const pkg = (await rpj(pj).catch(() => s.data.packages[''])) || {};\n    return this[loadWorkspaces](this[loadNode]('', pkg));\n  }\n\n  async [loadFromShrinkwrap](s, root) {\n    if (!this[rootOptionProvided]) {\n      // root is never any of these things, but might be a brand new\n      // baby Node object that never had its dep flags calculated.\n      root.extraneous = false;\n      root.dev = false;\n      root.optional = false;\n      root.devOptional = false;\n      root.peer = false;\n    } else this[flagsSuspect] = true;\n\n    this[checkRootEdges](s, root);\n    root.meta = s;\n    this.virtualTree = root;\n    const {\n      links,\n      nodes\n    } = this[resolveNodes](s, root);\n    await this[resolveLinks](links, nodes);\n    this[assignBundles](nodes);\n    if (this[flagsSuspect]) this[reCalcDepFlags](nodes.values());\n    return root;\n  }\n\n  [reCalcDepFlags](nodes) {\n    // reset all dep flags\n    // can't use inventory here, because virtualTree might not be root\n    for (const node of nodes) {\n      if (node.isRoot || node === this[rootOptionProvided]) continue;\n      node.extraneous = true;\n      node.dev = true;\n      node.optional = true;\n      node.devOptional = true;\n      node.peer = true;\n    }\n\n    calcDepFlags(this.virtualTree, !this[rootOptionProvided]);\n  } // check the lockfile deps, and see if they match.  if they do not\n  // then we have to reset dep flags at the end.  for example, if the\n  // user manually edits their package.json file, then we need to know\n  // that the idealTree is no longer entirely trustworthy.\n\n\n  [checkRootEdges](s, root) {\n    // loaded virtually from tree, no chance of being out of sync\n    // ancient lockfiles are critically damaged by this process,\n    // so we need to just hope for the best in those cases.\n    if (!s.loadedFromDisk || s.ancientLockfile) return;\n    const lock = s.get('');\n    const prod = lock.dependencies || {};\n    const dev = lock.devDependencies || {};\n    const optional = lock.optionalDependencies || {};\n    const peer = lock.peerDependencies || {};\n    const peerOptional = {};\n\n    if (lock.peerDependenciesMeta) {\n      for (const [name, meta] of Object.entries(lock.peerDependenciesMeta)) {\n        if (meta.optional && peer[name] !== undefined) {\n          peerOptional[name] = peer[name];\n          delete peer[name];\n        }\n      }\n    }\n\n    for (const name of Object.keys(optional)) delete prod[name];\n\n    const lockWS = [];\n    const workspaces = this[loadWorkspacesVirtual]({\n      cwd: this.path,\n      lockfile: s.data\n    });\n\n    for (const [name, path] of workspaces.entries()) lockWS.push(['workspace', name, `file:${path}`]);\n\n    const lockEdges = [...depsToEdges('prod', prod), ...depsToEdges('dev', dev), ...depsToEdges('optional', optional), ...depsToEdges('peer', peer), ...depsToEdges('peerOptional', peerOptional), ...lockWS].sort(([atype, aname], [btype, bname]) => atype.localeCompare(btype) || aname.localeCompare(bname));\n    const rootEdges = [...root.edgesOut.values()].map(e => [e.type, e.name, e.spec]).sort(([atype, aname], [btype, bname]) => atype.localeCompare(btype) || aname.localeCompare(bname));\n\n    if (rootEdges.length !== lockEdges.length) {\n      // something added or removed\n      return this[flagsSuspect] = true;\n    }\n\n    for (let i = 0; i < lockEdges.length; i++) {\n      if (rootEdges[i][0] !== lockEdges[i][0] || rootEdges[i][1] !== lockEdges[i][1] || rootEdges[i][2] !== lockEdges[i][2]) return this[flagsSuspect] = true;\n    }\n  } // separate out link metadatas, and create Node objects for nodes\n\n\n  [resolveNodes](s, root) {\n    const links = new Map();\n    const nodes = new Map([['', root]]);\n\n    for (const [location, meta] of Object.entries(s.data.packages)) {\n      // skip the root because we already got it\n      if (!location) continue;\n      if (meta.link) links.set(location, meta);else nodes.set(location, this[loadNode](location, meta));\n    }\n\n    return {\n      links,\n      nodes\n    };\n  } // links is the set of metadata, and nodes is the map of non-Link nodes\n  // Set the targets to nodes in the set, if we have them (we might not)\n\n\n  async [resolveLinks](links, nodes) {\n    for (const [location, meta] of links.entries()) {\n      const targetPath = resolve(this.path, meta.resolved);\n      const targetLoc = relpath(this.path, targetPath);\n      const target = nodes.get(targetLoc);\n      const link = this[loadLink](location, targetLoc, target, meta);\n      nodes.set(location, link);\n      nodes.set(targetLoc, link.target); // we always need to read the package.json for link targets\n      // outside node_modules because they can be changed by the local user\n\n      if (!link.target.parent) {\n        const pj = link.realpath + '/package.json';\n        const pkg = await rpj(pj).catch(() => null);\n        if (pkg) link.target.package = pkg;\n      }\n    }\n  }\n\n  [assignBundles](nodes) {\n    for (const [location, node] of nodes) {\n      // Skip assignment of parentage for the root package\n      if (!location) continue;\n      const {\n        name,\n        parent,\n        package: {\n          inBundle\n        }\n      } = node;\n      if (!parent) continue; // read inBundle from package because 'package' here is\n      // actually a v2 lockfile metadata entry.\n      // If the *parent* is also bundled, though, then we assume\n      // that it's being pulled in just by virtue of that.\n\n      const {\n        package: ppkg\n      } = parent;\n      const {\n        inBundle: parentBundled\n      } = ppkg;\n\n      if (inBundle && !parentBundled) {\n        if (!ppkg.bundleDependencies) ppkg.bundleDependencies = [name];else if (!ppkg.bundleDependencies.includes(name)) ppkg.bundleDependencies.push(name);\n      }\n    }\n  }\n\n  [loadNode](location, sw) {\n    const p = this.virtualTree ? this.virtualTree.realpath : this.path;\n    const path = resolve(p, location); // shrinkwrap doesn't include package name unless necessary\n\n    if (!sw.name) sw.name = nameFromFolder(path);\n    const dev = sw.dev;\n    const optional = sw.optional;\n    const devOptional = dev || optional || sw.devOptional;\n    const peer = sw.peer;\n    const node = new Node({\n      legacyPeerDeps: this.legacyPeerDeps,\n      root: this.virtualTree,\n      path,\n      realpath: path,\n      integrity: sw.integrity,\n      resolved: consistentResolve(sw.resolved, this.path, path),\n      pkg: sw,\n      hasShrinkwrap: sw.hasShrinkwrap,\n      dev,\n      optional,\n      devOptional,\n      peer\n    }); // cast to boolean because they're undefined in the lock file when false\n\n    node.extraneous = !!sw.extraneous;\n    node.devOptional = !!(sw.devOptional || sw.dev || sw.optional);\n    node.peer = !!sw.peer;\n    node.optional = !!sw.optional;\n    node.dev = !!sw.dev;\n    return node;\n  }\n\n  [loadLink](location, targetLoc, target, meta) {\n    const path = resolve(this.path, location);\n    const link = new Link({\n      legacyPeerDeps: this.legacyPeerDeps,\n      path,\n      realpath: resolve(this.path, targetLoc),\n      target,\n      pkg: target && target.package\n    });\n    link.extraneous = target.extraneous;\n    link.devOptional = target.devOptional;\n    link.peer = target.peer;\n    link.optional = target.optional;\n    link.dev = target.dev;\n    return link;\n  }\n\n};","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/node_modules/@npmcli/arborist/lib/arborist/load-virtual.js"],"names":["resolve","require","nameFromFolder","consistentResolve","Shrinkwrap","Node","Link","relpath","calcDepFlags","rpj","treeCheck","loadFromShrinkwrap","Symbol","resolveNodes","resolveLinks","assignBundles","loadRoot","loadNode","loadLink","loadWorkspaces","for","loadWorkspacesVirtual","flagsSuspect","reCalcDepFlags","checkRootEdges","rootOptionProvided","depsToEdges","type","deps","Object","entries","map","d","module","exports","cls","VirtualLoader","constructor","options","virtualTree","loadVirtual","root","meta","s","load","path","loadedFromDisk","er","Error","assign","code","pj","pkg","catch","data","packages","extraneous","dev","optional","devOptional","peer","links","nodes","values","node","isRoot","ancientLockfile","lock","get","prod","dependencies","devDependencies","optionalDependencies","peerDependencies","peerOptional","peerDependenciesMeta","name","undefined","keys","lockWS","workspaces","cwd","lockfile","push","lockEdges","sort","atype","aname","btype","bname","localeCompare","rootEdges","edgesOut","e","spec","length","i","Map","location","link","set","targetPath","resolved","targetLoc","target","parent","realpath","package","inBundle","ppkg","parentBundled","bundleDependencies","includes","sw","p","legacyPeerDeps","integrity","hasShrinkwrap"],"mappings":"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","sourcesContent":["// mixin providing the loadVirtual method\n\nconst {resolve} = require('path')\n\nconst nameFromFolder = require('@npmcli/name-from-folder')\nconst consistentResolve = require('../consistent-resolve.js')\nconst Shrinkwrap = require('../shrinkwrap.js')\nconst Node = require('../node.js')\nconst Link = require('../link.js')\nconst relpath = require('../relpath.js')\nconst calcDepFlags = require('../calc-dep-flags.js')\nconst rpj = require('read-package-json-fast')\nconst treeCheck = require('../tree-check.js')\n\nconst loadFromShrinkwrap = Symbol('loadFromShrinkwrap')\nconst resolveNodes = Symbol('resolveNodes')\nconst resolveLinks = Symbol('resolveLinks')\nconst assignBundles = Symbol('assignBundles')\nconst loadRoot = Symbol('loadRoot')\nconst loadNode = Symbol('loadVirtualNode')\nconst loadLink = Symbol('loadVirtualLink')\nconst loadWorkspaces = Symbol.for('loadWorkspaces')\nconst loadWorkspacesVirtual = Symbol.for('loadWorkspacesVirtual')\nconst flagsSuspect = Symbol.for('flagsSuspect')\nconst reCalcDepFlags = Symbol('reCalcDepFlags')\nconst checkRootEdges = Symbol('checkRootEdges')\nconst rootOptionProvided = Symbol('rootOptionProvided')\n\nconst depsToEdges = (type, deps) =>\n  Object.entries(deps).map(d => [type, ...d])\n\nmodule.exports = cls => class VirtualLoader extends cls {\n  constructor (options) {\n    super(options)\n\n    // the virtual tree we load from a shrinkwrap\n    this.virtualTree = options.virtualTree\n    this[flagsSuspect] = false\n  }\n\n  // public method\n  async loadVirtual (options = {}) {\n    if (this.virtualTree)\n      return this.virtualTree\n\n    // allow the user to set reify options on the ctor as well.\n    // XXX: deprecate separate reify() options object.\n    options = { ...this.options, ...options }\n\n    if (options.root && options.root.meta) {\n      await this[loadFromShrinkwrap](options.root.meta, options.root)\n      return treeCheck(this.virtualTree)\n    }\n\n    const s = await Shrinkwrap.load({ path: this.path })\n    if (!s.loadedFromDisk && !options.root) {\n      const er = new Error('loadVirtual requires existing shrinkwrap file')\n      throw Object.assign(er, { code: 'ENOLOCK' })\n    }\n\n    // when building the ideal tree, we pass in a root node to this function\n    // otherwise, load it from the root package json or the lockfile\n    const {\n      root = await this[loadRoot](s),\n    } = options\n\n    this[rootOptionProvided] = options.root\n\n    await this[loadFromShrinkwrap](s, root)\n    return treeCheck(this.virtualTree)\n  }\n\n  async [loadRoot] (s) {\n    const pj = this.path + '/package.json'\n    const pkg = await rpj(pj).catch(() => s.data.packages['']) || {}\n    return this[loadWorkspaces](this[loadNode]('', pkg))\n  }\n\n  async [loadFromShrinkwrap] (s, root) {\n    if (!this[rootOptionProvided]) {\n      // root is never any of these things, but might be a brand new\n      // baby Node object that never had its dep flags calculated.\n      root.extraneous = false\n      root.dev = false\n      root.optional = false\n      root.devOptional = false\n      root.peer = false\n    } else\n      this[flagsSuspect] = true\n\n    this[checkRootEdges](s, root)\n    root.meta = s\n    this.virtualTree = root\n    const {links, nodes} = this[resolveNodes](s, root)\n    await this[resolveLinks](links, nodes)\n    this[assignBundles](nodes)\n    if (this[flagsSuspect])\n      this[reCalcDepFlags](nodes.values())\n    return root\n  }\n\n  [reCalcDepFlags] (nodes) {\n    // reset all dep flags\n    // can't use inventory here, because virtualTree might not be root\n    for (const node of nodes) {\n      if (node.isRoot || node === this[rootOptionProvided])\n        continue\n      node.extraneous = true\n      node.dev = true\n      node.optional = true\n      node.devOptional = true\n      node.peer = true\n    }\n    calcDepFlags(this.virtualTree, !this[rootOptionProvided])\n  }\n\n  // check the lockfile deps, and see if they match.  if they do not\n  // then we have to reset dep flags at the end.  for example, if the\n  // user manually edits their package.json file, then we need to know\n  // that the idealTree is no longer entirely trustworthy.\n  [checkRootEdges] (s, root) {\n    // loaded virtually from tree, no chance of being out of sync\n    // ancient lockfiles are critically damaged by this process,\n    // so we need to just hope for the best in those cases.\n    if (!s.loadedFromDisk || s.ancientLockfile)\n      return\n\n    const lock = s.get('')\n    const prod = lock.dependencies || {}\n    const dev = lock.devDependencies || {}\n    const optional = lock.optionalDependencies || {}\n    const peer = lock.peerDependencies || {}\n    const peerOptional = {}\n    if (lock.peerDependenciesMeta) {\n      for (const [name, meta] of Object.entries(lock.peerDependenciesMeta)) {\n        if (meta.optional && peer[name] !== undefined) {\n          peerOptional[name] = peer[name]\n          delete peer[name]\n        }\n      }\n    }\n    for (const name of Object.keys(optional))\n      delete prod[name]\n\n    const lockWS = []\n    const workspaces = this[loadWorkspacesVirtual]({\n      cwd: this.path,\n      lockfile: s.data,\n    })\n    for (const [name, path] of workspaces.entries())\n      lockWS.push(['workspace', name, `file:${path}`])\n\n    const lockEdges = [\n      ...depsToEdges('prod', prod),\n      ...depsToEdges('dev', dev),\n      ...depsToEdges('optional', optional),\n      ...depsToEdges('peer', peer),\n      ...depsToEdges('peerOptional', peerOptional),\n      ...lockWS,\n    ].sort(([atype, aname], [btype, bname]) =>\n      atype.localeCompare(btype) || aname.localeCompare(bname))\n\n    const rootEdges = [...root.edgesOut.values()]\n      .map(e => [e.type, e.name, e.spec])\n      .sort(([atype, aname], [btype, bname]) =>\n        atype.localeCompare(btype) || aname.localeCompare(bname))\n\n    if (rootEdges.length !== lockEdges.length) {\n      // something added or removed\n      return this[flagsSuspect] = true\n    }\n\n    for (let i = 0; i < lockEdges.length; i++) {\n      if (rootEdges[i][0] !== lockEdges[i][0] ||\n          rootEdges[i][1] !== lockEdges[i][1] ||\n          rootEdges[i][2] !== lockEdges[i][2])\n        return this[flagsSuspect] = true\n    }\n  }\n\n  // separate out link metadatas, and create Node objects for nodes\n  [resolveNodes] (s, root) {\n    const links = new Map()\n    const nodes = new Map([['', root]])\n    for (const [location, meta] of Object.entries(s.data.packages)) {\n      // skip the root because we already got it\n      if (!location)\n        continue\n\n      if (meta.link)\n        links.set(location, meta)\n      else\n        nodes.set(location, this[loadNode](location, meta))\n    }\n    return {links, nodes}\n  }\n\n  // links is the set of metadata, and nodes is the map of non-Link nodes\n  // Set the targets to nodes in the set, if we have them (we might not)\n  async [resolveLinks] (links, nodes) {\n    for (const [location, meta] of links.entries()) {\n      const targetPath = resolve(this.path, meta.resolved)\n      const targetLoc = relpath(this.path, targetPath)\n      const target = nodes.get(targetLoc)\n      const link = this[loadLink](location, targetLoc, target, meta)\n      nodes.set(location, link)\n      nodes.set(targetLoc, link.target)\n\n      // we always need to read the package.json for link targets\n      // outside node_modules because they can be changed by the local user\n      if (!link.target.parent) {\n        const pj = link.realpath + '/package.json'\n        const pkg = await rpj(pj).catch(() => null)\n        if (pkg)\n          link.target.package = pkg\n      }\n    }\n  }\n\n  [assignBundles] (nodes) {\n    for (const [location, node] of nodes) {\n      // Skip assignment of parentage for the root package\n      if (!location)\n        continue\n      const { name, parent, package: { inBundle }} = node\n      if (!parent)\n        continue\n\n      // read inBundle from package because 'package' here is\n      // actually a v2 lockfile metadata entry.\n      // If the *parent* is also bundled, though, then we assume\n      // that it's being pulled in just by virtue of that.\n      const { package: ppkg } = parent\n      const { inBundle: parentBundled } = ppkg\n      if (inBundle && !parentBundled) {\n        if (!ppkg.bundleDependencies)\n          ppkg.bundleDependencies = [name]\n        else if (!ppkg.bundleDependencies.includes(name))\n          ppkg.bundleDependencies.push(name)\n      }\n    }\n  }\n\n  [loadNode] (location, sw) {\n    const p = this.virtualTree ? this.virtualTree.realpath : this.path\n    const path = resolve(p, location)\n    // shrinkwrap doesn't include package name unless necessary\n    if (!sw.name)\n      sw.name = nameFromFolder(path)\n\n    const dev = sw.dev\n    const optional = sw.optional\n    const devOptional = dev || optional || sw.devOptional\n    const peer = sw.peer\n\n    const node = new Node({\n      legacyPeerDeps: this.legacyPeerDeps,\n      root: this.virtualTree,\n      path,\n      realpath: path,\n      integrity: sw.integrity,\n      resolved: consistentResolve(sw.resolved, this.path, path),\n      pkg: sw,\n      hasShrinkwrap: sw.hasShrinkwrap,\n      dev,\n      optional,\n      devOptional,\n      peer,\n    })\n    // cast to boolean because they're undefined in the lock file when false\n    node.extraneous = !!sw.extraneous\n    node.devOptional = !!(sw.devOptional || sw.dev || sw.optional)\n    node.peer = !!sw.peer\n    node.optional = !!sw.optional\n    node.dev = !!sw.dev\n    return node\n  }\n\n  [loadLink] (location, targetLoc, target, meta) {\n    const path = resolve(this.path, location)\n    const link = new Link({\n      legacyPeerDeps: this.legacyPeerDeps,\n      path,\n      realpath: resolve(this.path, targetLoc),\n      target,\n      pkg: target && target.package,\n    })\n    link.extraneous = target.extraneous\n    link.devOptional = target.devOptional\n    link.peer = target.peer\n    link.optional = target.optional\n    link.dev = target.dev\n    return link\n  }\n}\n"]},"metadata":{},"sourceType":"script"}
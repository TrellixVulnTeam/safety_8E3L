{"ast":null,"code":"const fs = require('fs');\n\nconst promisify = require('util').promisify;\n\nconst readFile = promisify(fs.readFile);\nconst writeFile = promisify(fs.writeFile);\n\nconst {\n  resolve\n} = require('path');\n\nconst parseJSON = require('json-parse-even-better-errors');\n\nconst {\n  orderDeps\n} = require('./dep-spec.js');\n\nconst depTypes = new Set(['dependencies', 'optionalDependencies', 'devDependencies', 'peerDependencies']);\n\nconst parseJsonSafe = json => {\n  try {\n    return parseJSON(json);\n  } catch (er) {\n    return null;\n  }\n};\n\nconst updateRootPackageJson = async tree => {\n  const filename = resolve(tree.path, 'package.json');\n  const originalJson = await readFile(filename, 'utf8').catch(() => null);\n  const originalContent = parseJsonSafe(originalJson);\n  const depsData = orderDeps({ ...tree.package\n  }); // optionalDependencies don't need to be repeated in two places\n\n  if (depsData.dependencies) {\n    if (depsData.optionalDependencies) {\n      for (const name of Object.keys(depsData.optionalDependencies)) delete depsData.dependencies[name];\n    }\n\n    if (Object.keys(depsData.dependencies).length === 0) delete depsData.dependencies;\n  } // if there's no package.json, just use internal pkg info as source of truth\n  // clone the object though, so we can still refer to what it originally was\n\n\n  const packageJsonContent = !originalContent ? depsData : Object.assign({}, originalContent); // loop through all types of dependencies and update package json content\n\n  for (const type of depTypes) packageJsonContent[type] = depsData[type]; // if original package.json had dep in peerDeps AND deps, preserve that.\n\n\n  const {\n    dependencies: origProd,\n    peerDependencies: origPeer\n  } = originalContent || {};\n  const {\n    peerDependencies: newPeer\n  } = packageJsonContent;\n\n  if (origProd && origPeer && newPeer) {\n    // we have original prod/peer deps, and new peer deps\n    // copy over any that were in both in the original\n    for (const name of Object.keys(origPeer)) {\n      if (origProd[name] !== undefined && newPeer[name] !== undefined) {\n        packageJsonContent.dependencies = packageJsonContent.dependencies || {};\n        packageJsonContent.dependencies[name] = newPeer[name];\n      }\n    }\n  } // format content\n\n\n  const {\n    [Symbol.for('indent')]: indent,\n    [Symbol.for('newline')]: newline\n  } = tree.package;\n  const format = indent === undefined ? '  ' : indent;\n  const eol = newline === undefined ? '\\n' : newline;\n  const content = (JSON.stringify(packageJsonContent, null, format) + '\\n').replace(/\\n/g, eol);\n  if (content !== originalJson) return writeFile(filename, content);\n};\n\nmodule.exports = updateRootPackageJson;","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/node_modules/@npmcli/arborist/lib/update-root-package-json.js"],"names":["fs","require","promisify","readFile","writeFile","resolve","parseJSON","orderDeps","depTypes","Set","parseJsonSafe","json","er","updateRootPackageJson","tree","filename","path","originalJson","catch","originalContent","depsData","package","dependencies","optionalDependencies","name","Object","keys","length","packageJsonContent","assign","type","origProd","peerDependencies","origPeer","newPeer","undefined","Symbol","for","indent","newline","format","eol","content","JSON","stringify","replace","module","exports"],"mappings":"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","sourcesContent":["const fs = require('fs')\nconst promisify = require('util').promisify\nconst readFile = promisify(fs.readFile)\nconst writeFile = promisify(fs.writeFile)\nconst {resolve} = require('path')\n\nconst parseJSON = require('json-parse-even-better-errors')\n\nconst { orderDeps } = require('./dep-spec.js')\n\nconst depTypes = new Set([\n  'dependencies',\n  'optionalDependencies',\n  'devDependencies',\n  'peerDependencies',\n])\n\nconst parseJsonSafe = json => {\n  try {\n    return parseJSON(json)\n  } catch (er) {\n    return null\n  }\n}\n\nconst updateRootPackageJson = async tree => {\n  const filename = resolve(tree.path, 'package.json')\n  const originalJson = await readFile(filename, 'utf8').catch(() => null)\n  const originalContent = parseJsonSafe(originalJson)\n\n  const depsData = orderDeps({\n    ...tree.package,\n  })\n\n  // optionalDependencies don't need to be repeated in two places\n  if (depsData.dependencies) {\n    if (depsData.optionalDependencies) {\n      for (const name of Object.keys(depsData.optionalDependencies))\n        delete depsData.dependencies[name]\n    }\n    if (Object.keys(depsData.dependencies).length === 0)\n      delete depsData.dependencies\n  }\n\n  // if there's no package.json, just use internal pkg info as source of truth\n  // clone the object though, so we can still refer to what it originally was\n  const packageJsonContent = !originalContent ? depsData\n    : Object.assign({}, originalContent)\n\n  // loop through all types of dependencies and update package json content\n  for (const type of depTypes)\n    packageJsonContent[type] = depsData[type]\n\n  // if original package.json had dep in peerDeps AND deps, preserve that.\n  const { dependencies: origProd, peerDependencies: origPeer } =\n    originalContent || {}\n  const { peerDependencies: newPeer } = packageJsonContent\n  if (origProd && origPeer && newPeer) {\n    // we have original prod/peer deps, and new peer deps\n    // copy over any that were in both in the original\n    for (const name of Object.keys(origPeer)) {\n      if (origProd[name] !== undefined && newPeer[name] !== undefined) {\n        packageJsonContent.dependencies = packageJsonContent.dependencies || {}\n        packageJsonContent.dependencies[name] = newPeer[name]\n      }\n    }\n  }\n\n  // format content\n  const {\n    [Symbol.for('indent')]: indent,\n    [Symbol.for('newline')]: newline,\n  } = tree.package\n  const format = indent === undefined ? '  ' : indent\n  const eol = newline === undefined ? '\\n' : newline\n  const content = (JSON.stringify(packageJsonContent, null, format) + '\\n')\n    .replace(/\\n/g, eol)\n\n  if (content !== originalJson)\n    return writeFile(filename, content)\n}\n\nmodule.exports = updateRootPackageJson\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"'use strict';\n\nconst defaultOpts = require('./default-opts.js');\n\nconst url = require('url');\n\nmodule.exports = getAuth;\n\nfunction getAuth(registry, opts_ = {}) {\n  if (!registry) throw new Error('registry is required');\n  const opts = opts_.forceAuth ? opts_.forceAuth : { ...defaultOpts,\n    ...opts_\n  };\n  const AUTH = {};\n  const regKey = registry && registryKey(registry);\n\n  const doKey = (key, alias) => addKey(opts, AUTH, regKey, key, alias);\n\n  doKey('token');\n  doKey('_authToken', 'token');\n  doKey('username');\n  doKey('password');\n  doKey('_password', 'password');\n  doKey('email');\n  doKey('_auth');\n  doKey('otp');\n  doKey('always-auth', 'alwaysAuth');\n  if (AUTH.password) AUTH.password = Buffer.from(AUTH.password, 'base64').toString('utf8');\n\n  if (AUTH._auth && !(AUTH.username && AUTH.password)) {\n    let auth = Buffer.from(AUTH._auth, 'base64').toString();\n    auth = auth.split(':');\n    AUTH.username = auth.shift();\n    AUTH.password = auth.join(':');\n  }\n\n  AUTH.alwaysAuth = AUTH.alwaysAuth === 'false' ? false : !!AUTH.alwaysAuth;\n  return AUTH;\n}\n\nfunction addKey(opts, obj, scope, key, objKey) {\n  if (opts[key]) obj[objKey || key] = opts[key];\n  if (scope && opts[`${scope}:${key}`]) obj[objKey || key] = opts[`${scope}:${key}`];\n} // Called a nerf dart in the main codebase. Used as a \"safe\"\n// key when fetching registry info from config.\n\n\nfunction registryKey(registry) {\n  const parsed = new url.URL(registry);\n  const formatted = url.format({\n    protocol: parsed.protocol,\n    host: parsed.host,\n    pathname: parsed.pathname,\n    slashes: true\n  });\n  return url.format(new url.URL('.', formatted)).replace(/^[^:]+:/, '');\n}","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/node_modules/npm-registry-fetch/auth.js"],"names":["defaultOpts","require","url","module","exports","getAuth","registry","opts_","Error","opts","forceAuth","AUTH","regKey","registryKey","doKey","key","alias","addKey","password","Buffer","from","toString","_auth","username","auth","split","shift","join","alwaysAuth","obj","scope","objKey","parsed","URL","formatted","format","protocol","host","pathname","slashes","replace"],"mappings":"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","sourcesContent":["'use strict'\n\nconst defaultOpts = require('./default-opts.js')\nconst url = require('url')\n\nmodule.exports = getAuth\nfunction getAuth (registry, opts_ = {}) {\n  if (!registry)\n    throw new Error('registry is required')\n  const opts = opts_.forceAuth ? opts_.forceAuth : { ...defaultOpts, ...opts_ }\n  const AUTH = {}\n  const regKey = registry && registryKey(registry)\n  const doKey = (key, alias) => addKey(opts, AUTH, regKey, key, alias)\n  doKey('token')\n  doKey('_authToken', 'token')\n  doKey('username')\n  doKey('password')\n  doKey('_password', 'password')\n  doKey('email')\n  doKey('_auth')\n  doKey('otp')\n  doKey('always-auth', 'alwaysAuth')\n  if (AUTH.password)\n    AUTH.password = Buffer.from(AUTH.password, 'base64').toString('utf8')\n\n  if (AUTH._auth && !(AUTH.username && AUTH.password)) {\n    let auth = Buffer.from(AUTH._auth, 'base64').toString()\n    auth = auth.split(':')\n    AUTH.username = auth.shift()\n    AUTH.password = auth.join(':')\n  }\n  AUTH.alwaysAuth = AUTH.alwaysAuth === 'false' ? false : !!AUTH.alwaysAuth\n  return AUTH\n}\n\nfunction addKey (opts, obj, scope, key, objKey) {\n  if (opts[key])\n    obj[objKey || key] = opts[key]\n\n  if (scope && opts[`${scope}:${key}`])\n    obj[objKey || key] = opts[`${scope}:${key}`]\n}\n\n// Called a nerf dart in the main codebase. Used as a \"safe\"\n// key when fetching registry info from config.\nfunction registryKey (registry) {\n  const parsed = new url.URL(registry)\n  const formatted = url.format({\n    protocol: parsed.protocol,\n    host: parsed.host,\n    pathname: parsed.pathname,\n    slashes: true,\n  })\n  return url.format(new url.URL('.', formatted)).replace(/^[^:]+:/, '')\n}\n"]},"metadata":{},"sourceType":"script"}
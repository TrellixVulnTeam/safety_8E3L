{"ast":null,"code":"const path = require('path');\n\nconst util = require('util');\n\nconst log = require('npmlog');\n\nconst npa = require('npm-package-arg');\n\nconst libaccess = require('libnpmaccess');\n\nconst npmFetch = require('npm-registry-fetch');\n\nconst libunpub = require('libnpmpublish').unpublish;\n\nconst readJson = util.promisify(require('read-package-json'));\n\nconst otplease = require('./utils/otplease.js');\n\nconst getIdentity = require('./utils/get-identity.js');\n\nconst BaseCommand = require('./base-command.js');\n\nclass Unpublish extends BaseCommand {\n  static get description() {\n    return 'Remove a package from the registry';\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  static get name() {\n    return 'unpublish';\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  static get usage() {\n    return ['[<@scope>/]<pkg>[@<version>]'];\n  }\n\n  async completion(args) {\n    const {\n      partialWord,\n      conf\n    } = args;\n    if (conf.argv.remain.length >= 3) return [];\n    const opts = this.npm.flatOptions;\n    const username = await getIdentity(this.npm, { ...opts\n    }).catch(() => null);\n    if (!username) return [];\n    const access = await libaccess.lsPackages(username, opts); // do a bit of filtering at this point, so that we don't need\n    // to fetch versions for more than one thing, but also don't\n    // accidentally unpublish a whole project\n\n    let pkgs = Object.keys(access || {});\n    if (!partialWord || !pkgs.length) return pkgs;\n    const pp = npa(partialWord).name;\n    pkgs = pkgs.filter(p => !p.indexOf(pp));\n    if (pkgs.length > 1) return pkgs;\n    const json = await npmFetch.json(npa(pkgs[0]).escapedName, opts);\n    const versions = Object.keys(json.versions);\n    if (!versions.length) return pkgs;else return versions.map(v => `${pkgs[0]}@${v}`);\n  }\n\n  exec(args, cb) {\n    this.unpublish(args).then(() => cb()).catch(cb);\n  }\n\n  async unpublish(args) {\n    if (args.length > 1) throw new Error(this.usage);\n    const spec = args.length && npa(args[0]);\n    const force = this.npm.config.get('force');\n    const silent = this.npm.config.get('silent');\n    const loglevel = this.npm.config.get('loglevel');\n    let pkgName;\n    let pkgVersion;\n    log.silly('unpublish', 'args[0]', args[0]);\n    log.silly('unpublish', 'spec', spec);\n\n    if (!spec.rawSpec && !force) {\n      throw new Error('Refusing to delete entire project.\\n' + 'Run with --force to do this.\\n' + this.usage);\n    }\n\n    const opts = this.npm.flatOptions;\n\n    if (!spec || path.resolve(spec.name) === this.npm.localPrefix) {\n      // if there's a package.json in the current folder, then\n      // read the package name and version out of that.\n      const pkgJson = path.join(this.npm.localPrefix, 'package.json');\n      let manifest;\n\n      try {\n        manifest = await readJson(pkgJson);\n      } catch (err) {\n        if (err && err.code !== 'ENOENT' && err.code !== 'ENOTDIR') throw err;else throw new Error(`Usage: ${this.usage}`);\n      }\n\n      log.verbose('unpublish', manifest);\n      const {\n        name,\n        version,\n        publishConfig\n      } = manifest;\n      const pkgJsonSpec = npa.resolve(name, version);\n      const optsWithPub = { ...opts,\n        publishConfig\n      };\n      await otplease(opts, opts => libunpub(pkgJsonSpec, optsWithPub));\n      pkgName = name;\n      pkgVersion = version ? `@${version}` : '';\n    } else {\n      await otplease(opts, opts => libunpub(spec, opts));\n      pkgName = spec.name;\n      pkgVersion = spec.type === 'version' ? `@${spec.rawSpec}` : '';\n    }\n\n    if (!silent && loglevel !== 'silent') this.npm.output(`- ${pkgName}${pkgVersion}`);\n  }\n\n}\n\nmodule.exports = Unpublish;","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/lib/unpublish.js"],"names":["path","require","util","log","npa","libaccess","npmFetch","libunpub","unpublish","readJson","promisify","otplease","getIdentity","BaseCommand","Unpublish","description","name","usage","completion","args","partialWord","conf","argv","remain","length","opts","npm","flatOptions","username","catch","access","lsPackages","pkgs","Object","keys","pp","filter","p","indexOf","json","escapedName","versions","map","v","exec","cb","then","Error","spec","force","config","get","silent","loglevel","pkgName","pkgVersion","silly","rawSpec","resolve","localPrefix","pkgJson","join","manifest","err","code","verbose","version","publishConfig","pkgJsonSpec","optsWithPub","type","output","module","exports"],"mappings":"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","sourcesContent":["const path = require('path')\nconst util = require('util')\nconst log = require('npmlog')\nconst npa = require('npm-package-arg')\nconst libaccess = require('libnpmaccess')\nconst npmFetch = require('npm-registry-fetch')\nconst libunpub = require('libnpmpublish').unpublish\nconst readJson = util.promisify(require('read-package-json'))\n\nconst otplease = require('./utils/otplease.js')\nconst getIdentity = require('./utils/get-identity.js')\n\nconst BaseCommand = require('./base-command.js')\nclass Unpublish extends BaseCommand {\n  static get description () {\n    return 'Remove a package from the registry'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get name () {\n    return 'unpublish'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get usage () {\n    return ['[<@scope>/]<pkg>[@<version>]']\n  }\n\n  async completion (args) {\n    const { partialWord, conf } = args\n\n    if (conf.argv.remain.length >= 3)\n      return []\n\n    const opts = this.npm.flatOptions\n    const username = await getIdentity(this.npm, { ...opts }).catch(() => null)\n    if (!username)\n      return []\n\n    const access = await libaccess.lsPackages(username, opts)\n    // do a bit of filtering at this point, so that we don't need\n    // to fetch versions for more than one thing, but also don't\n    // accidentally unpublish a whole project\n    let pkgs = Object.keys(access || {})\n    if (!partialWord || !pkgs.length)\n      return pkgs\n\n    const pp = npa(partialWord).name\n    pkgs = pkgs.filter(p => !p.indexOf(pp))\n    if (pkgs.length > 1)\n      return pkgs\n\n    const json = await npmFetch.json(npa(pkgs[0]).escapedName, opts)\n    const versions = Object.keys(json.versions)\n    if (!versions.length)\n      return pkgs\n    else\n      return versions.map(v => `${pkgs[0]}@${v}`)\n  }\n\n  exec (args, cb) {\n    this.unpublish(args).then(() => cb()).catch(cb)\n  }\n\n  async unpublish (args) {\n    if (args.length > 1)\n      throw new Error(this.usage)\n\n    const spec = args.length && npa(args[0])\n    const force = this.npm.config.get('force')\n    const silent = this.npm.config.get('silent')\n    const loglevel = this.npm.config.get('loglevel')\n    let pkgName\n    let pkgVersion\n\n    log.silly('unpublish', 'args[0]', args[0])\n    log.silly('unpublish', 'spec', spec)\n\n    if (!spec.rawSpec && !force) {\n      throw new Error(\n        'Refusing to delete entire project.\\n' +\n        'Run with --force to do this.\\n' +\n        this.usage\n      )\n    }\n\n    const opts = this.npm.flatOptions\n    if (!spec || path.resolve(spec.name) === this.npm.localPrefix) {\n      // if there's a package.json in the current folder, then\n      // read the package name and version out of that.\n      const pkgJson = path.join(this.npm.localPrefix, 'package.json')\n      let manifest\n      try {\n        manifest = await readJson(pkgJson)\n      } catch (err) {\n        if (err && err.code !== 'ENOENT' && err.code !== 'ENOTDIR')\n          throw err\n        else\n          throw new Error(`Usage: ${this.usage}`)\n      }\n\n      log.verbose('unpublish', manifest)\n\n      const { name, version, publishConfig } = manifest\n      const pkgJsonSpec = npa.resolve(name, version)\n      const optsWithPub = { ...opts, publishConfig }\n      await otplease(opts, opts => libunpub(pkgJsonSpec, optsWithPub))\n      pkgName = name\n      pkgVersion = version ? `@${version}` : ''\n    } else {\n      await otplease(opts, opts => libunpub(spec, opts))\n      pkgName = spec.name\n      pkgVersion = spec.type === 'version' ? `@${spec.rawSpec}` : ''\n    }\n\n    if (!silent && loglevel !== 'silent')\n      this.npm.output(`- ${pkgName}${pkgVersion}`)\n  }\n}\nmodule.exports = Unpublish\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"// mix-in implementing the loadActual method\nconst {\n  relative,\n  dirname,\n  resolve,\n  join,\n  normalize\n} = require('path');\n\nconst rpj = require('read-package-json-fast');\n\nconst {\n  promisify\n} = require('util');\n\nconst readdir = promisify(require('readdir-scoped-modules'));\n\nconst walkUp = require('walk-up-path');\n\nconst ancestorPath = require('common-ancestor-path');\n\nconst treeCheck = require('../tree-check.js');\n\nconst Shrinkwrap = require('../shrinkwrap.js');\n\nconst calcDepFlags = require('../calc-dep-flags.js');\n\nconst Node = require('../node.js');\n\nconst Link = require('../link.js');\n\nconst realpath = require('../realpath.js');\n\nconst _loadFSNode = Symbol('loadFSNode');\n\nconst _newNode = Symbol('newNode');\n\nconst _newLink = Symbol('newLink');\n\nconst _loadFSTree = Symbol('loadFSTree');\n\nconst _loadFSChildren = Symbol('loadFSChildren');\n\nconst _findMissingEdges = Symbol('findMissingEdges');\n\nconst _findFSParents = Symbol('findFSParents');\n\nconst _actualTreeLoaded = Symbol('actualTreeLoaded');\n\nconst _rpcache = Symbol.for('realpathCache');\n\nconst _stcache = Symbol.for('statCache');\n\nconst _topNodes = Symbol('linkTargets');\n\nconst _cache = Symbol('nodeLoadingCache');\n\nconst _loadActual = Symbol('loadActual');\n\nconst _loadActualVirtually = Symbol('loadActualVirtually');\n\nconst _loadActualActually = Symbol('loadActualActually');\n\nconst _loadWorkspaces = Symbol.for('loadWorkspaces');\n\nconst _loadWorkspaceTargets = Symbol('loadWorkspaceTargets');\n\nconst _actualTreePromise = Symbol('actualTreePromise');\n\nconst _actualTree = Symbol('actualTree');\n\nconst _transplant = Symbol('transplant');\n\nconst _transplantFilter = Symbol('transplantFilter');\n\nconst _filter = Symbol('filter');\n\nconst _global = Symbol.for('global');\n\nconst _changePath = Symbol.for('_changePath');\n\nmodule.exports = cls => class ActualLoader extends cls {\n  constructor(options) {\n    super(options);\n    this[_global] = !!options.global; // the tree of nodes on disk\n\n    this.actualTree = options.actualTree; // ensure when walking the tree that we don't call loadTree on the\n    // same actual node more than one time.\n\n    this[_actualTreeLoaded] = new Set(); // caches for cached realpath calls\n\n    const cwd = process.cwd(); // assume that the cwd is real enough for our purposes\n\n    this[_rpcache] = new Map([[cwd, cwd]]);\n    this[_stcache] = new Map(); // cache of nodes when loading the actualTree, so that we avoid\n    // loaded the same node multiple times when symlinks attack.\n\n    this[_cache] = new Map(); // cache of link targets for setting fsParent links\n    // We don't do fsParent as a magic getter/setter, because\n    // it'd be too costly to keep up to date along the walk.\n    // And, we know that it can ONLY be relevant when the node\n    // is a target of a link, otherwise it'd be in a node_modules\n    // folder, so take advantage of that to limit the scans later.\n\n    this[_topNodes] = new Set();\n  } // public method\n\n\n  async loadActual(options = {}) {\n    // allow the user to set options on the ctor as well.\n    // XXX: deprecate separate method options objects.\n    options = { ...this.options,\n      ...options\n    }; // stash the promise so that we don't ever have more than one\n    // going at the same time.  This is so that buildIdealTree can\n    // default to the actualTree if no shrinkwrap present, but\n    // reify() can still call buildIdealTree and loadActual in parallel\n    // safely.\n\n    return this.actualTree ? this.actualTree : this[_actualTreePromise] ? this[_actualTreePromise] : this[_actualTreePromise] = this[_loadActual](options).then(tree => this.actualTree = treeCheck(tree));\n  }\n\n  async [_loadActual](options) {\n    // mostly realpath to throw if the root doesn't exist\n    const {\n      global = false,\n      filter = () => true,\n      root = null,\n      transplantFilter = () => true,\n      ignoreMissing = false\n    } = options;\n    this[_filter] = filter;\n    this[_transplantFilter] = transplantFilter;\n\n    if (global) {\n      const real = await realpath(this.path, this[_rpcache], this[_stcache]);\n      const newNodeOrLink = this.path === real ? _newNode : _newLink;\n      this[_actualTree] = await this[newNodeOrLink]({\n        path: this.path,\n        realpath: real,\n        pkg: {},\n        global\n      });\n      return this[_loadActualActually]({\n        root,\n        ignoreMissing,\n        global\n      });\n    } // not in global mode, hidden lockfile is allowed, load root pkg too\n\n\n    this[_actualTree] = await this[_loadFSNode]({\n      path: this.path,\n      real: await realpath(this.path, this[_rpcache], this[_stcache])\n    }); // XXX only rely on this if the hidden lockfile is the newest thing?\n    // need some kind of heuristic, like if the package.json or sw have\n    // been touched more recently, then ignore it?  This is a hazard if\n    // user switches back and forth between Arborist and another way of\n    // mutating the node_modules folder.\n\n    const meta = await Shrinkwrap.load({\n      path: this[_actualTree].path,\n      hiddenLockfile: true\n    });\n\n    if (meta.loadedFromDisk) {\n      this[_actualTree].meta = meta;\n      return this[_loadActualVirtually]({\n        root\n      });\n    } else {\n      const meta = await Shrinkwrap.load({\n        path: this[_actualTree].path\n      });\n      this[_actualTree].meta = meta;\n      return this[_loadActualActually]({\n        root,\n        ignoreMissing\n      });\n    }\n  }\n\n  async [_loadActualVirtually]({\n    root\n  }) {\n    // have to load on a new Arborist object, so we don't assign\n    // the virtualTree on this one!  Also, the weird reference is because\n    // we can't easily get a ref to Arborist in this module, without\n    // creating a circular reference, since this class is a mixin used\n    // to build up the Arborist class itself.\n    await new this.constructor({ ...this.options\n    }).loadVirtual({\n      root: this[_actualTree]\n    });\n    await this[_loadWorkspaces](this[_actualTree]);\n    if (this[_actualTree].workspaces && this[_actualTree].workspaces.size) calcDepFlags(this[_actualTree], !root);\n\n    this[_transplant](root);\n\n    return this[_actualTree];\n  }\n\n  async [_loadActualActually]({\n    root,\n    ignoreMissing,\n    global\n  }) {\n    await this[_loadFSTree](this[_actualTree]);\n    await this[_loadWorkspaces](this[_actualTree]);\n    await this[_loadWorkspaceTargets](this[_actualTree]);\n    if (!ignoreMissing) await this[_findMissingEdges]();\n\n    this[_findFSParents]();\n\n    this[_transplant](root);\n\n    if (global) {\n      // need to depend on the children, or else all of them\n      // will end up being flagged as extraneous, since the\n      // global root isn't a \"real\" project\n      const tree = this[_actualTree];\n      const actualRoot = tree.isLink ? tree.target : tree;\n      const {\n        dependencies = {}\n      } = actualRoot.package;\n\n      for (const name of actualRoot.children.keys()) dependencies[name] = dependencies[name] || '*';\n\n      actualRoot.package = { ...actualRoot.package,\n        dependencies\n      };\n    } // only reset root flags if we're not re-rooting, otherwise leave as-is\n\n\n    calcDepFlags(this[_actualTree], !root);\n    return this[_actualTree];\n  } // if there are workspace targets without Link nodes created, load\n  // the targets, so that we know what they are.\n\n\n  async [_loadWorkspaceTargets](tree) {\n    if (!tree.workspaces || !tree.workspaces.size) return;\n    const promises = [];\n\n    for (const path of tree.workspaces.values()) {\n      if (!this[_cache].has(path)) {\n        const p = this[_loadFSNode]({\n          path,\n          root: this[_actualTree]\n        }).then(node => this[_loadFSTree](node));\n\n        promises.push(p);\n      }\n    }\n\n    await Promise.all(promises);\n  }\n\n  [_transplant](root) {\n    if (!root || root === this[_actualTree]) return;\n\n    this[_actualTree][_changePath](root.path);\n\n    for (const node of this[_actualTree].children.values()) {\n      if (!this[_transplantFilter](node)) node.root = null;\n    }\n\n    root.replace(this[_actualTree]);\n\n    for (const node of this[_actualTree].fsChildren) node.root = this[_transplantFilter](node) ? root : null;\n\n    this[_actualTree] = root;\n  }\n\n  [_loadFSNode]({\n    path,\n    parent,\n    real,\n    root\n  }) {\n    if (!real) {\n      return realpath(path, this[_rpcache], this[_stcache]).then(real => this[_loadFSNode]({\n        path,\n        parent,\n        real,\n        root\n      }), // if realpath fails, just provide a dummy error node\n      error => new Node({\n        error,\n        path,\n        realpath: path,\n        parent,\n        root\n      }));\n    } // cache temporarily holds a promise placeholder so we don't try to create\n    // the same node multiple times.  this is rare to encounter, given the\n    // aggressive caching on realpath and lstat calls, but it's possible that\n    // it's already loaded as a tree top, and then gets its parent loaded\n    // later, if a symlink points deeper in the tree.\n\n\n    const cached = this[_cache].get(path);\n\n    if (cached && !cached.dummy) {\n      return Promise.resolve(cached).then(node => {\n        node.parent = parent;\n        return node;\n      });\n    }\n\n    const p = rpj(join(real, 'package.json')) // soldier on if read-package-json raises an error\n    .then(pkg => [pkg, null], error => [null, error]).then(([pkg, error]) => {\n      return this[normalize(path) === real ? _newNode : _newLink]({\n        legacyPeerDeps: this.legacyPeerDeps,\n        path,\n        realpath: real,\n        pkg,\n        error,\n        parent,\n        root\n      });\n    }).then(node => {\n      this[_cache].set(path, node);\n\n      return node;\n    });\n\n    this[_cache].set(path, p);\n\n    return p;\n  } // this is the way it is to expose a timing issue which is difficult to\n  // test otherwise.  The creation of a Node may take slightly longer than\n  // the creation of a Link that targets it.  If the Node has _begun_ its\n  // creation phase (and put a Promise in the cache) then the Link will\n  // get a Promise as its cachedTarget instead of an actual Node object.\n  // This is not a problem, because it gets resolved prior to returning\n  // the tree or attempting to load children.  However, it IS remarkably\n  // difficult to get to happen in a test environment to verify reliably.\n  // Hence this kludge.\n\n\n  [_newNode](options) {\n    // check it for an fsParent if it's a tree top.  there's a decent chance\n    // it'll get parented later, making the fsParent scan a no-op, but better\n    // safe than sorry, since it's cheap.\n    const {\n      parent,\n      realpath\n    } = options;\n    if (!parent) this[_topNodes].add(realpath);\n    return process.env._TEST_ARBORIST_SLOW_LINK_TARGET_ === '1' ? new Promise(res => setTimeout(() => res(new Node(options)), 100)) : new Node(options);\n  }\n\n  [_newLink](options) {\n    const {\n      realpath\n    } = options;\n\n    this[_topNodes].add(realpath);\n\n    const target = this[_cache].get(realpath);\n\n    const link = new Link({ ...options,\n      target\n    });\n\n    if (!target) {\n      this[_cache].set(realpath, link.target); // if a link target points at a node outside of the root tree's\n      // node_modules hierarchy, then load that node as well.\n\n\n      return this[_loadFSTree](link.target).then(() => link);\n    } else if (target.then) target.then(node => link.target = node);\n\n    return link;\n  }\n\n  [_loadFSTree](node) {\n    const did = this[_actualTreeLoaded];\n    node = node.target || node; // if a Link target has started, but not completed, then\n    // a Promise will be in the cache to indicate this.\n\n    if (node.then) return node.then(node => this[_loadFSTree](node)); // impossible except in pathological ELOOP cases\n\n    /* istanbul ignore if */\n\n    if (did.has(node.realpath)) return Promise.resolve(node);\n    did.add(node.realpath);\n    return this[_loadFSChildren](node).then(() => Promise.all([...node.children.entries()].filter(([name, kid]) => !did.has(kid.realpath)).map(([name, kid]) => this[_loadFSTree](kid))));\n  } // create child nodes for all the entries in node_modules\n  // and attach them to the node as a parent\n\n\n  [_loadFSChildren](node) {\n    const nm = resolve(node.realpath, 'node_modules');\n    return readdir(nm).then(kids => {\n      return Promise.all( // ignore . dirs and retired scoped package folders\n      kids.filter(kid => !/^(@[^/]+\\/)?\\./.test(kid)).filter(kid => this[_filter](node, kid)).map(kid => this[_loadFSNode]({\n        parent: node,\n        path: resolve(nm, kid)\n      })));\n    }, // error in the readdir is not fatal, just means no kids\n    () => {});\n  }\n\n  async [_findMissingEdges]() {\n    // try to resolve any missing edges by walking up the directory tree,\n    // checking for the package in each node_modules folder.  stop at the\n    // root directory.\n    // The tricky move here is that we load a \"dummy\" node for the folder\n    // containing the node_modules folder, so that it can be assigned as\n    // the fsParent.  It's a bad idea to *actually* load that full node,\n    // because people sometimes develop in ~/projects/node_modules/...\n    // so we'd end up loading a massive tree with lots of unrelated junk.\n    const nmContents = new Map();\n    const tree = this[_actualTree];\n\n    for (const node of tree.inventory.values()) {\n      const ancestor = ancestorPath(node.realpath, this.path);\n      const depPromises = [];\n\n      for (const [name, edge] of node.edgesOut.entries()) {\n        if (!edge.missing && !(edge.to && (edge.to.dummy || edge.to.parent !== node))) continue; // start the walk from the dirname, because we would have found\n        // the dep in the loadFSTree step already if it was local.\n\n        for (const p of walkUp(dirname(node.realpath))) {\n          // only walk as far as the nearest ancestor\n          // this keeps us from going into completely unrelated\n          // places when a project is just missing something, but\n          // allows for finding the transitive deps of link targets.\n          // ie, if it has to go up and back out to get to the path\n          // from the nearest common ancestor, we've gone too far.\n          if (ancestor && /^\\.\\.(?:[\\\\/]|$)/.test(relative(ancestor, p))) break;\n          const entries = nmContents.get(p) || (await readdir(p + '/node_modules').catch(() => []));\n          nmContents.set(p, entries);\n          if (!entries.includes(name)) continue;\n          const d = this[_cache].has(p) ? await this[_cache].get(p) : new Node({\n            path: p,\n            root: node.root,\n            dummy: true\n          });\n\n          this[_cache].set(p, d);\n\n          if (d.dummy) {\n            // it's a placeholder, so likely would not have loaded this dep,\n            // unless another dep in the tree also needs it.\n            const depPath = `${p}/node_modules/${name}`;\n\n            const cached = this[_cache].get(depPath);\n\n            if (!cached || cached.dummy) {\n              depPromises.push(this[_loadFSNode]({\n                path: depPath,\n                root: node.root,\n                parent: d\n              }).then(node => this[_loadFSTree](node)));\n            }\n          }\n\n          break;\n        }\n      }\n\n      await Promise.all(depPromises);\n    }\n  } // try to find a node that is the parent in a fs tree sense, but not a\n  // node_modules tree sense, of any link targets.  this allows us to\n  // resolve deps that node will find, but a legacy npm view of the\n  // world would not have noticed.\n\n\n  [_findFSParents]() {\n    for (const path of this[_topNodes]) {\n      const node = this[_cache].get(path);\n\n      if (node && !node.parent && !node.fsParent) {\n        for (const p of walkUp(dirname(path))) {\n          if (this[_cache].has(p)) {\n            node.fsParent = this[_cache].get(p);\n            break;\n          }\n        }\n      }\n    }\n  }\n\n};","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/node_modules/@npmcli/arborist/lib/arborist/load-actual.js"],"names":["relative","dirname","resolve","join","normalize","require","rpj","promisify","readdir","walkUp","ancestorPath","treeCheck","Shrinkwrap","calcDepFlags","Node","Link","realpath","_loadFSNode","Symbol","_newNode","_newLink","_loadFSTree","_loadFSChildren","_findMissingEdges","_findFSParents","_actualTreeLoaded","_rpcache","for","_stcache","_topNodes","_cache","_loadActual","_loadActualVirtually","_loadActualActually","_loadWorkspaces","_loadWorkspaceTargets","_actualTreePromise","_actualTree","_transplant","_transplantFilter","_filter","_global","_changePath","module","exports","cls","ActualLoader","constructor","options","global","actualTree","Set","cwd","process","Map","loadActual","then","tree","filter","root","transplantFilter","ignoreMissing","real","path","newNodeOrLink","pkg","meta","load","hiddenLockfile","loadedFromDisk","loadVirtual","workspaces","size","actualRoot","isLink","target","dependencies","package","name","children","keys","promises","values","has","p","node","push","Promise","all","replace","fsChildren","parent","error","cached","get","dummy","legacyPeerDeps","set","add","env","_TEST_ARBORIST_SLOW_LINK_TARGET_","res","setTimeout","link","did","entries","kid","map","nm","kids","test","nmContents","inventory","ancestor","depPromises","edge","edgesOut","missing","to","catch","includes","d","depPath","fsParent"],"mappings":"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","sourcesContent":["// mix-in implementing the loadActual method\n\nconst {relative, dirname, resolve, join, normalize} = require('path')\n\nconst rpj = require('read-package-json-fast')\nconst {promisify} = require('util')\nconst readdir = promisify(require('readdir-scoped-modules'))\nconst walkUp = require('walk-up-path')\nconst ancestorPath = require('common-ancestor-path')\nconst treeCheck = require('../tree-check.js')\n\nconst Shrinkwrap = require('../shrinkwrap.js')\nconst calcDepFlags = require('../calc-dep-flags.js')\nconst Node = require('../node.js')\nconst Link = require('../link.js')\nconst realpath = require('../realpath.js')\n\nconst _loadFSNode = Symbol('loadFSNode')\nconst _newNode = Symbol('newNode')\nconst _newLink = Symbol('newLink')\nconst _loadFSTree = Symbol('loadFSTree')\nconst _loadFSChildren = Symbol('loadFSChildren')\nconst _findMissingEdges = Symbol('findMissingEdges')\nconst _findFSParents = Symbol('findFSParents')\n\nconst _actualTreeLoaded = Symbol('actualTreeLoaded')\nconst _rpcache = Symbol.for('realpathCache')\nconst _stcache = Symbol.for('statCache')\nconst _topNodes = Symbol('linkTargets')\nconst _cache = Symbol('nodeLoadingCache')\nconst _loadActual = Symbol('loadActual')\nconst _loadActualVirtually = Symbol('loadActualVirtually')\nconst _loadActualActually = Symbol('loadActualActually')\nconst _loadWorkspaces = Symbol.for('loadWorkspaces')\nconst _loadWorkspaceTargets = Symbol('loadWorkspaceTargets')\nconst _actualTreePromise = Symbol('actualTreePromise')\nconst _actualTree = Symbol('actualTree')\nconst _transplant = Symbol('transplant')\nconst _transplantFilter = Symbol('transplantFilter')\n\nconst _filter = Symbol('filter')\nconst _global = Symbol.for('global')\nconst _changePath = Symbol.for('_changePath')\n\nmodule.exports = cls => class ActualLoader extends cls {\n  constructor (options) {\n    super(options)\n\n    this[_global] = !!options.global\n\n    // the tree of nodes on disk\n    this.actualTree = options.actualTree\n\n    // ensure when walking the tree that we don't call loadTree on the\n    // same actual node more than one time.\n    this[_actualTreeLoaded] = new Set()\n\n    // caches for cached realpath calls\n    const cwd = process.cwd()\n    // assume that the cwd is real enough for our purposes\n    this[_rpcache] = new Map([[cwd, cwd]])\n    this[_stcache] = new Map()\n\n    // cache of nodes when loading the actualTree, so that we avoid\n    // loaded the same node multiple times when symlinks attack.\n    this[_cache] = new Map()\n\n    // cache of link targets for setting fsParent links\n    // We don't do fsParent as a magic getter/setter, because\n    // it'd be too costly to keep up to date along the walk.\n    // And, we know that it can ONLY be relevant when the node\n    // is a target of a link, otherwise it'd be in a node_modules\n    // folder, so take advantage of that to limit the scans later.\n    this[_topNodes] = new Set()\n  }\n\n  // public method\n  async loadActual (options = {}) {\n    // allow the user to set options on the ctor as well.\n    // XXX: deprecate separate method options objects.\n    options = { ...this.options, ...options }\n\n    // stash the promise so that we don't ever have more than one\n    // going at the same time.  This is so that buildIdealTree can\n    // default to the actualTree if no shrinkwrap present, but\n    // reify() can still call buildIdealTree and loadActual in parallel\n    // safely.\n    return this.actualTree ? this.actualTree\n      : this[_actualTreePromise] ? this[_actualTreePromise]\n      : this[_actualTreePromise] = this[_loadActual](options)\n        .then(tree => this.actualTree = treeCheck(tree))\n  }\n\n  async [_loadActual] (options) {\n    // mostly realpath to throw if the root doesn't exist\n    const {\n      global = false,\n      filter = () => true,\n      root = null,\n      transplantFilter = () => true,\n      ignoreMissing = false,\n    } = options\n    this[_filter] = filter\n    this[_transplantFilter] = transplantFilter\n\n    if (global) {\n      const real = await realpath(this.path, this[_rpcache], this[_stcache])\n      const newNodeOrLink = this.path === real ? _newNode : _newLink\n      this[_actualTree] = await this[newNodeOrLink]({\n        path: this.path,\n        realpath: real,\n        pkg: {},\n        global,\n      })\n      return this[_loadActualActually]({root, ignoreMissing, global})\n    }\n\n    // not in global mode, hidden lockfile is allowed, load root pkg too\n    this[_actualTree] = await this[_loadFSNode]({\n      path: this.path,\n      real: await realpath(this.path, this[_rpcache], this[_stcache]),\n    })\n\n    // XXX only rely on this if the hidden lockfile is the newest thing?\n    // need some kind of heuristic, like if the package.json or sw have\n    // been touched more recently, then ignore it?  This is a hazard if\n    // user switches back and forth between Arborist and another way of\n    // mutating the node_modules folder.\n    const meta = await Shrinkwrap.load({\n      path: this[_actualTree].path,\n      hiddenLockfile: true,\n    })\n    if (meta.loadedFromDisk) {\n      this[_actualTree].meta = meta\n      return this[_loadActualVirtually]({ root })\n    } else {\n      const meta = await Shrinkwrap.load({\n        path: this[_actualTree].path,\n      })\n      this[_actualTree].meta = meta\n      return this[_loadActualActually]({ root, ignoreMissing })\n    }\n  }\n\n  async [_loadActualVirtually] ({ root }) {\n    // have to load on a new Arborist object, so we don't assign\n    // the virtualTree on this one!  Also, the weird reference is because\n    // we can't easily get a ref to Arborist in this module, without\n    // creating a circular reference, since this class is a mixin used\n    // to build up the Arborist class itself.\n    await new this.constructor({...this.options}).loadVirtual({\n      root: this[_actualTree],\n    })\n    await this[_loadWorkspaces](this[_actualTree])\n    if (this[_actualTree].workspaces && this[_actualTree].workspaces.size)\n      calcDepFlags(this[_actualTree], !root)\n    this[_transplant](root)\n    return this[_actualTree]\n  }\n\n  async [_loadActualActually] ({ root, ignoreMissing, global }) {\n    await this[_loadFSTree](this[_actualTree])\n    await this[_loadWorkspaces](this[_actualTree])\n    await this[_loadWorkspaceTargets](this[_actualTree])\n    if (!ignoreMissing)\n      await this[_findMissingEdges]()\n    this[_findFSParents]()\n    this[_transplant](root)\n\n    if (global) {\n      // need to depend on the children, or else all of them\n      // will end up being flagged as extraneous, since the\n      // global root isn't a \"real\" project\n      const tree = this[_actualTree]\n      const actualRoot = tree.isLink ? tree.target : tree\n      const { dependencies = {} } = actualRoot.package\n      for (const name of actualRoot.children.keys())\n        dependencies[name] = dependencies[name] || '*'\n      actualRoot.package = { ...actualRoot.package, dependencies }\n    }\n    // only reset root flags if we're not re-rooting, otherwise leave as-is\n    calcDepFlags(this[_actualTree], !root)\n    return this[_actualTree]\n  }\n\n  // if there are workspace targets without Link nodes created, load\n  // the targets, so that we know what they are.\n  async [_loadWorkspaceTargets] (tree) {\n    if (!tree.workspaces || !tree.workspaces.size)\n      return\n\n    const promises = []\n    for (const path of tree.workspaces.values()) {\n      if (!this[_cache].has(path)) {\n        const p = this[_loadFSNode]({ path, root: this[_actualTree] })\n          .then(node => this[_loadFSTree](node))\n        promises.push(p)\n      }\n    }\n    await Promise.all(promises)\n  }\n\n  [_transplant] (root) {\n    if (!root || root === this[_actualTree])\n      return\n\n    this[_actualTree][_changePath](root.path)\n    for (const node of this[_actualTree].children.values()) {\n      if (!this[_transplantFilter](node))\n        node.root = null\n    }\n\n    root.replace(this[_actualTree])\n    for (const node of this[_actualTree].fsChildren)\n      node.root = this[_transplantFilter](node) ? root : null\n\n    this[_actualTree] = root\n  }\n\n  [_loadFSNode] ({ path, parent, real, root }) {\n    if (!real) {\n      return realpath(path, this[_rpcache], this[_stcache])\n        .then(\n          real => this[_loadFSNode]({ path, parent, real, root }),\n          // if realpath fails, just provide a dummy error node\n          error => new Node({ error, path, realpath: path, parent, root })\n        )\n    }\n\n    // cache temporarily holds a promise placeholder so we don't try to create\n    // the same node multiple times.  this is rare to encounter, given the\n    // aggressive caching on realpath and lstat calls, but it's possible that\n    // it's already loaded as a tree top, and then gets its parent loaded\n    // later, if a symlink points deeper in the tree.\n    const cached = this[_cache].get(path)\n    if (cached && !cached.dummy) {\n      return Promise.resolve(cached).then(node => {\n        node.parent = parent\n        return node\n      })\n    }\n\n    const p = rpj(join(real, 'package.json'))\n      // soldier on if read-package-json raises an error\n      .then(pkg => [pkg, null], error => [null, error])\n      .then(([pkg, error]) => {\n        return this[normalize(path) === real ? _newNode : _newLink]({\n          legacyPeerDeps: this.legacyPeerDeps,\n          path,\n          realpath: real,\n          pkg,\n          error,\n          parent,\n          root,\n        })\n      })\n      .then(node => {\n        this[_cache].set(path, node)\n        return node\n      })\n\n    this[_cache].set(path, p)\n    return p\n  }\n\n  // this is the way it is to expose a timing issue which is difficult to\n  // test otherwise.  The creation of a Node may take slightly longer than\n  // the creation of a Link that targets it.  If the Node has _begun_ its\n  // creation phase (and put a Promise in the cache) then the Link will\n  // get a Promise as its cachedTarget instead of an actual Node object.\n  // This is not a problem, because it gets resolved prior to returning\n  // the tree or attempting to load children.  However, it IS remarkably\n  // difficult to get to happen in a test environment to verify reliably.\n  // Hence this kludge.\n  [_newNode] (options) {\n    // check it for an fsParent if it's a tree top.  there's a decent chance\n    // it'll get parented later, making the fsParent scan a no-op, but better\n    // safe than sorry, since it's cheap.\n    const { parent, realpath } = options\n    if (!parent)\n      this[_topNodes].add(realpath)\n    return process.env._TEST_ARBORIST_SLOW_LINK_TARGET_ === '1'\n      ? new Promise(res => setTimeout(() => res(new Node(options)), 100))\n      : new Node(options)\n  }\n\n  [_newLink] (options) {\n    const { realpath } = options\n    this[_topNodes].add(realpath)\n    const target = this[_cache].get(realpath)\n    const link = new Link({ ...options, target })\n\n    if (!target) {\n      this[_cache].set(realpath, link.target)\n      // if a link target points at a node outside of the root tree's\n      // node_modules hierarchy, then load that node as well.\n      return this[_loadFSTree](link.target).then(() => link)\n    } else if (target.then)\n      target.then(node => link.target = node)\n\n    return link\n  }\n\n  [_loadFSTree] (node) {\n    const did = this[_actualTreeLoaded]\n    node = node.target || node\n\n    // if a Link target has started, but not completed, then\n    // a Promise will be in the cache to indicate this.\n    if (node.then)\n      return node.then(node => this[_loadFSTree](node))\n\n    // impossible except in pathological ELOOP cases\n    /* istanbul ignore if */\n    if (did.has(node.realpath))\n      return Promise.resolve(node)\n\n    did.add(node.realpath)\n    return this[_loadFSChildren](node)\n      .then(() => Promise.all(\n        [...node.children.entries()]\n          .filter(([name, kid]) => !did.has(kid.realpath))\n          .map(([name, kid]) => this[_loadFSTree](kid))))\n  }\n\n  // create child nodes for all the entries in node_modules\n  // and attach them to the node as a parent\n  [_loadFSChildren] (node) {\n    const nm = resolve(node.realpath, 'node_modules')\n    return readdir(nm).then(kids => {\n      return Promise.all(\n      // ignore . dirs and retired scoped package folders\n        kids.filter(kid => !/^(@[^/]+\\/)?\\./.test(kid))\n          .filter(kid => this[_filter](node, kid))\n          .map(kid => this[_loadFSNode]({\n            parent: node,\n            path: resolve(nm, kid),\n          })))\n    },\n    // error in the readdir is not fatal, just means no kids\n    () => {})\n  }\n\n  async [_findMissingEdges] () {\n    // try to resolve any missing edges by walking up the directory tree,\n    // checking for the package in each node_modules folder.  stop at the\n    // root directory.\n    // The tricky move here is that we load a \"dummy\" node for the folder\n    // containing the node_modules folder, so that it can be assigned as\n    // the fsParent.  It's a bad idea to *actually* load that full node,\n    // because people sometimes develop in ~/projects/node_modules/...\n    // so we'd end up loading a massive tree with lots of unrelated junk.\n    const nmContents = new Map()\n    const tree = this[_actualTree]\n    for (const node of tree.inventory.values()) {\n      const ancestor = ancestorPath(node.realpath, this.path)\n\n      const depPromises = []\n      for (const [name, edge] of node.edgesOut.entries()) {\n        if (!edge.missing && !(edge.to && (edge.to.dummy || edge.to.parent !== node)))\n          continue\n\n        // start the walk from the dirname, because we would have found\n        // the dep in the loadFSTree step already if it was local.\n        for (const p of walkUp(dirname(node.realpath))) {\n          // only walk as far as the nearest ancestor\n          // this keeps us from going into completely unrelated\n          // places when a project is just missing something, but\n          // allows for finding the transitive deps of link targets.\n          // ie, if it has to go up and back out to get to the path\n          // from the nearest common ancestor, we've gone too far.\n          if (ancestor && /^\\.\\.(?:[\\\\/]|$)/.test(relative(ancestor, p)))\n            break\n\n          const entries = nmContents.get(p) ||\n            await readdir(p + '/node_modules').catch(() => [])\n          nmContents.set(p, entries)\n          if (!entries.includes(name))\n            continue\n\n          const d = this[_cache].has(p) ? await this[_cache].get(p)\n            : new Node({ path: p, root: node.root, dummy: true })\n          this[_cache].set(p, d)\n          if (d.dummy) {\n            // it's a placeholder, so likely would not have loaded this dep,\n            // unless another dep in the tree also needs it.\n            const depPath = `${p}/node_modules/${name}`\n            const cached = this[_cache].get(depPath)\n            if (!cached || cached.dummy) {\n              depPromises.push(this[_loadFSNode]({\n                path: depPath,\n                root: node.root,\n                parent: d,\n              }).then(node => this[_loadFSTree](node)))\n            }\n          }\n          break\n        }\n      }\n      await Promise.all(depPromises)\n    }\n  }\n\n  // try to find a node that is the parent in a fs tree sense, but not a\n  // node_modules tree sense, of any link targets.  this allows us to\n  // resolve deps that node will find, but a legacy npm view of the\n  // world would not have noticed.\n  [_findFSParents] () {\n    for (const path of this[_topNodes]) {\n      const node = this[_cache].get(path)\n      if (node && !node.parent && !node.fsParent) {\n        for (const p of walkUp(dirname(path))) {\n          if (this[_cache].has(p)) {\n            node.fsParent = this[_cache].get(p)\n            break\n          }\n        }\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}
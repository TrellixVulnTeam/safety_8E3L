{"ast":null,"code":"'use strict';\n\nconst URL = require('url').URL;\n\nconst Arborist = require('@npmcli/arborist'); // supports object funding and string shorthand, or an array of these\n// if original was an array, returns an array; else returns the lone item\n\n\nfunction normalizeFunding(funding) {\n  const normalizeItem = item => typeof item === 'string' ? {\n    url: item\n  } : item;\n\n  const sources = [].concat(funding || []).map(normalizeItem);\n  return Array.isArray(funding) ? sources : sources[0];\n} // Is the value of a `funding` property of a `package.json`\n// a valid type+url for `npm fund` to display?\n\n\nfunction isValidFunding(funding) {\n  if (!funding) return false;\n\n  if (Array.isArray(funding)) {\n    return funding.every(f => !Array.isArray(f) && isValidFunding(f));\n  }\n\n  try {\n    var parsed = new URL(funding.url || funding);\n  } catch (error) {\n    return false;\n  }\n\n  if (parsed.protocol !== 'https:' && parsed.protocol !== 'http:') return false;\n  return Boolean(parsed.host);\n}\n\nconst empty = () => Object.create(null);\n\nfunction readTree(tree, opts) {\n  let packageWithFundingCount = 0;\n  const seen = new Set();\n  const {\n    countOnly\n  } = opts || {};\n\n  const _trailingDependencies = Symbol('trailingDependencies');\n\n  function tracked(name, version) {\n    const key = String(name) + String(version);\n\n    if (seen.has(key)) {\n      return true;\n    }\n\n    seen.add(key);\n  }\n\n  function retrieveDependencies(dependencies) {\n    const trailing = dependencies[_trailingDependencies];\n\n    if (trailing) {\n      return Object.assign(empty(), dependencies, trailing);\n    }\n\n    return dependencies;\n  }\n\n  function hasDependencies(dependencies) {\n    return dependencies && (Object.keys(dependencies).length || dependencies[_trailingDependencies]);\n  }\n\n  function attachFundingInfo(target, funding) {\n    if (funding && isValidFunding(funding)) {\n      target.funding = normalizeFunding(funding);\n      packageWithFundingCount++;\n    }\n  }\n\n  function getFundingDependencies(tree) {\n    const edges = tree && tree.edgesOut && tree.edgesOut.values();\n    if (!edges) return empty();\n    const directDepsWithFunding = Array.from(edges).map(edge => {\n      if (!edge || !edge.to) return empty();\n      const node = edge.to.target || edge.to;\n      if (!node.package) return empty();\n      const {\n        name,\n        funding,\n        version\n      } = node.package; // avoids duplicated items within the funding tree\n\n      if (tracked(name, version)) return empty();\n      const fundingItem = {};\n\n      if (version) {\n        fundingItem.version = version;\n      }\n\n      attachFundingInfo(fundingItem, funding);\n      return {\n        node,\n        fundingItem\n      };\n    });\n    return directDepsWithFunding.reduce((res, {\n      node,\n      fundingItem\n    }, i) => {\n      if (!fundingItem || fundingItem.length === 0 || !node) return res; // recurse\n\n      const transitiveDependencies = node.edgesOut && node.edgesOut.size > 0 && getFundingDependencies(node); // if we're only counting items there's no need\n      // to add all the data to the resulting object\n\n      if (countOnly) return null;\n\n      if (hasDependencies(transitiveDependencies)) {\n        fundingItem.dependencies = retrieveDependencies(transitiveDependencies);\n      }\n\n      if (isValidFunding(fundingItem.funding)) {\n        res[node.package.name] = fundingItem;\n      } else if (hasDependencies(fundingItem.dependencies)) {\n        res[_trailingDependencies] = Object.assign(empty(), res[_trailingDependencies], fundingItem.dependencies);\n      }\n\n      return res;\n    }, countOnly ? null : empty());\n  }\n\n  const treeDependencies = getFundingDependencies(tree);\n  const result = {\n    length: packageWithFundingCount\n  };\n\n  if (!countOnly) {\n    const name = tree && tree.package && tree.package.name || tree && tree.name;\n    result.name = name || tree && tree.path;\n\n    if (tree && tree.package && tree.package.version) {\n      result.version = tree.package.version;\n    }\n\n    if (tree && tree.package && tree.package.funding) {\n      result.funding = normalizeFunding(tree.package.funding);\n    }\n\n    result.dependencies = retrieveDependencies(treeDependencies);\n  }\n\n  return result;\n}\n\nasync function read(opts) {\n  const arb = new Arborist(opts);\n  const tree = await arb.loadActual();\n  return readTree(tree, opts);\n}\n\nmodule.exports = {\n  read,\n  readTree,\n  normalizeFunding,\n  isValidFunding\n};","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/node_modules/libnpmfund/index.js"],"names":["URL","require","Arborist","normalizeFunding","funding","normalizeItem","item","url","sources","concat","map","Array","isArray","isValidFunding","every","f","parsed","error","protocol","Boolean","host","empty","Object","create","readTree","tree","opts","packageWithFundingCount","seen","Set","countOnly","_trailingDependencies","Symbol","tracked","name","version","key","String","has","add","retrieveDependencies","dependencies","trailing","assign","hasDependencies","keys","length","attachFundingInfo","target","getFundingDependencies","edges","edgesOut","values","directDepsWithFunding","from","edge","to","node","package","fundingItem","reduce","res","i","transitiveDependencies","size","treeDependencies","result","path","read","arb","loadActual","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst URL = require('url').URL\nconst Arborist = require('@npmcli/arborist')\n\n// supports object funding and string shorthand, or an array of these\n// if original was an array, returns an array; else returns the lone item\nfunction normalizeFunding (funding) {\n  const normalizeItem = item =>\n    typeof item === 'string' ? { url: item } : item\n  const sources = [].concat(funding || []).map(normalizeItem)\n  return Array.isArray(funding) ? sources : sources[0]\n}\n\n// Is the value of a `funding` property of a `package.json`\n// a valid type+url for `npm fund` to display?\nfunction isValidFunding (funding) {\n  if (!funding) return false\n\n  if (Array.isArray(funding)) {\n    return funding.every(f => !Array.isArray(f) && isValidFunding(f))\n  }\n\n  try {\n    var parsed = new URL(funding.url || funding)\n  } catch (error) {\n    return false\n  }\n\n  if (\n    parsed.protocol !== 'https:' &&\n    parsed.protocol !== 'http:'\n  ) return false\n\n  return Boolean(parsed.host)\n}\n\nconst empty = () => Object.create(null)\n\nfunction readTree (tree, opts) {\n  let packageWithFundingCount = 0\n  const seen = new Set()\n  const { countOnly } = opts || {}\n  const _trailingDependencies = Symbol('trailingDependencies')\n\n  function tracked (name, version) {\n    const key = String(name) + String(version)\n    if (seen.has(key)) {\n      return true\n    }\n    seen.add(key)\n  }\n\n  function retrieveDependencies (dependencies) {\n    const trailing = dependencies[_trailingDependencies]\n\n    if (trailing) {\n      return Object.assign(\n        empty(),\n        dependencies,\n        trailing\n      )\n    }\n\n    return dependencies\n  }\n\n  function hasDependencies (dependencies) {\n    return dependencies && (\n      Object.keys(dependencies).length ||\n      dependencies[_trailingDependencies]\n    )\n  }\n\n  function attachFundingInfo (target, funding) {\n    if (funding && isValidFunding(funding)) {\n      target.funding = normalizeFunding(funding)\n      packageWithFundingCount++\n    }\n  }\n\n  function getFundingDependencies (tree) {\n    const edges = tree && tree.edgesOut && tree.edgesOut.values()\n    if (!edges) return empty()\n\n    const directDepsWithFunding = Array.from(edges).map(edge => {\n      if (!edge || !edge.to) return empty()\n\n      const node = edge.to.target || edge.to\n      if (!node.package) return empty()\n\n      const { name, funding, version } = node.package\n\n      // avoids duplicated items within the funding tree\n      if (tracked(name, version)) return empty()\n\n      const fundingItem = {}\n\n      if (version) {\n        fundingItem.version = version\n      }\n\n      attachFundingInfo(fundingItem, funding)\n\n      return {\n        node,\n        fundingItem\n      }\n    })\n\n    return directDepsWithFunding.reduce(\n      (res, { node, fundingItem }, i) => {\n        if (!fundingItem ||\n          fundingItem.length === 0 ||\n          !node) return res\n\n        // recurse\n        const transitiveDependencies = node.edgesOut &&\n          node.edgesOut.size > 0 &&\n          getFundingDependencies(node)\n\n        // if we're only counting items there's no need\n        // to add all the data to the resulting object\n        if (countOnly) return null\n\n        if (hasDependencies(transitiveDependencies)) {\n          fundingItem.dependencies =\n            retrieveDependencies(transitiveDependencies)\n        }\n\n        if (isValidFunding(fundingItem.funding)) {\n          res[node.package.name] = fundingItem\n        } else if (hasDependencies(fundingItem.dependencies)) {\n          res[_trailingDependencies] =\n            Object.assign(\n              empty(),\n              res[_trailingDependencies],\n              fundingItem.dependencies\n            )\n        }\n\n        return res\n      }, countOnly ? null : empty())\n  }\n\n  const treeDependencies = getFundingDependencies(tree)\n  const result = {\n    length: packageWithFundingCount\n  }\n\n  if (!countOnly) {\n    const name =\n      (tree && tree.package && tree.package.name) ||\n      (tree && tree.name)\n    result.name = name || (tree && tree.path)\n\n    if (tree && tree.package && tree.package.version) {\n      result.version = tree.package.version\n    }\n\n    if (tree && tree.package && tree.package.funding) {\n      result.funding = normalizeFunding(tree.package.funding)\n    }\n\n    result.dependencies = retrieveDependencies(treeDependencies)\n  }\n\n  return result\n}\n\nasync function read (opts) {\n  const arb = new Arborist(opts)\n  const tree = await arb.loadActual()\n\n  return readTree(tree, opts)\n}\n\nmodule.exports = {\n  read,\n  readTree,\n  normalizeFunding,\n  isValidFunding\n}\n"]},"metadata":{},"sourceType":"script"}
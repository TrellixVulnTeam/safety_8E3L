{"ast":null,"code":"'use strict';\n\nconst checkResponse = require('./check-response.js');\n\nconst getAuth = require('./auth.js');\n\nconst fetch = require('make-fetch-happen');\n\nconst JSONStream = require('minipass-json-stream');\n\nconst npa = require('npm-package-arg');\n\nconst qs = require('querystring');\n\nconst url = require('url');\n\nconst zlib = require('minizlib');\n\nconst Minipass = require('minipass');\n\nconst defaultOpts = require('./default-opts.js'); // WhatWG URL throws if it's not fully resolved\n\n\nconst urlIsValid = u => {\n  try {\n    return !!new url.URL(u);\n  } catch (_) {\n    return false;\n  }\n};\n\nmodule.exports = regFetch;\n\nfunction regFetch(uri,\n/* istanbul ignore next */\nopts_ = {}) {\n  const opts = { ...defaultOpts,\n    ...opts_\n  };\n  const registry = opts.registry = opts.spec && pickRegistry(opts.spec, opts) || opts.registry ||\n  /* istanbul ignore next */\n  'https://registry.npmjs.org/';\n\n  if (!urlIsValid(uri)) {\n    uri = `${registry.trim().replace(/\\/?$/g, '')}/${uri.trim().replace(/^\\//, '')}`;\n  }\n\n  const method = opts.method || 'GET'; // through that takes into account the scope, the prefix of `uri`, etc\n\n  const startTime = Date.now();\n  const headers = getHeaders(registry, uri, opts);\n  let body = opts.body;\n  const bodyIsStream = Minipass.isStream(body);\n  const bodyIsPromise = body && typeof body === 'object' && typeof body.then === 'function';\n\n  if (body && !bodyIsStream && !bodyIsPromise && typeof body !== 'string' && !Buffer.isBuffer(body)) {\n    headers['content-type'] = headers['content-type'] || 'application/json';\n    body = JSON.stringify(body);\n  } else if (body && !headers['content-type']) headers['content-type'] = 'application/octet-stream';\n\n  if (opts.gzip) {\n    headers['content-encoding'] = 'gzip';\n\n    if (bodyIsStream) {\n      const gz = new zlib.Gzip();\n      body.on('error',\n      /* istanbul ignore next: unlikely and hard to test */\n      err => gz.emit('error', err));\n      body = body.pipe(gz);\n    } else if (!bodyIsPromise) body = new zlib.Gzip().end(body).concat();\n  }\n\n  const parsed = new url.URL(uri);\n\n  if (opts.query) {\n    const q = typeof opts.query === 'string' ? qs.parse(opts.query) : opts.query;\n    Object.keys(q).forEach(key => {\n      if (q[key] !== undefined) parsed.searchParams.set(key, q[key]);\n    });\n    uri = url.format(parsed);\n  }\n\n  if (parsed.searchParams.get('write') === 'true' && method === 'GET') {\n    // do not cache, because this GET is fetching a rev that will be\n    // used for a subsequent PUT or DELETE, so we need to conditionally\n    // update cache.\n    opts.offline = false;\n    opts.preferOffline = false;\n    opts.preferOnline = true;\n  }\n\n  const doFetch = body => fetch(uri, {\n    agent: opts.agent,\n    algorithms: opts.algorithms,\n    body,\n    cache: getCacheMode(opts),\n    cacheManager: opts.cache,\n    ca: opts.ca,\n    cert: opts.cert,\n    headers,\n    integrity: opts.integrity,\n    key: opts.key,\n    localAddress: opts.localAddress,\n    maxSockets: opts.maxSockets,\n    memoize: opts.memoize,\n    method: method,\n    noProxy: opts.noProxy,\n    proxy: opts.httpsProxy || opts.proxy,\n    retry: opts.retry ? opts.retry : {\n      retries: opts.fetchRetries,\n      factor: opts.fetchRetryFactor,\n      minTimeout: opts.fetchRetryMintimeout,\n      maxTimeout: opts.fetchRetryMaxtimeout\n    },\n    strictSSL: opts.strictSSL,\n    timeout: opts.timeout || 30 * 1000\n  }).then(res => checkResponse(method, res, registry, startTime, opts));\n\n  return Promise.resolve(body).then(doFetch);\n}\n\nmodule.exports.json = fetchJSON;\n\nfunction fetchJSON(uri, opts) {\n  return regFetch(uri, opts).then(res => res.json());\n}\n\nmodule.exports.json.stream = fetchJSONStream;\n\nfunction fetchJSONStream(uri, jsonPath,\n/* istanbul ignore next */\nopts_ = {}) {\n  const opts = { ...defaultOpts,\n    ...opts_\n  };\n  const parser = JSONStream.parse(jsonPath, opts.mapJSON);\n  regFetch(uri, opts).then(res => res.body.on('error',\n  /* istanbul ignore next: unlikely and difficult to test */\n  er => parser.emit('error', er)).pipe(parser)).catch(er => parser.emit('error', er));\n  return parser;\n}\n\nmodule.exports.pickRegistry = pickRegistry;\n\nfunction pickRegistry(spec, opts = {}) {\n  spec = npa(spec);\n  let registry = spec.scope && opts[spec.scope.replace(/^@?/, '@') + ':registry'];\n  if (!registry && opts.scope) registry = opts[opts.scope.replace(/^@?/, '@') + ':registry'];\n  if (!registry) registry = opts.registry || 'https://registry.npmjs.org/';\n  return registry;\n}\n\nfunction getCacheMode(opts) {\n  return opts.offline ? 'only-if-cached' : opts.preferOffline ? 'force-cache' : opts.preferOnline ? 'no-cache' : 'default';\n}\n\nfunction getHeaders(registry, uri, opts) {\n  const headers = Object.assign({\n    'npm-in-ci': !!opts.isFromCI,\n    'user-agent': opts.userAgent\n  }, opts.headers || {});\n  if (opts.projectScope) headers['npm-scope'] = opts.projectScope;\n  if (opts.npmSession) headers['npm-session'] = opts.npmSession;\n  if (opts.npmCommand) headers['npm-command'] = opts.npmCommand;\n  const auth = getAuth(registry, opts); // If a tarball is hosted on a different place than the manifest, only send\n  // credentials on `alwaysAuth`\n\n  const shouldAuth = auth.alwaysAuth || new url.URL(uri).host === new url.URL(registry).host;\n  if (shouldAuth && auth.token) headers.authorization = `Bearer ${auth.token}`;else if (shouldAuth && auth.username && auth.password) {\n    const encoded = Buffer.from(`${auth.username}:${auth.password}`, 'utf8').toString('base64');\n    headers.authorization = `Basic ${encoded}`;\n  } else if (shouldAuth && auth._auth) headers.authorization = `Basic ${auth._auth}`;\n  if (shouldAuth && auth.otp) headers['npm-otp'] = auth.otp;\n  return headers;\n}","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/node_modules/npm-registry-fetch/index.js"],"names":["checkResponse","require","getAuth","fetch","JSONStream","npa","qs","url","zlib","Minipass","defaultOpts","urlIsValid","u","URL","_","module","exports","regFetch","uri","opts_","opts","registry","spec","pickRegistry","trim","replace","method","startTime","Date","now","headers","getHeaders","body","bodyIsStream","isStream","bodyIsPromise","then","Buffer","isBuffer","JSON","stringify","gzip","gz","Gzip","on","err","emit","pipe","end","concat","parsed","query","q","parse","Object","keys","forEach","key","undefined","searchParams","set","format","get","offline","preferOffline","preferOnline","doFetch","agent","algorithms","cache","getCacheMode","cacheManager","ca","cert","integrity","localAddress","maxSockets","memoize","noProxy","proxy","httpsProxy","retry","retries","fetchRetries","factor","fetchRetryFactor","minTimeout","fetchRetryMintimeout","maxTimeout","fetchRetryMaxtimeout","strictSSL","timeout","res","Promise","resolve","json","fetchJSON","stream","fetchJSONStream","jsonPath","parser","mapJSON","er","catch","scope","assign","isFromCI","userAgent","projectScope","npmSession","npmCommand","auth","shouldAuth","alwaysAuth","host","token","authorization","username","password","encoded","from","toString","_auth","otp"],"mappings":"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","sourcesContent":["'use strict'\n\nconst checkResponse = require('./check-response.js')\nconst getAuth = require('./auth.js')\nconst fetch = require('make-fetch-happen')\nconst JSONStream = require('minipass-json-stream')\nconst npa = require('npm-package-arg')\nconst qs = require('querystring')\nconst url = require('url')\nconst zlib = require('minizlib')\nconst Minipass = require('minipass')\n\nconst defaultOpts = require('./default-opts.js')\n\n// WhatWG URL throws if it's not fully resolved\nconst urlIsValid = u => {\n  try {\n    return !!new url.URL(u)\n  } catch (_) {\n    return false\n  }\n}\n\nmodule.exports = regFetch\nfunction regFetch (uri, /* istanbul ignore next */ opts_ = {}) {\n  const opts = {\n    ...defaultOpts,\n    ...opts_,\n  }\n  const registry = opts.registry = (\n    (opts.spec && pickRegistry(opts.spec, opts)) ||\n    opts.registry ||\n    /* istanbul ignore next */\n    'https://registry.npmjs.org/'\n  )\n\n  if (!urlIsValid(uri)) {\n    uri = `${\n      registry.trim().replace(/\\/?$/g, '')\n    }/${\n      uri.trim().replace(/^\\//, '')\n    }`\n  }\n\n  const method = opts.method || 'GET'\n\n  // through that takes into account the scope, the prefix of `uri`, etc\n  const startTime = Date.now()\n  const headers = getHeaders(registry, uri, opts)\n  let body = opts.body\n  const bodyIsStream = Minipass.isStream(body)\n  const bodyIsPromise = body &&\n    typeof body === 'object' &&\n    typeof body.then === 'function'\n\n  if (body && !bodyIsStream && !bodyIsPromise && typeof body !== 'string' && !Buffer.isBuffer(body)) {\n    headers['content-type'] = headers['content-type'] || 'application/json'\n    body = JSON.stringify(body)\n  } else if (body && !headers['content-type'])\n    headers['content-type'] = 'application/octet-stream'\n\n  if (opts.gzip) {\n    headers['content-encoding'] = 'gzip'\n    if (bodyIsStream) {\n      const gz = new zlib.Gzip()\n      body.on('error', /* istanbul ignore next: unlikely and hard to test */\n        err => gz.emit('error', err))\n      body = body.pipe(gz)\n    } else if (!bodyIsPromise)\n      body = new zlib.Gzip().end(body).concat()\n  }\n\n  const parsed = new url.URL(uri)\n\n  if (opts.query) {\n    const q = typeof opts.query === 'string' ? qs.parse(opts.query)\n      : opts.query\n\n    Object.keys(q).forEach(key => {\n      if (q[key] !== undefined)\n        parsed.searchParams.set(key, q[key])\n    })\n    uri = url.format(parsed)\n  }\n\n  if (parsed.searchParams.get('write') === 'true' && method === 'GET') {\n    // do not cache, because this GET is fetching a rev that will be\n    // used for a subsequent PUT or DELETE, so we need to conditionally\n    // update cache.\n    opts.offline = false\n    opts.preferOffline = false\n    opts.preferOnline = true\n  }\n\n  const doFetch = (body) => fetch(uri, {\n    agent: opts.agent,\n    algorithms: opts.algorithms,\n    body,\n    cache: getCacheMode(opts),\n    cacheManager: opts.cache,\n    ca: opts.ca,\n    cert: opts.cert,\n    headers,\n    integrity: opts.integrity,\n    key: opts.key,\n    localAddress: opts.localAddress,\n    maxSockets: opts.maxSockets,\n    memoize: opts.memoize,\n    method: method,\n    noProxy: opts.noProxy,\n    proxy: opts.httpsProxy || opts.proxy,\n    retry: opts.retry ? opts.retry : {\n      retries: opts.fetchRetries,\n      factor: opts.fetchRetryFactor,\n      minTimeout: opts.fetchRetryMintimeout,\n      maxTimeout: opts.fetchRetryMaxtimeout,\n    },\n    strictSSL: opts.strictSSL,\n    timeout: opts.timeout || 30 * 1000,\n  }).then(res => checkResponse(\n    method, res, registry, startTime, opts\n  ))\n\n  return Promise.resolve(body).then(doFetch)\n}\n\nmodule.exports.json = fetchJSON\nfunction fetchJSON (uri, opts) {\n  return regFetch(uri, opts).then(res => res.json())\n}\n\nmodule.exports.json.stream = fetchJSONStream\nfunction fetchJSONStream (uri, jsonPath, /* istanbul ignore next */ opts_ = {}) {\n  const opts = { ...defaultOpts, ...opts_ }\n  const parser = JSONStream.parse(jsonPath, opts.mapJSON)\n  regFetch(uri, opts).then(res =>\n    res.body.on('error',\n      /* istanbul ignore next: unlikely and difficult to test */\n      er => parser.emit('error', er)).pipe(parser)\n  ).catch(er => parser.emit('error', er))\n  return parser\n}\n\nmodule.exports.pickRegistry = pickRegistry\nfunction pickRegistry (spec, opts = {}) {\n  spec = npa(spec)\n  let registry = spec.scope &&\n    opts[spec.scope.replace(/^@?/, '@') + ':registry']\n\n  if (!registry && opts.scope)\n    registry = opts[opts.scope.replace(/^@?/, '@') + ':registry']\n\n  if (!registry)\n    registry = opts.registry || 'https://registry.npmjs.org/'\n\n  return registry\n}\n\nfunction getCacheMode (opts) {\n  return opts.offline ? 'only-if-cached'\n    : opts.preferOffline ? 'force-cache'\n    : opts.preferOnline ? 'no-cache'\n    : 'default'\n}\n\nfunction getHeaders (registry, uri, opts) {\n  const headers = Object.assign({\n    'npm-in-ci': !!opts.isFromCI,\n    'user-agent': opts.userAgent,\n  }, opts.headers || {})\n\n  if (opts.projectScope)\n    headers['npm-scope'] = opts.projectScope\n\n  if (opts.npmSession)\n    headers['npm-session'] = opts.npmSession\n\n  if (opts.npmCommand)\n    headers['npm-command'] = opts.npmCommand\n\n  const auth = getAuth(registry, opts)\n  // If a tarball is hosted on a different place than the manifest, only send\n  // credentials on `alwaysAuth`\n  const shouldAuth = (\n    auth.alwaysAuth ||\n    new url.URL(uri).host === new url.URL(registry).host\n  )\n  if (shouldAuth && auth.token)\n    headers.authorization = `Bearer ${auth.token}`\n  else if (shouldAuth && auth.username && auth.password) {\n    const encoded = Buffer.from(\n      `${auth.username}:${auth.password}`, 'utf8'\n    ).toString('base64')\n    headers.authorization = `Basic ${encoded}`\n  } else if (shouldAuth && auth._auth)\n    headers.authorization = `Basic ${auth._auth}`\n\n  if (shouldAuth && auth.otp)\n    headers['npm-otp'] = auth.otp\n\n  return headers\n}\n"]},"metadata":{},"sourceType":"script"}
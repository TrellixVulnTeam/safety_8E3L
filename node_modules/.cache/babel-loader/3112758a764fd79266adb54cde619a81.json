{"ast":null,"code":"// Arborist.rebuild({path = this.path}) will do all the binlinks and\n// bundle building needed.  Called by reify, and by `npm rebuild`.\nconst {\n  depth: dfwalk\n} = require('treeverse');\n\nconst promiseAllRejectLate = require('promise-all-reject-late');\n\nconst rpj = require('read-package-json-fast');\n\nconst binLinks = require('bin-links');\n\nconst runScript = require('@npmcli/run-script');\n\nconst promiseCallLimit = require('promise-call-limit');\n\nconst {\n  resolve\n} = require('path');\n\nconst {\n  isNodeGypPackage,\n  defaultGypInstallScript\n} = require('@npmcli/node-gyp');\n\nconst boolEnv = b => b ? '1' : '';\n\nconst sortNodes = (a, b) => a.depth - b.depth || a.path.localeCompare(b.path);\n\nconst _build = Symbol('build');\n\nconst _resetQueues = Symbol('resetQueues');\n\nconst _rebuildBundle = Symbol('rebuildBundle');\n\nconst _ignoreScripts = Symbol('ignoreScripts');\n\nconst _binLinks = Symbol('binLinks');\n\nconst _oldMeta = Symbol('oldMeta');\n\nconst _createBinLinks = Symbol('createBinLinks');\n\nconst _doHandleOptionalFailure = Symbol('doHandleOptionalFailure');\n\nconst _linkAllBins = Symbol('linkAllBins');\n\nconst _runScripts = Symbol('runScripts');\n\nconst _buildQueues = Symbol('buildQueues');\n\nconst _addToBuildSet = Symbol('addToBuildSet');\n\nconst _checkBins = Symbol.for('checkBins');\n\nconst _queues = Symbol('queues');\n\nconst _scriptShell = Symbol('scriptShell');\n\nconst _force = Symbol.for('force'); // defined by reify mixin\n\n\nconst _handleOptionalFailure = Symbol.for('handleOptionalFailure');\n\nconst _trashList = Symbol.for('trashList');\n\nmodule.exports = cls => class Builder extends cls {\n  constructor(options) {\n    super(options);\n    const {\n      ignoreScripts = false,\n      scriptShell,\n      binLinks = true,\n      rebuildBundle = true\n    } = options;\n    this.scriptsRun = new Set();\n    this[_binLinks] = binLinks;\n    this[_ignoreScripts] = !!ignoreScripts;\n    this[_scriptShell] = scriptShell;\n    this[_rebuildBundle] = !!rebuildBundle;\n\n    this[_resetQueues]();\n\n    this[_oldMeta] = null;\n  }\n\n  async rebuild({\n    nodes,\n    handleOptionalFailure = false\n  } = {}) {\n    // nothing to do if we're not building anything!\n    if (this[_ignoreScripts] && !this[_binLinks]) return; // when building for the first time, as part of reify, we ignore\n    // failures in optional nodes, and just delete them.  however, when\n    // running JUST a rebuild, we treat optional failures as real fails\n\n    this[_doHandleOptionalFailure] = handleOptionalFailure; // if we don't have a set of nodes, then just rebuild\n    // the actual tree on disk.\n\n    if (!nodes) nodes = (await this.loadActual()).inventory.values(); // separates links nodes so that it can run\n    // prepare scripts and link bins in the expected order\n\n    process.emit('time', 'build');\n    const depNodes = new Set();\n    const linkNodes = new Set();\n\n    for (const node of nodes) {\n      // we skip the target nodes to that workspace in order to make sure\n      // we only run lifecycle scripts / place bin links once per workspace\n      if (node.isLink) linkNodes.add(node);else depNodes.add(node);\n    }\n\n    await this[_build](depNodes, {});\n\n    if (linkNodes.size) {\n      this[_resetQueues]();\n\n      await this[_build](linkNodes, {\n        type: 'links'\n      });\n    }\n\n    process.emit('timeEnd', 'build');\n  }\n\n  [_resetQueues]() {\n    this[_queues] = {\n      preinstall: [],\n      install: [],\n      postinstall: [],\n      prepare: [],\n      bin: []\n    };\n  }\n\n  async [_build](nodes, {\n    type = 'deps'\n  }) {\n    process.emit('time', `build:${type}`);\n    await this[_buildQueues](nodes);\n    if (!this[_ignoreScripts]) await this[_runScripts]('preinstall');\n    if (this[_binLinks] && type !== 'links') await this[_linkAllBins]();\n\n    if (!this[_ignoreScripts]) {\n      await this[_runScripts]('install');\n      await this[_runScripts]('postinstall');\n    } // links should also run prepare scripts and only link bins after that\n\n\n    if (type === 'links') {\n      await this[_runScripts]('prepare');\n      if (this[_binLinks]) await this[_linkAllBins]();\n    }\n\n    process.emit('timeEnd', `build:${type}`);\n  }\n\n  async [_buildQueues](nodes) {\n    process.emit('time', 'build:queue');\n    const set = new Set();\n    const promises = [];\n\n    for (const node of nodes) {\n      promises.push(this[_addToBuildSet](node, set)); // if it has bundle deps, add those too, if rebuildBundle\n\n      if (this[_rebuildBundle] !== false) {\n        const bd = node.package.bundleDependencies;\n\n        if (bd && bd.length) {\n          dfwalk({\n            tree: node,\n            leave: node => promises.push(this[_addToBuildSet](node, set)),\n            getChildren: node => [...node.children.values()],\n            filter: node => node.inBundle\n          });\n        }\n      }\n    }\n\n    await promiseAllRejectLate(promises); // now sort into the queues for the 4 things we have to do\n    // run in the same predictable order that buildIdealTree uses\n    // there's no particular reason for doing it in this order rather\n    // than another, but sorting *somehow* makes it consistent.\n\n    const queue = [...set].sort(sortNodes);\n\n    for (const node of queue) {\n      const {\n        package: {\n          bin,\n          scripts = {}\n        }\n      } = node;\n      const {\n        preinstall,\n        install,\n        postinstall,\n        prepare\n      } = scripts;\n      const tests = {\n        bin,\n        preinstall,\n        install,\n        postinstall,\n        prepare\n      };\n\n      for (const [key, has] of Object.entries(tests)) {\n        if (has) this[_queues][key].push(node);\n      }\n    }\n\n    process.emit('timeEnd', 'build:queue');\n  }\n\n  async [_checkBins](node) {\n    // if the node is a global top, and we're not in force mode, then\n    // any existing bins need to either be missing, or a symlink into\n    // the node path.  Otherwise a package can have a preinstall script\n    // that unlinks something, to allow them to silently overwrite system\n    // binaries, which is unsafe and insecure.\n    if (!node.globalTop || this[_force]) return;\n    const {\n      path,\n      package: pkg\n    } = node;\n    await binLinks.checkBins({\n      pkg,\n      path,\n      top: true,\n      global: true\n    });\n  }\n\n  async [_addToBuildSet](node, set, refreshed = false) {\n    if (set.has(node)) return;\n\n    if (this[_oldMeta] === null) {\n      const {\n        root: {\n          meta\n        }\n      } = node;\n      this[_oldMeta] = meta && meta.loadedFromDisk && !(meta.originalLockfileVersion >= 2);\n    }\n\n    const {\n      package: pkg,\n      hasInstallScript\n    } = node;\n    const {\n      gypfile,\n      bin,\n      scripts = {}\n    } = pkg;\n    const {\n      preinstall,\n      install,\n      postinstall,\n      prepare\n    } = scripts;\n    const anyScript = preinstall || install || postinstall || prepare;\n\n    if (!refreshed && !anyScript && (hasInstallScript || this[_oldMeta])) {\n      // we either have an old metadata (and thus might have scripts)\n      // or we have an indication that there's install scripts (but\n      // don't yet know what they are) so we have to load the package.json\n      // from disk to see what the deal is.  Failure here just means\n      // no scripts to add, probably borked package.json.\n      // add to the set then remove while we're reading the pj, so we\n      // don't accidentally hit it multiple times.\n      set.add(node);\n      const pkg = await rpj(node.path + '/package.json').catch(() => ({}));\n      set.delete(node);\n      const {\n        scripts = {}\n      } = pkg;\n      node.package.scripts = scripts;\n      return this[_addToBuildSet](node, set, true);\n    } // Rebuild node-gyp dependencies lacking an install or preinstall script\n    // note that 'scripts' might be missing entirely, and the package may\n    // set gypfile:false to avoid this automatic detection.\n\n\n    const isGyp = gypfile !== false && !install && !preinstall && (await isNodeGypPackage(node.path));\n\n    if (bin || preinstall || install || postinstall || prepare || isGyp) {\n      if (bin) await this[_checkBins](node);\n\n      if (isGyp) {\n        scripts.install = defaultGypInstallScript;\n        node.package.scripts = scripts;\n      }\n\n      set.add(node);\n    }\n  }\n\n  async [_runScripts](event) {\n    const queue = this[_queues][event];\n    if (!queue.length) return;\n    process.emit('time', `build:run:${event}`);\n    const stdio = this.options.foregroundScripts ? 'inherit' : 'pipe';\n    const limit = this.options.foregroundScripts ? 1 : undefined;\n    await promiseCallLimit(queue.map(node => async () => {\n      const {\n        path,\n        integrity,\n        resolved,\n        optional,\n        peer,\n        dev,\n        devOptional,\n        package: pkg,\n        location\n      } = node.target || node; // skip any that we know we'll be deleting\n\n      if (this[_trashList].has(path)) return;\n      const timer = `build:run:${event}:${location}`;\n      process.emit('time', timer);\n      this.log.info('run', pkg._id, event, location, pkg.scripts[event]);\n      const env = {\n        npm_package_resolved: resolved,\n        npm_package_integrity: integrity,\n        npm_package_json: resolve(path, 'package.json'),\n        npm_package_optional: boolEnv(optional),\n        npm_package_dev: boolEnv(dev),\n        npm_package_peer: boolEnv(peer),\n        npm_package_dev_optional: boolEnv(devOptional && !dev && !optional)\n      };\n      const runOpts = {\n        event,\n        path,\n        pkg,\n        stdioString: true,\n        stdio,\n        env,\n        scriptShell: this[_scriptShell]\n      };\n      const p = runScript(runOpts).catch(er => {\n        const {\n          code,\n          signal\n        } = er;\n        this.log.info('run', pkg._id, event, {\n          code,\n          signal\n        });\n        throw er;\n      }).then(({\n        args,\n        code,\n        signal,\n        stdout,\n        stderr\n      }) => {\n        this.scriptsRun.add({\n          pkg,\n          path,\n          event,\n          cmd: args && args[args.length - 1],\n          env,\n          code,\n          signal,\n          stdout,\n          stderr\n        });\n        this.log.info('run', pkg._id, event, {\n          code,\n          signal\n        });\n      });\n      await (this[_doHandleOptionalFailure] ? this[_handleOptionalFailure](node, p) : p);\n      process.emit('timeEnd', timer);\n    }), limit);\n    process.emit('timeEnd', `build:run:${event}`);\n  }\n\n  async [_linkAllBins]() {\n    const queue = this[_queues].bin;\n    if (!queue.length) return;\n    process.emit('time', 'build:link');\n    const promises = []; // sort the queue by node path, so that the module-local collision\n    // detector in bin-links will always resolve the same way.\n\n    for (const node of queue.sort(sortNodes)) promises.push(this[_createBinLinks](node));\n\n    await promiseAllRejectLate(promises);\n    process.emit('timeEnd', 'build:link');\n  }\n\n  async [_createBinLinks](node) {\n    if (this[_trashList].has(node.path)) return;\n    process.emit('time', `build:link:${node.location}`);\n    const p = binLinks({\n      pkg: node.package,\n      path: node.path,\n      top: !!(node.isTop || node.globalTop),\n      force: this[_force],\n      global: !!node.globalTop\n    });\n    await (this[_doHandleOptionalFailure] ? this[_handleOptionalFailure](node, p) : p);\n    process.emit('timeEnd', `build:link:${node.location}`);\n  }\n\n};","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/node_modules/@npmcli/arborist/lib/arborist/rebuild.js"],"names":["depth","dfwalk","require","promiseAllRejectLate","rpj","binLinks","runScript","promiseCallLimit","resolve","isNodeGypPackage","defaultGypInstallScript","boolEnv","b","sortNodes","a","path","localeCompare","_build","Symbol","_resetQueues","_rebuildBundle","_ignoreScripts","_binLinks","_oldMeta","_createBinLinks","_doHandleOptionalFailure","_linkAllBins","_runScripts","_buildQueues","_addToBuildSet","_checkBins","for","_queues","_scriptShell","_force","_handleOptionalFailure","_trashList","module","exports","cls","Builder","constructor","options","ignoreScripts","scriptShell","rebuildBundle","scriptsRun","Set","rebuild","nodes","handleOptionalFailure","loadActual","inventory","values","process","emit","depNodes","linkNodes","node","isLink","add","size","type","preinstall","install","postinstall","prepare","bin","set","promises","push","bd","package","bundleDependencies","length","tree","leave","getChildren","children","filter","inBundle","queue","sort","scripts","tests","key","has","Object","entries","globalTop","pkg","checkBins","top","global","refreshed","root","meta","loadedFromDisk","originalLockfileVersion","hasInstallScript","gypfile","anyScript","catch","delete","isGyp","event","stdio","foregroundScripts","limit","undefined","map","integrity","resolved","optional","peer","dev","devOptional","location","target","timer","log","info","_id","env","npm_package_resolved","npm_package_integrity","npm_package_json","npm_package_optional","npm_package_dev","npm_package_peer","npm_package_dev_optional","runOpts","stdioString","p","er","code","signal","then","args","stdout","stderr","cmd","isTop","force"],"mappings":"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","sourcesContent":["// Arborist.rebuild({path = this.path}) will do all the binlinks and\n// bundle building needed.  Called by reify, and by `npm rebuild`.\n\nconst {depth: dfwalk} = require('treeverse')\nconst promiseAllRejectLate = require('promise-all-reject-late')\nconst rpj = require('read-package-json-fast')\nconst binLinks = require('bin-links')\nconst runScript = require('@npmcli/run-script')\nconst promiseCallLimit = require('promise-call-limit')\nconst {resolve} = require('path')\nconst {\n  isNodeGypPackage,\n  defaultGypInstallScript,\n} = require('@npmcli/node-gyp')\n\nconst boolEnv = b => b ? '1' : ''\nconst sortNodes = (a, b) => (a.depth - b.depth) || a.path.localeCompare(b.path)\n\nconst _build = Symbol('build')\nconst _resetQueues = Symbol('resetQueues')\nconst _rebuildBundle = Symbol('rebuildBundle')\nconst _ignoreScripts = Symbol('ignoreScripts')\nconst _binLinks = Symbol('binLinks')\nconst _oldMeta = Symbol('oldMeta')\nconst _createBinLinks = Symbol('createBinLinks')\nconst _doHandleOptionalFailure = Symbol('doHandleOptionalFailure')\nconst _linkAllBins = Symbol('linkAllBins')\nconst _runScripts = Symbol('runScripts')\nconst _buildQueues = Symbol('buildQueues')\nconst _addToBuildSet = Symbol('addToBuildSet')\nconst _checkBins = Symbol.for('checkBins')\nconst _queues = Symbol('queues')\nconst _scriptShell = Symbol('scriptShell')\n\nconst _force = Symbol.for('force')\n\n// defined by reify mixin\nconst _handleOptionalFailure = Symbol.for('handleOptionalFailure')\nconst _trashList = Symbol.for('trashList')\n\nmodule.exports = cls => class Builder extends cls {\n  constructor (options) {\n    super(options)\n\n    const {\n      ignoreScripts = false,\n      scriptShell,\n      binLinks = true,\n      rebuildBundle = true,\n    } = options\n\n    this.scriptsRun = new Set()\n    this[_binLinks] = binLinks\n    this[_ignoreScripts] = !!ignoreScripts\n    this[_scriptShell] = scriptShell\n    this[_rebuildBundle] = !!rebuildBundle\n    this[_resetQueues]()\n    this[_oldMeta] = null\n  }\n\n  async rebuild ({ nodes, handleOptionalFailure = false } = {}) {\n    // nothing to do if we're not building anything!\n    if (this[_ignoreScripts] && !this[_binLinks])\n      return\n\n    // when building for the first time, as part of reify, we ignore\n    // failures in optional nodes, and just delete them.  however, when\n    // running JUST a rebuild, we treat optional failures as real fails\n    this[_doHandleOptionalFailure] = handleOptionalFailure\n\n    // if we don't have a set of nodes, then just rebuild\n    // the actual tree on disk.\n    if (!nodes)\n      nodes = (await this.loadActual()).inventory.values()\n\n    // separates links nodes so that it can run\n    // prepare scripts and link bins in the expected order\n    process.emit('time', 'build')\n    const depNodes = new Set()\n    const linkNodes = new Set()\n    for (const node of nodes) {\n      // we skip the target nodes to that workspace in order to make sure\n      // we only run lifecycle scripts / place bin links once per workspace\n      if (node.isLink)\n        linkNodes.add(node)\n      else\n        depNodes.add(node)\n    }\n\n    await this[_build](depNodes, {})\n\n    if (linkNodes.size) {\n      this[_resetQueues]()\n      await this[_build](linkNodes, { type: 'links' })\n    }\n\n    process.emit('timeEnd', 'build')\n  }\n\n  [_resetQueues] () {\n    this[_queues] = {\n      preinstall: [],\n      install: [],\n      postinstall: [],\n      prepare: [],\n      bin: [],\n    }\n  }\n\n  async [_build] (nodes, { type = 'deps' }) {\n    process.emit('time', `build:${type}`)\n\n    await this[_buildQueues](nodes)\n    if (!this[_ignoreScripts])\n      await this[_runScripts]('preinstall')\n    if (this[_binLinks] && type !== 'links')\n      await this[_linkAllBins]()\n    if (!this[_ignoreScripts]) {\n      await this[_runScripts]('install')\n      await this[_runScripts]('postinstall')\n    }\n\n    // links should also run prepare scripts and only link bins after that\n    if (type === 'links') {\n      await this[_runScripts]('prepare')\n\n      if (this[_binLinks])\n        await this[_linkAllBins]()\n    }\n\n    process.emit('timeEnd', `build:${type}`)\n  }\n\n  async [_buildQueues] (nodes) {\n    process.emit('time', 'build:queue')\n    const set = new Set()\n\n    const promises = []\n    for (const node of nodes) {\n      promises.push(this[_addToBuildSet](node, set))\n\n      // if it has bundle deps, add those too, if rebuildBundle\n      if (this[_rebuildBundle] !== false) {\n        const bd = node.package.bundleDependencies\n        if (bd && bd.length) {\n          dfwalk({\n            tree: node,\n            leave: node => promises.push(this[_addToBuildSet](node, set)),\n            getChildren: node => [...node.children.values()],\n            filter: node => node.inBundle,\n          })\n        }\n      }\n    }\n    await promiseAllRejectLate(promises)\n\n    // now sort into the queues for the 4 things we have to do\n    // run in the same predictable order that buildIdealTree uses\n    // there's no particular reason for doing it in this order rather\n    // than another, but sorting *somehow* makes it consistent.\n    const queue = [...set].sort(sortNodes)\n\n    for (const node of queue) {\n      const { package: { bin, scripts = {} } } = node\n      const { preinstall, install, postinstall, prepare } = scripts\n      const tests = { bin, preinstall, install, postinstall, prepare }\n      for (const [key, has] of Object.entries(tests)) {\n        if (has)\n          this[_queues][key].push(node)\n      }\n    }\n    process.emit('timeEnd', 'build:queue')\n  }\n\n  async [_checkBins] (node) {\n    // if the node is a global top, and we're not in force mode, then\n    // any existing bins need to either be missing, or a symlink into\n    // the node path.  Otherwise a package can have a preinstall script\n    // that unlinks something, to allow them to silently overwrite system\n    // binaries, which is unsafe and insecure.\n    if (!node.globalTop || this[_force])\n      return\n    const { path, package: pkg } = node\n    await binLinks.checkBins({ pkg, path, top: true, global: true })\n  }\n\n  async [_addToBuildSet] (node, set, refreshed = false) {\n    if (set.has(node))\n      return\n\n    if (this[_oldMeta] === null) {\n      const {root: {meta}} = node\n      this[_oldMeta] = meta && meta.loadedFromDisk &&\n        !(meta.originalLockfileVersion >= 2)\n    }\n\n    const { package: pkg, hasInstallScript } = node\n    const { gypfile, bin, scripts = {} } = pkg\n\n    const { preinstall, install, postinstall, prepare } = scripts\n    const anyScript = preinstall || install || postinstall || prepare\n    if (!refreshed && !anyScript && (hasInstallScript || this[_oldMeta])) {\n      // we either have an old metadata (and thus might have scripts)\n      // or we have an indication that there's install scripts (but\n      // don't yet know what they are) so we have to load the package.json\n      // from disk to see what the deal is.  Failure here just means\n      // no scripts to add, probably borked package.json.\n      // add to the set then remove while we're reading the pj, so we\n      // don't accidentally hit it multiple times.\n      set.add(node)\n      const pkg = await rpj(node.path + '/package.json').catch(() => ({}))\n      set.delete(node)\n\n      const {scripts = {}} = pkg\n      node.package.scripts = scripts\n      return this[_addToBuildSet](node, set, true)\n    }\n\n    // Rebuild node-gyp dependencies lacking an install or preinstall script\n    // note that 'scripts' might be missing entirely, and the package may\n    // set gypfile:false to avoid this automatic detection.\n    const isGyp = gypfile !== false &&\n      !install &&\n      !preinstall &&\n      await isNodeGypPackage(node.path)\n\n    if (bin || preinstall || install || postinstall || prepare || isGyp) {\n      if (bin)\n        await this[_checkBins](node)\n      if (isGyp) {\n        scripts.install = defaultGypInstallScript\n        node.package.scripts = scripts\n      }\n      set.add(node)\n    }\n  }\n\n  async [_runScripts] (event) {\n    const queue = this[_queues][event]\n\n    if (!queue.length)\n      return\n\n    process.emit('time', `build:run:${event}`)\n    const stdio = this.options.foregroundScripts ? 'inherit' : 'pipe'\n    const limit = this.options.foregroundScripts ? 1 : undefined\n    await promiseCallLimit(queue.map(node => async () => {\n      const {\n        path,\n        integrity,\n        resolved,\n        optional,\n        peer,\n        dev,\n        devOptional,\n        package: pkg,\n        location,\n      } = node.target || node\n\n      // skip any that we know we'll be deleting\n      if (this[_trashList].has(path))\n        return\n\n      const timer = `build:run:${event}:${location}`\n      process.emit('time', timer)\n      this.log.info('run', pkg._id, event, location, pkg.scripts[event])\n      const env = {\n        npm_package_resolved: resolved,\n        npm_package_integrity: integrity,\n        npm_package_json: resolve(path, 'package.json'),\n        npm_package_optional: boolEnv(optional),\n        npm_package_dev: boolEnv(dev),\n        npm_package_peer: boolEnv(peer),\n        npm_package_dev_optional:\n          boolEnv(devOptional && !dev && !optional),\n      }\n      const runOpts = {\n        event,\n        path,\n        pkg,\n        stdioString: true,\n        stdio,\n        env,\n        scriptShell: this[_scriptShell],\n      }\n      const p = runScript(runOpts).catch(er => {\n        const { code, signal } = er\n        this.log.info('run', pkg._id, event, {code, signal})\n        throw er\n      }).then(({args, code, signal, stdout, stderr}) => {\n        this.scriptsRun.add({\n          pkg,\n          path,\n          event,\n          cmd: args && args[args.length - 1],\n          env,\n          code,\n          signal,\n          stdout,\n          stderr,\n        })\n        this.log.info('run', pkg._id, event, {code, signal})\n      })\n\n      await (this[_doHandleOptionalFailure]\n        ? this[_handleOptionalFailure](node, p)\n        : p)\n\n      process.emit('timeEnd', timer)\n    }), limit)\n    process.emit('timeEnd', `build:run:${event}`)\n  }\n\n  async [_linkAllBins] () {\n    const queue = this[_queues].bin\n    if (!queue.length)\n      return\n\n    process.emit('time', 'build:link')\n    const promises = []\n    // sort the queue by node path, so that the module-local collision\n    // detector in bin-links will always resolve the same way.\n    for (const node of queue.sort(sortNodes))\n      promises.push(this[_createBinLinks](node))\n\n    await promiseAllRejectLate(promises)\n    process.emit('timeEnd', 'build:link')\n  }\n\n  async [_createBinLinks] (node) {\n    if (this[_trashList].has(node.path))\n      return\n\n    process.emit('time', `build:link:${node.location}`)\n\n    const p = binLinks({\n      pkg: node.package,\n      path: node.path,\n      top: !!(node.isTop || node.globalTop),\n      force: this[_force],\n      global: !!node.globalTop,\n    })\n\n    await (this[_doHandleOptionalFailure]\n      ? this[_handleOptionalFailure](node, p)\n      : p)\n\n    process.emit('timeEnd', `build:link:${node.location}`)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}
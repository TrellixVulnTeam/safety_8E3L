{"ast":null,"code":"'use strict';\n\nconst Url = require('url');\n\nconst Minipass = require('minipass');\n\nconst Headers = require('./headers.js');\n\nconst {\n  exportNodeCompatibleHeaders\n} = Headers;\n\nconst Body = require('./body.js');\n\nconst {\n  clone,\n  extractContentType,\n  getTotalBytes\n} = Body;\n\nconst version = require('../package.json').version;\n\nconst defaultUserAgent = `minipass-fetch/${version} (+https://github.com/isaacs/minipass-fetch)`;\nconst INTERNALS = Symbol('Request internals');\nconst {\n  parse: parseUrl,\n  format: formatUrl\n} = Url;\n\nconst isRequest = input => typeof input === 'object' && typeof input[INTERNALS] === 'object';\n\nconst isAbortSignal = signal => {\n  const proto = signal && typeof signal === 'object' && Object.getPrototypeOf(signal);\n  return !!(proto && proto.constructor.name === 'AbortSignal');\n};\n\nclass Request extends Body {\n  constructor(input, init = {}) {\n    const parsedURL = isRequest(input) ? Url.parse(input.url) : input && input.href ? Url.parse(input.href) : Url.parse(`${input}`);\n    if (isRequest(input)) init = { ...input[INTERNALS],\n      ...init\n    };else if (!input || typeof input === 'string') input = {};\n    const method = (init.method || input.method || 'GET').toUpperCase();\n    const isGETHEAD = method === 'GET' || method === 'HEAD';\n    if ((init.body !== null && init.body !== undefined || isRequest(input) && input.body !== null) && isGETHEAD) throw new TypeError('Request with GET/HEAD method cannot have body');\n    const inputBody = init.body !== null && init.body !== undefined ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;\n    super(inputBody, {\n      timeout: init.timeout || input.timeout || 0,\n      size: init.size || input.size || 0\n    });\n    const headers = new Headers(init.headers || input.headers || {});\n\n    if (inputBody !== null && inputBody !== undefined && !headers.has('Content-Type')) {\n      const contentType = extractContentType(inputBody);\n      if (contentType) headers.append('Content-Type', contentType);\n    }\n\n    const signal = 'signal' in init ? init.signal : null;\n    if (signal !== null && signal !== undefined && !isAbortSignal(signal)) throw new TypeError('Expected signal must be an instanceof AbortSignal'); // TLS specific options that are handled by node\n\n    const {\n      ca,\n      cert,\n      ciphers,\n      clientCertEngine,\n      crl,\n      dhparam,\n      ecdhCurve,\n      honorCipherOrder,\n      key,\n      passphrase,\n      pfx,\n      rejectUnauthorized = true,\n      secureOptions,\n      secureProtocol,\n      servername,\n      sessionIdContext\n    } = init;\n    this[INTERNALS] = {\n      method,\n      redirect: init.redirect || input.redirect || 'follow',\n      headers,\n      parsedURL,\n      signal,\n      ca,\n      cert,\n      ciphers,\n      clientCertEngine,\n      crl,\n      dhparam,\n      ecdhCurve,\n      honorCipherOrder,\n      key,\n      passphrase,\n      pfx,\n      rejectUnauthorized,\n      secureOptions,\n      secureProtocol,\n      servername,\n      sessionIdContext\n    }; // node-fetch-only options\n\n    this.follow = init.follow !== undefined ? init.follow : input.follow !== undefined ? input.follow : 20;\n    this.compress = init.compress !== undefined ? init.compress : input.compress !== undefined ? input.compress : true;\n    this.counter = init.counter || input.counter || 0;\n    this.agent = init.agent || input.agent;\n  }\n\n  get method() {\n    return this[INTERNALS].method;\n  }\n\n  get url() {\n    return formatUrl(this[INTERNALS].parsedURL);\n  }\n\n  get headers() {\n    return this[INTERNALS].headers;\n  }\n\n  get redirect() {\n    return this[INTERNALS].redirect;\n  }\n\n  get signal() {\n    return this[INTERNALS].signal;\n  }\n\n  clone() {\n    return new Request(this);\n  }\n\n  get [Symbol.toStringTag]() {\n    return 'Request';\n  }\n\n  static getNodeRequestOptions(request) {\n    const parsedURL = request[INTERNALS].parsedURL;\n    const headers = new Headers(request[INTERNALS].headers); // fetch step 1.3\n\n    if (!headers.has('Accept')) headers.set('Accept', '*/*'); // Basic fetch\n\n    if (!parsedURL.protocol || !parsedURL.hostname) throw new TypeError('Only absolute URLs are supported');\n    if (!/^https?:$/.test(parsedURL.protocol)) throw new TypeError('Only HTTP(S) protocols are supported');\n\n    if (request.signal && Minipass.isStream(request.body) && typeof request.body.destroy !== 'function') {\n      throw new Error('Cancellation of streamed requests with AbortSignal is not supported');\n    } // HTTP-network-or-cache fetch steps 2.4-2.7\n\n\n    const contentLengthValue = (request.body === null || request.body === undefined) && /^(POST|PUT)$/i.test(request.method) ? '0' : request.body !== null && request.body !== undefined ? getTotalBytes(request) : null;\n    if (contentLengthValue) headers.set('Content-Length', contentLengthValue + ''); // HTTP-network-or-cache fetch step 2.11\n\n    if (!headers.has('User-Agent')) headers.set('User-Agent', defaultUserAgent); // HTTP-network-or-cache fetch step 2.15\n\n    if (request.compress && !headers.has('Accept-Encoding')) headers.set('Accept-Encoding', 'gzip,deflate');\n    const agent = typeof request.agent === 'function' ? request.agent(parsedURL) : request.agent;\n    if (!headers.has('Connection') && !agent) headers.set('Connection', 'close'); // TLS specific options that are handled by node\n\n    const {\n      ca,\n      cert,\n      ciphers,\n      clientCertEngine,\n      crl,\n      dhparam,\n      ecdhCurve,\n      honorCipherOrder,\n      key,\n      passphrase,\n      pfx,\n      rejectUnauthorized,\n      secureOptions,\n      secureProtocol,\n      servername,\n      sessionIdContext\n    } = request[INTERNALS]; // HTTP-network fetch step 4.2\n    // chunked encoding is handled by Node.js\n\n    return { ...parsedURL,\n      method: request.method,\n      headers: exportNodeCompatibleHeaders(headers),\n      agent,\n      ca,\n      cert,\n      ciphers,\n      clientCertEngine,\n      crl,\n      dhparam,\n      ecdhCurve,\n      honorCipherOrder,\n      key,\n      passphrase,\n      pfx,\n      rejectUnauthorized,\n      secureOptions,\n      secureProtocol,\n      servername,\n      sessionIdContext\n    };\n  }\n\n}\n\nmodule.exports = Request;\nObject.defineProperties(Request.prototype, {\n  method: {\n    enumerable: true\n  },\n  url: {\n    enumerable: true\n  },\n  headers: {\n    enumerable: true\n  },\n  redirect: {\n    enumerable: true\n  },\n  clone: {\n    enumerable: true\n  },\n  signal: {\n    enumerable: true\n  }\n});","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/node_modules/minipass-fetch/lib/request.js"],"names":["Url","require","Minipass","Headers","exportNodeCompatibleHeaders","Body","clone","extractContentType","getTotalBytes","version","defaultUserAgent","INTERNALS","Symbol","parse","parseUrl","format","formatUrl","isRequest","input","isAbortSignal","signal","proto","Object","getPrototypeOf","constructor","name","Request","init","parsedURL","url","href","method","toUpperCase","isGETHEAD","body","undefined","TypeError","inputBody","timeout","size","headers","has","contentType","append","ca","cert","ciphers","clientCertEngine","crl","dhparam","ecdhCurve","honorCipherOrder","key","passphrase","pfx","rejectUnauthorized","secureOptions","secureProtocol","servername","sessionIdContext","redirect","follow","compress","counter","agent","toStringTag","getNodeRequestOptions","request","set","protocol","hostname","test","isStream","destroy","Error","contentLengthValue","module","exports","defineProperties","prototype","enumerable"],"mappings":"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","sourcesContent":["'use strict'\nconst Url = require('url')\nconst Minipass = require('minipass')\nconst Headers = require('./headers.js')\nconst { exportNodeCompatibleHeaders } = Headers\nconst Body = require('./body.js')\nconst { clone, extractContentType, getTotalBytes } = Body\n\nconst version = require('../package.json').version\nconst defaultUserAgent =\n  `minipass-fetch/${version} (+https://github.com/isaacs/minipass-fetch)`\n\nconst INTERNALS = Symbol('Request internals')\n\nconst { parse: parseUrl, format: formatUrl } = Url\n\nconst isRequest = input =>\n  typeof input === 'object' && typeof input[INTERNALS] === 'object'\n\nconst isAbortSignal = signal => {\n  const proto = (\n    signal\n    && typeof signal === 'object'\n    && Object.getPrototypeOf(signal)\n  )\n  return !!(proto && proto.constructor.name === 'AbortSignal')\n}\n\nclass Request extends Body {\n  constructor (input, init = {}) {\n    const parsedURL = isRequest(input) ? Url.parse(input.url)\n      : input && input.href ? Url.parse(input.href)\n      : Url.parse(`${input}`)\n\n    if (isRequest(input))\n      init = { ...input[INTERNALS], ...init }\n    else if (!input || typeof input === 'string')\n      input = {}\n\n    const method = (init.method || input.method || 'GET').toUpperCase()\n    const isGETHEAD = method === 'GET' || method === 'HEAD'\n\n    if ((init.body !== null && init.body !== undefined ||\n        isRequest(input) && input.body !== null) && isGETHEAD)\n      throw new TypeError('Request with GET/HEAD method cannot have body')\n\n    const inputBody = init.body !== null && init.body !== undefined ? init.body\n      : isRequest(input) && input.body !== null ? clone(input)\n      : null\n\n    super(inputBody, {\n      timeout: init.timeout || input.timeout || 0,\n      size: init.size || input.size || 0,\n    })\n\n    const headers = new Headers(init.headers || input.headers || {})\n\n    if (inputBody !== null && inputBody !== undefined &&\n        !headers.has('Content-Type')) {\n      const contentType = extractContentType(inputBody)\n      if (contentType)\n        headers.append('Content-Type', contentType)\n    }\n\n    const signal = 'signal' in init ? init.signal\n      : null\n\n    if (signal !== null && signal !== undefined && !isAbortSignal(signal))\n      throw new TypeError('Expected signal must be an instanceof AbortSignal')\n\n    // TLS specific options that are handled by node\n    const {\n      ca,\n      cert,\n      ciphers,\n      clientCertEngine,\n      crl,\n      dhparam,\n      ecdhCurve,\n      honorCipherOrder,\n      key,\n      passphrase,\n      pfx,\n      rejectUnauthorized = true,\n      secureOptions,\n      secureProtocol,\n      servername,\n      sessionIdContext,\n    } = init\n\n    this[INTERNALS] = {\n      method,\n      redirect: init.redirect || input.redirect || 'follow',\n      headers,\n      parsedURL,\n      signal,\n      ca,\n      cert,\n      ciphers,\n      clientCertEngine,\n      crl,\n      dhparam,\n      ecdhCurve,\n      honorCipherOrder,\n      key,\n      passphrase,\n      pfx,\n      rejectUnauthorized,\n      secureOptions,\n      secureProtocol,\n      servername,\n      sessionIdContext,\n    }\n\n    // node-fetch-only options\n    this.follow = init.follow !== undefined ? init.follow\n      : input.follow !== undefined ? input.follow\n      : 20\n    this.compress = init.compress !== undefined ? init.compress\n      : input.compress !== undefined ? input.compress\n      : true\n    this.counter = init.counter || input.counter || 0\n    this.agent = init.agent || input.agent\n  }\n\n  get method() {\n    return this[INTERNALS].method\n  }\n\n  get url() {\n    return formatUrl(this[INTERNALS].parsedURL)\n  }\n\n  get headers() {\n    return this[INTERNALS].headers\n  }\n\n  get redirect() {\n    return this[INTERNALS].redirect\n  }\n\n  get signal() {\n    return this[INTERNALS].signal\n  }\n\n  clone () {\n    return new Request(this)\n  }\n\n  get [Symbol.toStringTag] () {\n    return 'Request'\n  }\n\n  static getNodeRequestOptions (request) {\n    const parsedURL = request[INTERNALS].parsedURL\n    const headers = new Headers(request[INTERNALS].headers)\n\n    // fetch step 1.3\n    if (!headers.has('Accept'))\n      headers.set('Accept', '*/*')\n\n    // Basic fetch\n    if (!parsedURL.protocol || !parsedURL.hostname)\n      throw new TypeError('Only absolute URLs are supported')\n\n    if (!/^https?:$/.test(parsedURL.protocol))\n      throw new TypeError('Only HTTP(S) protocols are supported')\n\n    if (request.signal &&\n        Minipass.isStream(request.body) &&\n        typeof request.body.destroy !== 'function') {\n      throw new Error(\n        'Cancellation of streamed requests with AbortSignal is not supported')\n    }\n\n    // HTTP-network-or-cache fetch steps 2.4-2.7\n    const contentLengthValue =\n      (request.body === null || request.body === undefined) &&\n        /^(POST|PUT)$/i.test(request.method) ? '0'\n      : request.body !== null && request.body !== undefined\n        ? getTotalBytes(request)\n      : null\n\n    if (contentLengthValue)\n      headers.set('Content-Length', contentLengthValue + '')\n\n    // HTTP-network-or-cache fetch step 2.11\n    if (!headers.has('User-Agent'))\n      headers.set('User-Agent', defaultUserAgent)\n\n    // HTTP-network-or-cache fetch step 2.15\n    if (request.compress && !headers.has('Accept-Encoding'))\n      headers.set('Accept-Encoding', 'gzip,deflate')\n\n    const agent = typeof request.agent === 'function'\n      ? request.agent(parsedURL)\n      : request.agent\n\n    if (!headers.has('Connection') && !agent)\n      headers.set('Connection', 'close')\n\n    // TLS specific options that are handled by node\n    const {\n      ca,\n      cert,\n      ciphers,\n      clientCertEngine,\n      crl,\n      dhparam,\n      ecdhCurve,\n      honorCipherOrder,\n      key,\n      passphrase,\n      pfx,\n      rejectUnauthorized,\n      secureOptions,\n      secureProtocol,\n      servername,\n      sessionIdContext,\n    } = request[INTERNALS]\n\n    // HTTP-network fetch step 4.2\n    // chunked encoding is handled by Node.js\n\n    return {\n      ...parsedURL,\n      method: request.method,\n      headers: exportNodeCompatibleHeaders(headers),\n      agent,\n      ca,\n      cert,\n      ciphers,\n      clientCertEngine,\n      crl,\n      dhparam,\n      ecdhCurve,\n      honorCipherOrder,\n      key,\n      passphrase,\n      pfx,\n      rejectUnauthorized,\n      secureOptions,\n      secureProtocol,\n      servername,\n      sessionIdContext,\n    }\n  }\n}\n\nmodule.exports = Request\n\nObject.defineProperties(Request.prototype, {\n  method: { enumerable: true },\n  url: { enumerable: true },\n  headers: { enumerable: true },\n  redirect: { enumerable: true },\n  clone: { enumerable: true },\n  signal: { enumerable: true },\n})\n"]},"metadata":{},"sourceType":"script"}
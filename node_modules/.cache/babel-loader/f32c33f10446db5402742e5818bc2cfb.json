{"ast":null,"code":"// a tree representing the difference between two trees\n// A Diff node's parent is not necessarily the parent of\n// the node location it refers to, but rather the highest level\n// node that needs to be either changed or removed.\n// Thus, the root Diff node is the shallowest change required\n// for a given branch of the tree being mutated.\nconst {\n  depth\n} = require('treeverse');\n\nconst {\n  existsSync\n} = require('fs');\n\nconst ssri = require('ssri');\n\nclass Diff {\n  constructor({\n    actual,\n    ideal,\n    filterSet\n  }) {\n    this.filterSet = filterSet;\n    this.children = [];\n    this.actual = actual;\n    this.ideal = ideal;\n\n    if (this.ideal) {\n      this.resolved = this.ideal.resolved;\n      this.integrity = this.ideal.integrity;\n    }\n\n    this.action = getAction(this);\n    this.parent = null; // the set of leaf nodes that we rake up to the top level\n\n    this.leaves = []; // the set of nodes that don't change in this branch of the tree\n\n    this.unchanged = []; // the set of nodes that will be removed in this branch of the tree\n\n    this.removed = [];\n  }\n\n  static calculate({\n    actual,\n    ideal,\n    filterNodes = []\n  }) {\n    // if there's a filterNode, then:\n    // - get the path from the root to the filterNode.  The root or\n    //   root.target should have an edge either to the filterNode or\n    //   a link to the filterNode.  If not, abort.  Add the path to the\n    //   filterSet.\n    // - Add set of Nodes depended on by the filterNode to filterSet.\n    // - Anything outside of that set should be ignored by getChildren\n    const filterSet = new Set();\n\n    for (const filterNode of filterNodes) {\n      const {\n        root\n      } = filterNode;\n      if (root !== ideal && root !== actual) throw new Error('invalid filterNode: outside idealTree/actualTree');\n      const {\n        target\n      } = root;\n      const rootTarget = target || root;\n      const edge = [...rootTarget.edgesOut.values()].filter(e => {\n        return e.to && (e.to === filterNode || e.to.target === filterNode);\n      })[0];\n      filterSet.add(root);\n      filterSet.add(rootTarget);\n      filterSet.add(ideal);\n      filterSet.add(actual);\n\n      if (edge && edge.to) {\n        filterSet.add(edge.to);\n        if (edge.to.target) filterSet.add(edge.to.target);\n      }\n\n      filterSet.add(filterNode);\n      depth({\n        tree: filterNode,\n        visit: node => filterSet.add(node),\n        getChildren: node => {\n          node = node.target || node;\n          const loc = node.location;\n          const idealNode = ideal.inventory.get(loc);\n          const ideals = !idealNode ? [] : [...idealNode.edgesOut.values()].filter(e => e.to).map(e => e.to);\n          const actualNode = actual.inventory.get(loc);\n          const actuals = !actualNode ? [] : [...actualNode.edgesOut.values()].filter(e => e.to).map(e => e.to);\n          return ideals.concat(actuals);\n        }\n      });\n    }\n\n    return depth({\n      tree: new Diff({\n        actual,\n        ideal,\n        filterSet\n      }),\n      getChildren,\n      leave\n    });\n  }\n\n}\n\nconst getAction = ({\n  actual,\n  ideal\n}) => {\n  if (!ideal) return 'REMOVE'; // bundled meta-deps are copied over to the ideal tree when we visit it,\n  // so they'll appear to be missing here.  There's no need to handle them\n  // in the diff, though, because they'll be replaced at reify time anyway\n  // Otherwise, add the missing node.\n\n  if (!actual) return ideal.inDepBundle ? null : 'ADD'; // always ignore the root node\n\n  if (ideal.isRoot && actual.isRoot) return null;\n  const binsExist = ideal.binPaths.every(path => existsSync(path)); // top nodes, links, and git deps won't have integrity, but do have resolved\n\n  if (!ideal.integrity && !actual.integrity && ideal.resolved === actual.resolved && binsExist) return null; // otherwise, verify that it's the same bits\n  // note that if ideal has integrity, and resolved doesn't, we treat\n  // that as a 'change', so that it gets re-fetched and locked down.\n\n  if (!ideal.integrity || !actual.integrity || !ssri.parse(ideal.integrity).match(actual.integrity) || !binsExist) return 'CHANGE';\n  return null;\n};\n\nconst allChildren = node => {\n  if (!node) return new Map(); // if the node is a global root, and also a link, then what we really\n  // want is to traverse the target's children\n\n  if (node.global && node.isRoot && node.isLink) return allChildren(node.target);\n  const kids = new Map();\n\n  for (const n of [node, ...node.fsChildren]) {\n    for (const kid of n.children.values()) kids.set(kid.path, kid);\n  }\n\n  return kids;\n}; // functions for the walk options when we traverse the trees\n// to create the diff tree\n\n\nconst getChildren = diff => {\n  const children = [];\n  const {\n    actual,\n    ideal,\n    unchanged,\n    removed,\n    filterSet\n  } = diff; // Note: we DON'T diff fsChildren themselves, because they are either\n  // included in the package contents, or part of some other project, and\n  // will never appear in legacy shrinkwraps anyway.  but we _do_ include the\n  // child nodes of fsChildren, because those are nodes that we are typically\n  // responsible for installing.\n\n  const actualKids = allChildren(actual);\n  const idealKids = allChildren(ideal);\n  const paths = new Set([...actualKids.keys(), ...idealKids.keys()]);\n\n  for (const path of paths) {\n    const actual = actualKids.get(path);\n    const ideal = idealKids.get(path);\n    diffNode(actual, ideal, children, unchanged, removed, filterSet);\n  }\n\n  if (diff.leaves && !children.length) diff.leaves.push(diff);\n  return children;\n};\n\nconst diffNode = (actual, ideal, children, unchanged, removed, filterSet) => {\n  if (filterSet.size && !(filterSet.has(ideal) || filterSet.has(actual))) return;\n  const action = getAction({\n    actual,\n    ideal\n  }); // if it's a match, then get its children\n  // otherwise, this is the child diff node\n\n  if (action) {\n    if (action === 'REMOVE') removed.push(actual);\n    children.push(new Diff({\n      actual,\n      ideal,\n      filterSet\n    }));\n  } else {\n    unchanged.push(ideal); // !*! Weird dirty hack warning !*!\n    //\n    // Bundled deps aren't loaded in the ideal tree, because we don't know\n    // what they are going to be without unpacking.  Swap them over now if\n    // the bundling node isn't changing, so we don't prune them later.\n    //\n    // It's a little bit dirty to be doing this here, since it means that\n    // diffing trees can mutate them, but otherwise we have to walk over\n    // all unchanging bundlers and correct the diff later, so it's more\n    // efficient to just fix it while we're passing through already.\n    //\n    // Note that moving over a bundled dep will break the links to other\n    // deps under this parent, which may have been transitively bundled.\n    // Breaking those links means that we'll no longer see the transitive\n    // dependency, meaning that it won't appear as bundled any longer!\n    // In order to not end up dropping transitively bundled deps, we have\n    // to get the list of nodes to move, then move them all at once, rather\n    // than moving them one at a time in the first loop.\n\n    const bd = ideal.package.bundleDependencies;\n\n    if (actual && bd && bd.length) {\n      const bundledChildren = [];\n\n      for (const node of actual.children.values()) {\n        if (node.inBundle) bundledChildren.push(node);\n      }\n\n      for (const node of bundledChildren) node.parent = ideal;\n    }\n\n    children.push(...getChildren({\n      actual,\n      ideal,\n      unchanged,\n      removed,\n      filterSet\n    }));\n  }\n}; // set the parentage in the leave step so that we aren't attaching\n// child nodes only to remove them later.  also bubble up the unchanged\n// nodes so that we can move them out of staging in the reification step.\n\n\nconst leave = (diff, children) => {\n  children.forEach(kid => {\n    kid.parent = diff;\n    diff.leaves.push(...kid.leaves);\n    diff.unchanged.push(...kid.unchanged);\n    diff.removed.push(...kid.removed);\n  });\n  diff.children = children;\n  return diff;\n};\n\nmodule.exports = Diff;","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/node_modules/@npmcli/arborist/lib/diff.js"],"names":["depth","require","existsSync","ssri","Diff","constructor","actual","ideal","filterSet","children","resolved","integrity","action","getAction","parent","leaves","unchanged","removed","calculate","filterNodes","Set","filterNode","root","Error","target","rootTarget","edge","edgesOut","values","filter","e","to","add","tree","visit","node","getChildren","loc","location","idealNode","inventory","get","ideals","map","actualNode","actuals","concat","leave","inDepBundle","isRoot","binsExist","binPaths","every","path","parse","match","allChildren","Map","global","isLink","kids","n","fsChildren","kid","set","diff","actualKids","idealKids","paths","keys","diffNode","length","push","size","has","bd","package","bundleDependencies","bundledChildren","inBundle","forEach","module","exports"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AAEA,MAAM;AAACA,EAAAA;AAAD,IAAUC,OAAO,CAAC,WAAD,CAAvB;;AACA,MAAM;AAACC,EAAAA;AAAD,IAAeD,OAAO,CAAC,IAAD,CAA5B;;AAEA,MAAME,IAAI,GAAGF,OAAO,CAAC,MAAD,CAApB;;AAEA,MAAMG,IAAN,CAAW;AACTC,EAAAA,WAAW,CAAE;AAACC,IAAAA,MAAD;AAASC,IAAAA,KAAT;AAAgBC,IAAAA;AAAhB,GAAF,EAA8B;AACvC,SAAKA,SAAL,GAAiBA,SAAjB;AACA,SAAKC,QAAL,GAAgB,EAAhB;AACA,SAAKH,MAAL,GAAcA,MAAd;AACA,SAAKC,KAAL,GAAaA,KAAb;;AACA,QAAI,KAAKA,KAAT,EAAgB;AACd,WAAKG,QAAL,GAAgB,KAAKH,KAAL,CAAWG,QAA3B;AACA,WAAKC,SAAL,GAAiB,KAAKJ,KAAL,CAAWI,SAA5B;AACD;;AACD,SAAKC,MAAL,GAAcC,SAAS,CAAC,IAAD,CAAvB;AACA,SAAKC,MAAL,GAAc,IAAd,CAVuC,CAWvC;;AACA,SAAKC,MAAL,GAAc,EAAd,CAZuC,CAavC;;AACA,SAAKC,SAAL,GAAiB,EAAjB,CAduC,CAevC;;AACA,SAAKC,OAAL,GAAe,EAAf;AACD;;AAEe,SAATC,SAAS,CAAE;AAACZ,IAAAA,MAAD;AAASC,IAAAA,KAAT;AAAgBY,IAAAA,WAAW,GAAG;AAA9B,GAAF,EAAqC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAMX,SAAS,GAAG,IAAIY,GAAJ,EAAlB;;AACA,SAAK,MAAMC,UAAX,IAAyBF,WAAzB,EAAsC;AACpC,YAAM;AAAEG,QAAAA;AAAF,UAAWD,UAAjB;AACA,UAAIC,IAAI,KAAKf,KAAT,IAAkBe,IAAI,KAAKhB,MAA/B,EACE,MAAM,IAAIiB,KAAJ,CAAU,kDAAV,CAAN;AACF,YAAM;AAAEC,QAAAA;AAAF,UAAaF,IAAnB;AACA,YAAMG,UAAU,GAAGD,MAAM,IAAIF,IAA7B;AACA,YAAMI,IAAI,GAAG,CAAC,GAAGD,UAAU,CAACE,QAAX,CAAoBC,MAApB,EAAJ,EAAkCC,MAAlC,CAAyCC,CAAC,IAAI;AACzD,eAAOA,CAAC,CAACC,EAAF,KAASD,CAAC,CAACC,EAAF,KAASV,UAAT,IAAuBS,CAAC,CAACC,EAAF,CAAKP,MAAL,KAAgBH,UAAhD,CAAP;AACD,OAFY,EAEV,CAFU,CAAb;AAGAb,MAAAA,SAAS,CAACwB,GAAV,CAAcV,IAAd;AACAd,MAAAA,SAAS,CAACwB,GAAV,CAAcP,UAAd;AACAjB,MAAAA,SAAS,CAACwB,GAAV,CAAczB,KAAd;AACAC,MAAAA,SAAS,CAACwB,GAAV,CAAc1B,MAAd;;AACA,UAAIoB,IAAI,IAAIA,IAAI,CAACK,EAAjB,EAAqB;AACnBvB,QAAAA,SAAS,CAACwB,GAAV,CAAcN,IAAI,CAACK,EAAnB;AACA,YAAIL,IAAI,CAACK,EAAL,CAAQP,MAAZ,EACEhB,SAAS,CAACwB,GAAV,CAAcN,IAAI,CAACK,EAAL,CAAQP,MAAtB;AACH;;AACDhB,MAAAA,SAAS,CAACwB,GAAV,CAAcX,UAAd;AAEArB,MAAAA,KAAK,CAAC;AACJiC,QAAAA,IAAI,EAAEZ,UADF;AAEJa,QAAAA,KAAK,EAAEC,IAAI,IAAI3B,SAAS,CAACwB,GAAV,CAAcG,IAAd,CAFX;AAGJC,QAAAA,WAAW,EAAED,IAAI,IAAI;AACnBA,UAAAA,IAAI,GAAGA,IAAI,CAACX,MAAL,IAAeW,IAAtB;AACA,gBAAME,GAAG,GAAGF,IAAI,CAACG,QAAjB;AACA,gBAAMC,SAAS,GAAGhC,KAAK,CAACiC,SAAN,CAAgBC,GAAhB,CAAoBJ,GAApB,CAAlB;AACA,gBAAMK,MAAM,GAAG,CAACH,SAAD,GAAa,EAAb,GACX,CAAC,GAAGA,SAAS,CAACZ,QAAV,CAAmBC,MAAnB,EAAJ,EAAiCC,MAAjC,CAAwCC,CAAC,IAAIA,CAAC,CAACC,EAA/C,EAAmDY,GAAnD,CAAuDb,CAAC,IAAIA,CAAC,CAACC,EAA9D,CADJ;AAEA,gBAAMa,UAAU,GAAGtC,MAAM,CAACkC,SAAP,CAAiBC,GAAjB,CAAqBJ,GAArB,CAAnB;AACA,gBAAMQ,OAAO,GAAG,CAACD,UAAD,GAAc,EAAd,GACZ,CAAC,GAAGA,UAAU,CAACjB,QAAX,CAAoBC,MAApB,EAAJ,EAAkCC,MAAlC,CAAyCC,CAAC,IAAIA,CAAC,CAACC,EAAhD,EAAoDY,GAApD,CAAwDb,CAAC,IAAIA,CAAC,CAACC,EAA/D,CADJ;AAEA,iBAAOW,MAAM,CAACI,MAAP,CAAcD,OAAd,CAAP;AACD;AAbG,OAAD,CAAL;AAeD;;AAED,WAAO7C,KAAK,CAAC;AACXiC,MAAAA,IAAI,EAAE,IAAI7B,IAAJ,CAAS;AAACE,QAAAA,MAAD;AAASC,QAAAA,KAAT;AAAgBC,QAAAA;AAAhB,OAAT,CADK;AAEX4B,MAAAA,WAFW;AAGXW,MAAAA;AAHW,KAAD,CAAZ;AAKD;;AAvEQ;;AA0EX,MAAMlC,SAAS,GAAG,CAAC;AAACP,EAAAA,MAAD;AAASC,EAAAA;AAAT,CAAD,KAAqB;AACrC,MAAI,CAACA,KAAL,EACE,OAAO,QAAP,CAFmC,CAIrC;AACA;AACA;AACA;;AACA,MAAI,CAACD,MAAL,EACE,OAAOC,KAAK,CAACyC,WAAN,GAAoB,IAApB,GAA2B,KAAlC,CATmC,CAWrC;;AACA,MAAIzC,KAAK,CAAC0C,MAAN,IAAgB3C,MAAM,CAAC2C,MAA3B,EACE,OAAO,IAAP;AAEF,QAAMC,SAAS,GAAG3C,KAAK,CAAC4C,QAAN,CAAeC,KAAf,CAAsBC,IAAD,IAAUnD,UAAU,CAACmD,IAAD,CAAzC,CAAlB,CAfqC,CAiBrC;;AACA,MAAI,CAAC9C,KAAK,CAACI,SAAP,IAAoB,CAACL,MAAM,CAACK,SAA5B,IAAyCJ,KAAK,CAACG,QAAN,KAAmBJ,MAAM,CAACI,QAAnE,IAA+EwC,SAAnF,EACE,OAAO,IAAP,CAnBmC,CAqBrC;AACA;AACA;;AACA,MAAI,CAAC3C,KAAK,CAACI,SAAP,IAAoB,CAACL,MAAM,CAACK,SAA5B,IAAyC,CAACR,IAAI,CAACmD,KAAL,CAAW/C,KAAK,CAACI,SAAjB,EAA4B4C,KAA5B,CAAkCjD,MAAM,CAACK,SAAzC,CAA1C,IAAiG,CAACuC,SAAtG,EACE,OAAO,QAAP;AAEF,SAAO,IAAP;AACD,CA5BD;;AA8BA,MAAMM,WAAW,GAAGrB,IAAI,IAAI;AAC1B,MAAI,CAACA,IAAL,EACE,OAAO,IAAIsB,GAAJ,EAAP,CAFwB,CAI1B;AACA;;AACA,MAAItB,IAAI,CAACuB,MAAL,IAAevB,IAAI,CAACc,MAApB,IAA8Bd,IAAI,CAACwB,MAAvC,EACE,OAAOH,WAAW,CAACrB,IAAI,CAACX,MAAN,CAAlB;AAEF,QAAMoC,IAAI,GAAG,IAAIH,GAAJ,EAAb;;AACA,OAAK,MAAMI,CAAX,IAAgB,CAAC1B,IAAD,EAAO,GAAGA,IAAI,CAAC2B,UAAf,CAAhB,EAA4C;AAC1C,SAAK,MAAMC,GAAX,IAAkBF,CAAC,CAACpD,QAAF,CAAWmB,MAAX,EAAlB,EACEgC,IAAI,CAACI,GAAL,CAASD,GAAG,CAACV,IAAb,EAAmBU,GAAnB;AACH;;AACD,SAAOH,IAAP;AACD,CAfD,C,CAiBA;AACA;;;AACA,MAAMxB,WAAW,GAAG6B,IAAI,IAAI;AAC1B,QAAMxD,QAAQ,GAAG,EAAjB;AACA,QAAM;AAACH,IAAAA,MAAD;AAASC,IAAAA,KAAT;AAAgBS,IAAAA,SAAhB;AAA2BC,IAAAA,OAA3B;AAAoCT,IAAAA;AAApC,MAAiDyD,IAAvD,CAF0B,CAI1B;AACA;AACA;AACA;AACA;;AACA,QAAMC,UAAU,GAAGV,WAAW,CAAClD,MAAD,CAA9B;AACA,QAAM6D,SAAS,GAAGX,WAAW,CAACjD,KAAD,CAA7B;AACA,QAAM6D,KAAK,GAAG,IAAIhD,GAAJ,CAAQ,CAAC,GAAG8C,UAAU,CAACG,IAAX,EAAJ,EAAuB,GAAGF,SAAS,CAACE,IAAV,EAA1B,CAAR,CAAd;;AACA,OAAK,MAAMhB,IAAX,IAAmBe,KAAnB,EAA0B;AACxB,UAAM9D,MAAM,GAAG4D,UAAU,CAACzB,GAAX,CAAeY,IAAf,CAAf;AACA,UAAM9C,KAAK,GAAG4D,SAAS,CAAC1B,GAAV,CAAcY,IAAd,CAAd;AACAiB,IAAAA,QAAQ,CAAChE,MAAD,EAASC,KAAT,EAAgBE,QAAhB,EAA0BO,SAA1B,EAAqCC,OAArC,EAA8CT,SAA9C,CAAR;AACD;;AAED,MAAIyD,IAAI,CAAClD,MAAL,IAAe,CAACN,QAAQ,CAAC8D,MAA7B,EACEN,IAAI,CAAClD,MAAL,CAAYyD,IAAZ,CAAiBP,IAAjB;AAEF,SAAOxD,QAAP;AACD,CAtBD;;AAwBA,MAAM6D,QAAQ,GAAG,CAAChE,MAAD,EAASC,KAAT,EAAgBE,QAAhB,EAA0BO,SAA1B,EAAqCC,OAArC,EAA8CT,SAA9C,KAA4D;AAC3E,MAAIA,SAAS,CAACiE,IAAV,IAAkB,EAAEjE,SAAS,CAACkE,GAAV,CAAcnE,KAAd,KAAwBC,SAAS,CAACkE,GAAV,CAAcpE,MAAd,CAA1B,CAAtB,EACE;AAEF,QAAMM,MAAM,GAAGC,SAAS,CAAC;AAACP,IAAAA,MAAD;AAASC,IAAAA;AAAT,GAAD,CAAxB,CAJ2E,CAM3E;AACA;;AACA,MAAIK,MAAJ,EAAY;AACV,QAAIA,MAAM,KAAK,QAAf,EACEK,OAAO,CAACuD,IAAR,CAAalE,MAAb;AACFG,IAAAA,QAAQ,CAAC+D,IAAT,CAAc,IAAIpE,IAAJ,CAAS;AAACE,MAAAA,MAAD;AAASC,MAAAA,KAAT;AAAgBC,MAAAA;AAAhB,KAAT,CAAd;AACD,GAJD,MAIO;AACLQ,IAAAA,SAAS,CAACwD,IAAV,CAAejE,KAAf,EADK,CAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,UAAMoE,EAAE,GAAGpE,KAAK,CAACqE,OAAN,CAAcC,kBAAzB;;AACA,QAAIvE,MAAM,IAAIqE,EAAV,IAAgBA,EAAE,CAACJ,MAAvB,EAA+B;AAC7B,YAAMO,eAAe,GAAG,EAAxB;;AACA,WAAK,MAAM3C,IAAX,IAAmB7B,MAAM,CAACG,QAAP,CAAgBmB,MAAhB,EAAnB,EAA6C;AAC3C,YAAIO,IAAI,CAAC4C,QAAT,EACED,eAAe,CAACN,IAAhB,CAAqBrC,IAArB;AACH;;AACD,WAAK,MAAMA,IAAX,IAAmB2C,eAAnB,EACE3C,IAAI,CAACrB,MAAL,GAAcP,KAAd;AACH;;AACDE,IAAAA,QAAQ,CAAC+D,IAAT,CAAc,GAAGpC,WAAW,CAAC;AAAC9B,MAAAA,MAAD;AAASC,MAAAA,KAAT;AAAgBS,MAAAA,SAAhB;AAA2BC,MAAAA,OAA3B;AAAoCT,MAAAA;AAApC,KAAD,CAA5B;AACD;AACF,CA5CD,C,CA8CA;AACA;AACA;;;AACA,MAAMuC,KAAK,GAAG,CAACkB,IAAD,EAAOxD,QAAP,KAAoB;AAChCA,EAAAA,QAAQ,CAACuE,OAAT,CAAiBjB,GAAG,IAAI;AACtBA,IAAAA,GAAG,CAACjD,MAAJ,GAAamD,IAAb;AACAA,IAAAA,IAAI,CAAClD,MAAL,CAAYyD,IAAZ,CAAiB,GAAGT,GAAG,CAAChD,MAAxB;AACAkD,IAAAA,IAAI,CAACjD,SAAL,CAAewD,IAAf,CAAoB,GAAGT,GAAG,CAAC/C,SAA3B;AACAiD,IAAAA,IAAI,CAAChD,OAAL,CAAauD,IAAb,CAAkB,GAAGT,GAAG,CAAC9C,OAAzB;AACD,GALD;AAMAgD,EAAAA,IAAI,CAACxD,QAAL,GAAgBA,QAAhB;AACA,SAAOwD,IAAP;AACD,CATD;;AAWAgB,MAAM,CAACC,OAAP,GAAiB9E,IAAjB","sourcesContent":["// a tree representing the difference between two trees\n// A Diff node's parent is not necessarily the parent of\n// the node location it refers to, but rather the highest level\n// node that needs to be either changed or removed.\n// Thus, the root Diff node is the shallowest change required\n// for a given branch of the tree being mutated.\n\nconst {depth} = require('treeverse')\nconst {existsSync} = require('fs')\n\nconst ssri = require('ssri')\n\nclass Diff {\n  constructor ({actual, ideal, filterSet}) {\n    this.filterSet = filterSet\n    this.children = []\n    this.actual = actual\n    this.ideal = ideal\n    if (this.ideal) {\n      this.resolved = this.ideal.resolved\n      this.integrity = this.ideal.integrity\n    }\n    this.action = getAction(this)\n    this.parent = null\n    // the set of leaf nodes that we rake up to the top level\n    this.leaves = []\n    // the set of nodes that don't change in this branch of the tree\n    this.unchanged = []\n    // the set of nodes that will be removed in this branch of the tree\n    this.removed = []\n  }\n\n  static calculate ({actual, ideal, filterNodes = []}) {\n    // if there's a filterNode, then:\n    // - get the path from the root to the filterNode.  The root or\n    //   root.target should have an edge either to the filterNode or\n    //   a link to the filterNode.  If not, abort.  Add the path to the\n    //   filterSet.\n    // - Add set of Nodes depended on by the filterNode to filterSet.\n    // - Anything outside of that set should be ignored by getChildren\n    const filterSet = new Set()\n    for (const filterNode of filterNodes) {\n      const { root } = filterNode\n      if (root !== ideal && root !== actual)\n        throw new Error('invalid filterNode: outside idealTree/actualTree')\n      const { target } = root\n      const rootTarget = target || root\n      const edge = [...rootTarget.edgesOut.values()].filter(e => {\n        return e.to && (e.to === filterNode || e.to.target === filterNode)\n      })[0]\n      filterSet.add(root)\n      filterSet.add(rootTarget)\n      filterSet.add(ideal)\n      filterSet.add(actual)\n      if (edge && edge.to) {\n        filterSet.add(edge.to)\n        if (edge.to.target)\n          filterSet.add(edge.to.target)\n      }\n      filterSet.add(filterNode)\n\n      depth({\n        tree: filterNode,\n        visit: node => filterSet.add(node),\n        getChildren: node => {\n          node = node.target || node\n          const loc = node.location\n          const idealNode = ideal.inventory.get(loc)\n          const ideals = !idealNode ? []\n            : [...idealNode.edgesOut.values()].filter(e => e.to).map(e => e.to)\n          const actualNode = actual.inventory.get(loc)\n          const actuals = !actualNode ? []\n            : [...actualNode.edgesOut.values()].filter(e => e.to).map(e => e.to)\n          return ideals.concat(actuals)\n        },\n      })\n    }\n\n    return depth({\n      tree: new Diff({actual, ideal, filterSet}),\n      getChildren,\n      leave,\n    })\n  }\n}\n\nconst getAction = ({actual, ideal}) => {\n  if (!ideal)\n    return 'REMOVE'\n\n  // bundled meta-deps are copied over to the ideal tree when we visit it,\n  // so they'll appear to be missing here.  There's no need to handle them\n  // in the diff, though, because they'll be replaced at reify time anyway\n  // Otherwise, add the missing node.\n  if (!actual)\n    return ideal.inDepBundle ? null : 'ADD'\n\n  // always ignore the root node\n  if (ideal.isRoot && actual.isRoot)\n    return null\n\n  const binsExist = ideal.binPaths.every((path) => existsSync(path))\n\n  // top nodes, links, and git deps won't have integrity, but do have resolved\n  if (!ideal.integrity && !actual.integrity && ideal.resolved === actual.resolved && binsExist)\n    return null\n\n  // otherwise, verify that it's the same bits\n  // note that if ideal has integrity, and resolved doesn't, we treat\n  // that as a 'change', so that it gets re-fetched and locked down.\n  if (!ideal.integrity || !actual.integrity || !ssri.parse(ideal.integrity).match(actual.integrity) || !binsExist)\n    return 'CHANGE'\n\n  return null\n}\n\nconst allChildren = node => {\n  if (!node)\n    return new Map()\n\n  // if the node is a global root, and also a link, then what we really\n  // want is to traverse the target's children\n  if (node.global && node.isRoot && node.isLink)\n    return allChildren(node.target)\n\n  const kids = new Map()\n  for (const n of [node, ...node.fsChildren]) {\n    for (const kid of n.children.values())\n      kids.set(kid.path, kid)\n  }\n  return kids\n}\n\n// functions for the walk options when we traverse the trees\n// to create the diff tree\nconst getChildren = diff => {\n  const children = []\n  const {actual, ideal, unchanged, removed, filterSet} = diff\n\n  // Note: we DON'T diff fsChildren themselves, because they are either\n  // included in the package contents, or part of some other project, and\n  // will never appear in legacy shrinkwraps anyway.  but we _do_ include the\n  // child nodes of fsChildren, because those are nodes that we are typically\n  // responsible for installing.\n  const actualKids = allChildren(actual)\n  const idealKids = allChildren(ideal)\n  const paths = new Set([...actualKids.keys(), ...idealKids.keys()])\n  for (const path of paths) {\n    const actual = actualKids.get(path)\n    const ideal = idealKids.get(path)\n    diffNode(actual, ideal, children, unchanged, removed, filterSet)\n  }\n\n  if (diff.leaves && !children.length)\n    diff.leaves.push(diff)\n\n  return children\n}\n\nconst diffNode = (actual, ideal, children, unchanged, removed, filterSet) => {\n  if (filterSet.size && !(filterSet.has(ideal) || filterSet.has(actual)))\n    return\n\n  const action = getAction({actual, ideal})\n\n  // if it's a match, then get its children\n  // otherwise, this is the child diff node\n  if (action) {\n    if (action === 'REMOVE')\n      removed.push(actual)\n    children.push(new Diff({actual, ideal, filterSet}))\n  } else {\n    unchanged.push(ideal)\n    // !*! Weird dirty hack warning !*!\n    //\n    // Bundled deps aren't loaded in the ideal tree, because we don't know\n    // what they are going to be without unpacking.  Swap them over now if\n    // the bundling node isn't changing, so we don't prune them later.\n    //\n    // It's a little bit dirty to be doing this here, since it means that\n    // diffing trees can mutate them, but otherwise we have to walk over\n    // all unchanging bundlers and correct the diff later, so it's more\n    // efficient to just fix it while we're passing through already.\n    //\n    // Note that moving over a bundled dep will break the links to other\n    // deps under this parent, which may have been transitively bundled.\n    // Breaking those links means that we'll no longer see the transitive\n    // dependency, meaning that it won't appear as bundled any longer!\n    // In order to not end up dropping transitively bundled deps, we have\n    // to get the list of nodes to move, then move them all at once, rather\n    // than moving them one at a time in the first loop.\n    const bd = ideal.package.bundleDependencies\n    if (actual && bd && bd.length) {\n      const bundledChildren = []\n      for (const node of actual.children.values()) {\n        if (node.inBundle)\n          bundledChildren.push(node)\n      }\n      for (const node of bundledChildren)\n        node.parent = ideal\n    }\n    children.push(...getChildren({actual, ideal, unchanged, removed, filterSet}))\n  }\n}\n\n// set the parentage in the leave step so that we aren't attaching\n// child nodes only to remove them later.  also bubble up the unchanged\n// nodes so that we can move them out of staging in the reification step.\nconst leave = (diff, children) => {\n  children.forEach(kid => {\n    kid.parent = diff\n    diff.leaves.push(...kid.leaves)\n    diff.unchanged.push(...kid.unchanged)\n    diff.removed.push(...kid.removed)\n  })\n  diff.children = children\n  return diff\n}\n\nmodule.exports = Diff\n"]},"metadata":{},"sourceType":"script"}
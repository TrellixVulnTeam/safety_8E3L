{"ast":null,"code":"'use strict';\n\nconst fetch = require('minipass-fetch');\n\nconst cacache = require('cacache');\n\nconst ssri = require('ssri');\n\nconst url = require('url');\n\nconst Minipass = require('minipass');\n\nconst MinipassFlush = require('minipass-flush');\n\nconst MinipassCollect = require('minipass-collect');\n\nconst MinipassPipeline = require('minipass-pipeline');\n\nconst MAX_MEM_SIZE = 5 * 1024 * 1024; // 5MB\n// some headers should never be stored in the cache, either because\n// they're a security footgun to leave lying around, or because we\n// just don't need them taking up space.\n// set to undefined so they're omitted from the JSON.stringify\n\nconst pruneHeaders = {\n  authorization: undefined,\n  'npm-session': undefined,\n  'set-cookie': undefined,\n  'cf-ray': undefined,\n  'cf-cache-status': undefined,\n  'cf-request-id': undefined,\n  'x-fetch-attempts': undefined\n};\n\nfunction cacheKey(req) {\n  const parsed = new url.URL(req.url);\n  return `make-fetch-happen:request-cache:${url.format({\n    protocol: parsed.protocol,\n    slashes: true,\n    port: parsed.port,\n    hostname: parsed.hostname,\n    pathname: parsed.pathname,\n    search: parsed.search\n  })}`;\n} // This is a cacache-based implementation of the Cache standard,\n// using node-fetch.\n// docs: https://developer.mozilla.org/en-US/docs/Web/API/Cache\n//\n\n\nmodule.exports = class Cache {\n  constructor(path, opts) {\n    this._path = path;\n    this.Promise = opts && opts.Promise || Promise;\n  }\n\n  static get pruneHeaders() {\n    // exposed for testing, not modifiable\n    return { ...pruneHeaders\n    };\n  } // Returns a Promise that resolves to the response associated with the first\n  // matching request in the Cache object.\n\n\n  match(req, opts) {\n    const key = cacheKey(req);\n    return cacache.get.info(this._path, key).then(info => {\n      return info && cacache.get.hasContent(this._path, info.integrity, opts).then(exists => exists && info);\n    }).then(info => {\n      if (info && info.metadata && matchDetails(req, {\n        url: info.metadata.url,\n        reqHeaders: new fetch.Headers(info.metadata.reqHeaders),\n        resHeaders: new fetch.Headers(info.metadata.resHeaders),\n        cacheIntegrity: info.integrity,\n        integrity: opts && opts.integrity\n      })) {\n        const resHeaders = new fetch.Headers(info.metadata.resHeaders);\n        addCacheHeaders(resHeaders, this._path, key, info.integrity, info.time);\n\n        if (req.method === 'HEAD') {\n          return new fetch.Response(null, {\n            url: req.url,\n            headers: resHeaders,\n            status: 200\n          });\n        }\n\n        const cachePath = this._path; // avoid opening cache file handles until a user actually tries to\n        // read from it.\n\n        const body = new Minipass();\n        const fitInMemory = info.size < MAX_MEM_SIZE;\n\n        const removeOnResume = () => body.removeListener('resume', onResume);\n\n        const onResume = opts.memoize !== false && fitInMemory ? () => {\n          const c = cacache.get.stream.byDigest(cachePath, info.integrity, {\n            memoize: opts.memoize\n          });\n          c.on('error',\n          /* istanbul ignore next */\n          err => {\n            body.emit('error', err);\n          });\n          c.pipe(body);\n        } : () => {\n          removeOnResume();\n          cacache.get.byDigest(cachePath, info.integrity, {\n            memoize: opts.memoize\n          }).then(data => body.end(data)).catch(\n          /* istanbul ignore next */\n          err => {\n            body.emit('error', err);\n          });\n        };\n        body.once('resume', onResume);\n        body.once('end', () => removeOnResume);\n        return this.Promise.resolve(new fetch.Response(body, {\n          url: req.url,\n          headers: resHeaders,\n          status: 200,\n          size: info.size\n        }));\n      }\n    });\n  } // Takes both a request and its response and adds it to the given cache.\n\n\n  put(req, response, opts) {\n    opts = opts || {};\n    const size = response.headers.get('content-length');\n    const fitInMemory = !!size && opts.memoize !== false && size < MAX_MEM_SIZE;\n    const ckey = cacheKey(req);\n    const cacheOpts = {\n      algorithms: opts.algorithms,\n      metadata: {\n        url: req.url,\n        reqHeaders: { ...req.headers.raw(),\n          ...pruneHeaders\n        },\n        resHeaders: { ...response.headers.raw(),\n          ...pruneHeaders\n        }\n      },\n      size,\n      memoize: fitInMemory && opts.memoize\n    };\n\n    if (req.method === 'HEAD' || response.status === 304) {\n      // Update metadata without writing\n      return cacache.get.info(this._path, ckey).then(info => {\n        // Providing these will bypass content write\n        cacheOpts.integrity = info.integrity;\n        addCacheHeaders(response.headers, this._path, ckey, info.integrity, info.time);\n        return new MinipassPipeline(cacache.get.stream.byDigest(this._path, info.integrity, cacheOpts), cacache.put.stream(this._path, ckey, cacheOpts)).promise().then(() => {\n          return response;\n        });\n      });\n    }\n\n    const oldBody = response.body; // the flush is the last thing in the pipeline.  Build the pipeline\n    // back-to-front so we don't consume the data before we use it!\n    // We unshift in either a tee-stream to the cache put stream,\n    // or a collecter that dumps it to cache in one go, then the\n    // old body to bring in the data.\n\n    const newBody = new MinipassPipeline(new MinipassFlush({\n      flush() {\n        return cacheWritePromise;\n      }\n\n    }));\n    let cacheWriteResolve, cacheWriteReject;\n    const cacheWritePromise = new Promise((resolve, reject) => {\n      cacheWriteResolve = resolve;\n      cacheWriteReject = reject;\n    });\n    const cachePath = this._path;\n\n    if (fitInMemory) {\n      const collecter = new MinipassCollect.PassThrough();\n      collecter.on('collect', data => {\n        cacache.put(cachePath, ckey, data, cacheOpts).then(cacheWriteResolve, cacheWriteReject);\n      });\n      newBody.unshift(collecter);\n    } else {\n      const tee = new Minipass();\n      const cacheStream = cacache.put.stream(cachePath, ckey, cacheOpts);\n      tee.pipe(cacheStream);\n      cacheStream.promise().then(cacheWriteResolve, cacheWriteReject);\n      newBody.unshift(tee);\n    }\n\n    newBody.unshift(oldBody);\n    return Promise.resolve(new fetch.Response(newBody, response));\n  } // Finds the Cache entry whose key is the request, and if found, deletes the\n  // Cache entry and returns a Promise that resolves to true. If no Cache entry\n  // is found, it returns false.\n\n\n  'delete'(req, opts) {\n    opts = opts || {};\n\n    if (typeof opts.memoize === 'object') {\n      if (opts.memoize.reset) opts.memoize.reset();else if (opts.memoize.clear) opts.memoize.clear();else {\n        Object.keys(opts.memoize).forEach(k => {\n          opts.memoize[k] = null;\n        });\n      }\n    }\n\n    return cacache.rm.entry(this._path, cacheKey(req) // TODO - true/false\n    ).then(() => false);\n  }\n\n};\n\nfunction matchDetails(req, cached) {\n  const reqUrl = new url.URL(req.url);\n  const cacheUrl = new url.URL(cached.url);\n  const vary = cached.resHeaders.get('Vary'); // https://tools.ietf.org/html/rfc7234#section-4.1\n\n  if (vary) {\n    if (vary.match(/\\*/)) return false;else {\n      const fieldsMatch = vary.split(/\\s*,\\s*/).every(field => {\n        return cached.reqHeaders.get(field) === req.headers.get(field);\n      });\n      if (!fieldsMatch) return false;\n    }\n  }\n\n  if (cached.integrity) return ssri.parse(cached.integrity).match(cached.cacheIntegrity);\n  reqUrl.hash = null;\n  cacheUrl.hash = null;\n  return url.format(reqUrl) === url.format(cacheUrl);\n}\n\nfunction addCacheHeaders(resHeaders, path, key, hash, time) {\n  resHeaders.set('X-Local-Cache', encodeURIComponent(path));\n  resHeaders.set('X-Local-Cache-Key', encodeURIComponent(key));\n  resHeaders.set('X-Local-Cache-Hash', encodeURIComponent(hash));\n  resHeaders.set('X-Local-Cache-Time', new Date(time).toUTCString());\n}","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/node_modules/make-fetch-happen/cache.js"],"names":["fetch","require","cacache","ssri","url","Minipass","MinipassFlush","MinipassCollect","MinipassPipeline","MAX_MEM_SIZE","pruneHeaders","authorization","undefined","cacheKey","req","parsed","URL","format","protocol","slashes","port","hostname","pathname","search","module","exports","Cache","constructor","path","opts","_path","Promise","match","key","get","info","then","hasContent","integrity","exists","metadata","matchDetails","reqHeaders","Headers","resHeaders","cacheIntegrity","addCacheHeaders","time","method","Response","headers","status","cachePath","body","fitInMemory","size","removeOnResume","removeListener","onResume","memoize","c","stream","byDigest","on","err","emit","pipe","data","end","catch","once","resolve","put","response","ckey","cacheOpts","algorithms","raw","promise","oldBody","newBody","flush","cacheWritePromise","cacheWriteResolve","cacheWriteReject","reject","collecter","PassThrough","unshift","tee","cacheStream","reset","clear","Object","keys","forEach","k","rm","entry","cached","reqUrl","cacheUrl","vary","fieldsMatch","split","every","field","parse","hash","set","encodeURIComponent","Date","toUTCString"],"mappings":"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","sourcesContent":["'use strict'\n\nconst fetch = require('minipass-fetch')\nconst cacache = require('cacache')\nconst ssri = require('ssri')\nconst url = require('url')\n\nconst Minipass = require('minipass')\nconst MinipassFlush = require('minipass-flush')\nconst MinipassCollect = require('minipass-collect')\nconst MinipassPipeline = require('minipass-pipeline')\n\nconst MAX_MEM_SIZE = 5 * 1024 * 1024 // 5MB\n\n// some headers should never be stored in the cache, either because\n// they're a security footgun to leave lying around, or because we\n// just don't need them taking up space.\n// set to undefined so they're omitted from the JSON.stringify\nconst pruneHeaders = {\n  authorization: undefined,\n  'npm-session': undefined,\n  'set-cookie': undefined,\n  'cf-ray': undefined,\n  'cf-cache-status': undefined,\n  'cf-request-id': undefined,\n  'x-fetch-attempts': undefined,\n}\n\nfunction cacheKey (req) {\n  const parsed = new url.URL(req.url)\n  return `make-fetch-happen:request-cache:${\n    url.format({\n      protocol: parsed.protocol,\n      slashes: true,\n      port: parsed.port,\n      hostname: parsed.hostname,\n      pathname: parsed.pathname,\n      search: parsed.search,\n    })\n  }`\n}\n\n// This is a cacache-based implementation of the Cache standard,\n// using node-fetch.\n// docs: https://developer.mozilla.org/en-US/docs/Web/API/Cache\n//\nmodule.exports = class Cache {\n  constructor (path, opts) {\n    this._path = path\n    this.Promise = (opts && opts.Promise) || Promise\n  }\n\n  static get pruneHeaders () {\n    // exposed for testing, not modifiable\n    return { ...pruneHeaders }\n  }\n\n  // Returns a Promise that resolves to the response associated with the first\n  // matching request in the Cache object.\n  match (req, opts) {\n    const key = cacheKey(req)\n    return cacache.get.info(this._path, key).then(info => {\n      return info && cacache.get.hasContent(\n        this._path, info.integrity, opts\n      ).then(exists => exists && info)\n    }).then(info => {\n      if (info && info.metadata && matchDetails(req, {\n        url: info.metadata.url,\n        reqHeaders: new fetch.Headers(info.metadata.reqHeaders),\n        resHeaders: new fetch.Headers(info.metadata.resHeaders),\n        cacheIntegrity: info.integrity,\n        integrity: opts && opts.integrity,\n      })) {\n        const resHeaders = new fetch.Headers(info.metadata.resHeaders)\n        addCacheHeaders(resHeaders, this._path, key, info.integrity, info.time)\n        if (req.method === 'HEAD') {\n          return new fetch.Response(null, {\n            url: req.url,\n            headers: resHeaders,\n            status: 200,\n          })\n        }\n        const cachePath = this._path\n        // avoid opening cache file handles until a user actually tries to\n        // read from it.\n        const body = new Minipass()\n        const fitInMemory = info.size < MAX_MEM_SIZE\n        const removeOnResume = () => body.removeListener('resume', onResume)\n        const onResume =\n          opts.memoize !== false && fitInMemory\n            ? () => {\n              const c = cacache.get.stream.byDigest(cachePath, info.integrity, {\n                memoize: opts.memoize,\n              })\n              c.on('error', /* istanbul ignore next */ err => {\n                body.emit('error', err)\n              })\n              c.pipe(body)\n            }\n            : () => {\n              removeOnResume()\n              cacache.get.byDigest(cachePath, info.integrity, {\n                memoize: opts.memoize,\n              })\n                .then(data => body.end(data))\n                .catch(/* istanbul ignore next */ err => {\n                  body.emit('error', err)\n                })\n            }\n        body.once('resume', onResume)\n        body.once('end', () => removeOnResume)\n        return this.Promise.resolve(new fetch.Response(body, {\n          url: req.url,\n          headers: resHeaders,\n          status: 200,\n          size: info.size,\n        }))\n      }\n    })\n  }\n\n  // Takes both a request and its response and adds it to the given cache.\n  put (req, response, opts) {\n    opts = opts || {}\n    const size = response.headers.get('content-length')\n    const fitInMemory = !!size && opts.memoize !== false && size < MAX_MEM_SIZE\n    const ckey = cacheKey(req)\n    const cacheOpts = {\n      algorithms: opts.algorithms,\n      metadata: {\n        url: req.url,\n        reqHeaders: {\n          ...req.headers.raw(),\n          ...pruneHeaders,\n        },\n        resHeaders: {\n          ...response.headers.raw(),\n          ...pruneHeaders,\n        },\n      },\n      size,\n      memoize: fitInMemory && opts.memoize,\n    }\n    if (req.method === 'HEAD' || response.status === 304) {\n      // Update metadata without writing\n      return cacache.get.info(this._path, ckey).then(info => {\n        // Providing these will bypass content write\n        cacheOpts.integrity = info.integrity\n        addCacheHeaders(\n          response.headers, this._path, ckey, info.integrity, info.time\n        )\n\n        return new MinipassPipeline(\n          cacache.get.stream.byDigest(this._path, info.integrity, cacheOpts),\n          cacache.put.stream(this._path, ckey, cacheOpts)\n        ).promise().then(() => {\n          return response\n        })\n      })\n    }\n    const oldBody = response.body\n    // the flush is the last thing in the pipeline.  Build the pipeline\n    // back-to-front so we don't consume the data before we use it!\n    // We unshift in either a tee-stream to the cache put stream,\n    // or a collecter that dumps it to cache in one go, then the\n    // old body to bring in the data.\n    const newBody = new MinipassPipeline(new MinipassFlush({\n      flush () {\n        return cacheWritePromise\n      },\n    }))\n\n    let cacheWriteResolve, cacheWriteReject\n    const cacheWritePromise = new Promise((resolve, reject) => {\n      cacheWriteResolve = resolve\n      cacheWriteReject = reject\n    })\n    const cachePath = this._path\n\n    if (fitInMemory) {\n      const collecter = new MinipassCollect.PassThrough()\n      collecter.on('collect', data => {\n        cacache.put(\n          cachePath,\n          ckey,\n          data,\n          cacheOpts\n        ).then(cacheWriteResolve, cacheWriteReject)\n      })\n      newBody.unshift(collecter)\n    } else {\n      const tee = new Minipass()\n      const cacheStream = cacache.put.stream(\n        cachePath,\n        ckey,\n        cacheOpts\n      )\n      tee.pipe(cacheStream)\n      cacheStream.promise().then(cacheWriteResolve, cacheWriteReject)\n      newBody.unshift(tee)\n    }\n\n    newBody.unshift(oldBody)\n    return Promise.resolve(new fetch.Response(newBody, response))\n  }\n\n  // Finds the Cache entry whose key is the request, and if found, deletes the\n  // Cache entry and returns a Promise that resolves to true. If no Cache entry\n  // is found, it returns false.\n  'delete' (req, opts) {\n    opts = opts || {}\n    if (typeof opts.memoize === 'object') {\n      if (opts.memoize.reset)\n        opts.memoize.reset()\n      else if (opts.memoize.clear)\n        opts.memoize.clear()\n      else {\n        Object.keys(opts.memoize).forEach(k => {\n          opts.memoize[k] = null\n        })\n      }\n    }\n    return cacache.rm.entry(\n      this._path,\n      cacheKey(req)\n    // TODO - true/false\n    ).then(() => false)\n  }\n}\n\nfunction matchDetails (req, cached) {\n  const reqUrl = new url.URL(req.url)\n  const cacheUrl = new url.URL(cached.url)\n  const vary = cached.resHeaders.get('Vary')\n  // https://tools.ietf.org/html/rfc7234#section-4.1\n  if (vary) {\n    if (vary.match(/\\*/))\n      return false\n    else {\n      const fieldsMatch = vary.split(/\\s*,\\s*/).every(field => {\n        return cached.reqHeaders.get(field) === req.headers.get(field)\n      })\n      if (!fieldsMatch)\n        return false\n    }\n  }\n  if (cached.integrity)\n    return ssri.parse(cached.integrity).match(cached.cacheIntegrity)\n\n  reqUrl.hash = null\n  cacheUrl.hash = null\n  return url.format(reqUrl) === url.format(cacheUrl)\n}\n\nfunction addCacheHeaders (resHeaders, path, key, hash, time) {\n  resHeaders.set('X-Local-Cache', encodeURIComponent(path))\n  resHeaders.set('X-Local-Cache-Key', encodeURIComponent(key))\n  resHeaders.set('X-Local-Cache-Hash', encodeURIComponent(hash))\n  resHeaders.set('X-Local-Cache-Time', new Date(time).toUTCString())\n}\n"]},"metadata":{},"sourceType":"script"}
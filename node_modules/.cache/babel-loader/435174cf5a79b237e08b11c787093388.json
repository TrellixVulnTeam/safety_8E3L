{"ast":null,"code":"// class that describes a config key we know about\n// this keeps us from defining a config key and not\n// providing a default, description, etc.\n//\n// TODO: some kind of categorization system, so we can\n// say \"these are for registry access\", \"these are for\n// version resolution\" etc.\nconst required = ['type', 'description', 'default', 'key'];\nconst allowed = ['default', 'defaultDescription', 'deprecated', 'description', 'flatten', 'hint', 'key', 'short', 'type', 'typeDescription', 'usage', 'envExport'];\n\nconst {\n  typeDefs: {\n    semver: {\n      type: semver\n    },\n    Umask: {\n      type: Umask\n    },\n    url: {\n      type: url\n    },\n    path: {\n      type: path\n    }\n  }\n} = require('@npmcli/config');\n\nclass Definition {\n  constructor(key, def) {\n    this.key = key; // if it's set falsey, don't export it, otherwise we do by default\n\n    this.envExport = true;\n    Object.assign(this, def);\n    this.validate();\n    if (!this.defaultDescription) this.defaultDescription = describeValue(this.default);\n    if (!this.typeDescription) this.typeDescription = describeType(this.type); // hint is only used for non-boolean values\n\n    if (!this.hint) this.hint = `<${this.key}>`;\n    if (!this.usage) this.usage = describeUsage(this);\n  }\n\n  validate() {\n    for (const req of required) {\n      if (!Object.prototype.hasOwnProperty.call(this, req)) throw new Error(`config lacks ${req}: ${this.key}`);\n    }\n\n    if (!this.key) throw new Error(`config lacks key: ${this.key}`);\n\n    for (const field of Object.keys(this)) {\n      if (!allowed.includes(field)) throw new Error(`config defines unknown field ${field}: ${this.key}`);\n    }\n  } // a textual description of this config, suitable for help output\n\n\n  describe() {\n    const description = unindent(this.description);\n    const noEnvExport = this.envExport ? '' : `\nThis value is not exported to the environment for child processes.\n`;\n    const deprecated = !this.deprecated ? '' : `* DEPRECATED: ${unindent(this.deprecated)}\\n`;\n    return wrapAll(`#### \\`${this.key}\\`\n\n* Default: ${unindent(this.defaultDescription)}\n* Type: ${unindent(this.typeDescription)}\n${deprecated}\n${description}\n${noEnvExport}`);\n  }\n\n}\n\nconst describeUsage = def => {\n  let key = `--${def.key}`;\n  if (def.short && typeof def.short === 'string') key = `-${def.short}|${key}`; // Single type\n\n  if (!Array.isArray(def.type)) return `${key}${def.type === Boolean ? '' : ' ' + def.hint}`; // Multiple types\n\n  let types = def.type;\n  const multiple = types.includes(Array);\n  const bool = types.includes(Boolean); // null type means optional and doesn't currently affect usage output since\n  // all non-optional params have defaults so we render everything as optional\n\n  types = types.filter(t => t !== null && t !== Array && t !== Boolean);\n  if (!types.length) return key;\n  let description;\n  if (!types.some(t => typeof t !== 'string')) // Specific values, use specifics given\n    description = `<${types.filter(d => d).join('|')}>`;else {\n    // Generic values, use hint\n    description = def.hint;\n  }\n  if (bool) key = `${key}|${key}`;\n  const usage = `${key} ${description}`;\n  if (multiple) return `${usage} [${usage} ...]`;else return usage;\n};\n\nconst describeType = type => {\n  if (Array.isArray(type)) {\n    const descriptions = type.filter(t => t !== Array).map(t => describeType(t)); // [a] => \"a\"\n    // [a, b] => \"a or b\"\n    // [a, b, c] => \"a, b, or c\"\n    // [a, Array] => \"a (can be set multiple times)\"\n    // [a, Array, b] => \"a or b (can be set multiple times)\"\n\n    const last = descriptions.length > 1 ? [descriptions.pop()] : [];\n    const oxford = descriptions.length > 1 ? ', or ' : ' or ';\n    const words = [descriptions.join(', ')].concat(last).join(oxford);\n    const multiple = type.includes(Array) ? ' (can be set multiple times)' : '';\n    return `${words}${multiple}`;\n  } // Note: these are not quite the same as the description printed\n  // when validation fails.  In that case, we want to give the user\n  // a bit more information to help them figure out what's wrong.\n\n\n  switch (type) {\n    case String:\n      return 'String';\n\n    case Number:\n      return 'Number';\n\n    case Umask:\n      return 'Octal numeric string in range 0000..0777 (0..511)';\n\n    case Boolean:\n      return 'Boolean';\n\n    case Date:\n      return 'Date';\n\n    case path:\n      return 'Path';\n\n    case semver:\n      return 'SemVer string';\n\n    case url:\n      return 'URL';\n\n    default:\n      return describeValue(type);\n  }\n}; // if it's a string, quote it.  otherwise, just cast to string.\n\n\nconst describeValue = val => typeof val === 'string' ? JSON.stringify(val) : String(val);\n\nconst unindent = s => {\n  // get the first \\n followed by a bunch of spaces, and pluck off\n  // that many spaces from the start of every line.\n  const match = s.match(/\\n +/);\n  return !match ? s.trim() : s.split(match[0]).join('\\n').trim();\n};\n\nconst wrap = s => {\n  const cols = Math.min(Math.max(20, process.stdout.columns) || 80, 80) - 5;\n  return unindent(s).split(/[ \\n]+/).reduce((left, right) => {\n    const last = left.split('\\n').pop();\n    const join = last.length && last.length + right.length > cols ? '\\n' : ' ';\n    return left + join + right;\n  });\n};\n\nconst wrapAll = s => {\n  let inCodeBlock = false;\n  return s.split('\\n\\n').map(block => {\n    if (inCodeBlock || block.startsWith('```')) {\n      inCodeBlock = !block.endsWith('```');\n      return block;\n    }\n\n    if (block.charAt(0) === '*') {\n      return '* ' + block.substr(1).trim().split('\\n* ').map(li => {\n        return wrap(li).replace(/\\n/g, '\\n  ');\n      }).join('\\n* ');\n    } else return wrap(block);\n  }).join('\\n\\n');\n};\n\nmodule.exports = Definition;","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/lib/utils/config/definition.js"],"names":["required","allowed","typeDefs","semver","type","Umask","url","path","require","Definition","constructor","key","def","envExport","Object","assign","validate","defaultDescription","describeValue","default","typeDescription","describeType","hint","usage","describeUsage","req","prototype","hasOwnProperty","call","Error","field","keys","includes","describe","description","unindent","noEnvExport","deprecated","wrapAll","short","Array","isArray","Boolean","types","multiple","bool","filter","t","length","some","d","join","descriptions","map","last","pop","oxford","words","concat","String","Number","Date","val","JSON","stringify","s","match","trim","split","wrap","cols","Math","min","max","process","stdout","columns","reduce","left","right","inCodeBlock","block","startsWith","endsWith","charAt","substr","li","replace","module","exports"],"mappings":"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","sourcesContent":["// class that describes a config key we know about\n// this keeps us from defining a config key and not\n// providing a default, description, etc.\n//\n// TODO: some kind of categorization system, so we can\n// say \"these are for registry access\", \"these are for\n// version resolution\" etc.\n\nconst required = [\n  'type',\n  'description',\n  'default',\n  'key',\n]\n\nconst allowed = [\n  'default',\n  'defaultDescription',\n  'deprecated',\n  'description',\n  'flatten',\n  'hint',\n  'key',\n  'short',\n  'type',\n  'typeDescription',\n  'usage',\n  'envExport',\n]\n\nconst {\n  typeDefs: {\n    semver: { type: semver },\n    Umask: { type: Umask },\n    url: { type: url },\n    path: { type: path },\n  },\n} = require('@npmcli/config')\n\nclass Definition {\n  constructor (key, def) {\n    this.key = key\n    // if it's set falsey, don't export it, otherwise we do by default\n    this.envExport = true\n    Object.assign(this, def)\n    this.validate()\n    if (!this.defaultDescription)\n      this.defaultDescription = describeValue(this.default)\n    if (!this.typeDescription)\n      this.typeDescription = describeType(this.type)\n    // hint is only used for non-boolean values\n    if (!this.hint)\n      this.hint = `<${this.key}>`\n    if (!this.usage)\n      this.usage = describeUsage(this)\n  }\n\n  validate () {\n    for (const req of required) {\n      if (!Object.prototype.hasOwnProperty.call(this, req))\n        throw new Error(`config lacks ${req}: ${this.key}`)\n    }\n    if (!this.key)\n      throw new Error(`config lacks key: ${this.key}`)\n    for (const field of Object.keys(this)) {\n      if (!allowed.includes(field))\n        throw new Error(`config defines unknown field ${field}: ${this.key}`)\n    }\n  }\n\n  // a textual description of this config, suitable for help output\n  describe () {\n    const description = unindent(this.description)\n    const noEnvExport = this.envExport ? '' : `\nThis value is not exported to the environment for child processes.\n`\n    const deprecated = !this.deprecated ? ''\n      : `* DEPRECATED: ${unindent(this.deprecated)}\\n`\n    return wrapAll(`#### \\`${this.key}\\`\n\n* Default: ${unindent(this.defaultDescription)}\n* Type: ${unindent(this.typeDescription)}\n${deprecated}\n${description}\n${noEnvExport}`)\n  }\n}\n\nconst describeUsage = (def) => {\n  let key = `--${def.key}`\n  if (def.short && typeof def.short === 'string')\n    key = `-${def.short}|${key}`\n\n  // Single type\n  if (!Array.isArray(def.type))\n    return `${key}${def.type === Boolean ? '' : ' ' + def.hint}`\n\n  // Multiple types\n  let types = def.type\n  const multiple = types.includes(Array)\n  const bool = types.includes(Boolean)\n\n  // null type means optional and doesn't currently affect usage output since\n  // all non-optional params have defaults so we render everything as optional\n  types = types.filter(t => t !== null && t !== Array && t !== Boolean)\n\n  if (!types.length)\n    return key\n\n  let description\n  if (!types.some(t => typeof t !== 'string'))\n    // Specific values, use specifics given\n    description = `<${types.filter(d => d).join('|')}>`\n  else {\n    // Generic values, use hint\n    description = def.hint\n  }\n\n  if (bool)\n    key = `${key}|${key}`\n\n  const usage = `${key} ${description}`\n  if (multiple)\n    return `${usage} [${usage} ...]`\n  else\n    return usage\n}\n\nconst describeType = type => {\n  if (Array.isArray(type)) {\n    const descriptions = type\n      .filter(t => t !== Array)\n      .map(t => describeType(t))\n\n    // [a] => \"a\"\n    // [a, b] => \"a or b\"\n    // [a, b, c] => \"a, b, or c\"\n    // [a, Array] => \"a (can be set multiple times)\"\n    // [a, Array, b] => \"a or b (can be set multiple times)\"\n    const last = descriptions.length > 1 ? [descriptions.pop()] : []\n    const oxford = descriptions.length > 1 ? ', or ' : ' or '\n    const words = [descriptions.join(', ')].concat(last).join(oxford)\n    const multiple = type.includes(Array) ? ' (can be set multiple times)'\n      : ''\n    return `${words}${multiple}`\n  }\n\n  // Note: these are not quite the same as the description printed\n  // when validation fails.  In that case, we want to give the user\n  // a bit more information to help them figure out what's wrong.\n  switch (type) {\n    case String:\n      return 'String'\n    case Number:\n      return 'Number'\n    case Umask:\n      return 'Octal numeric string in range 0000..0777 (0..511)'\n    case Boolean:\n      return 'Boolean'\n    case Date:\n      return 'Date'\n    case path:\n      return 'Path'\n    case semver:\n      return 'SemVer string'\n    case url:\n      return 'URL'\n    default:\n      return describeValue(type)\n  }\n}\n\n// if it's a string, quote it.  otherwise, just cast to string.\nconst describeValue = val =>\n  typeof val === 'string' ? JSON.stringify(val) : String(val)\n\nconst unindent = s => {\n  // get the first \\n followed by a bunch of spaces, and pluck off\n  // that many spaces from the start of every line.\n  const match = s.match(/\\n +/)\n  return !match ? s.trim() : s.split(match[0]).join('\\n').trim()\n}\n\nconst wrap = (s) => {\n  const cols = Math.min(Math.max(20, process.stdout.columns) || 80, 80) - 5\n  return unindent(s).split(/[ \\n]+/).reduce((left, right) => {\n    const last = left.split('\\n').pop()\n    const join = last.length && last.length + right.length > cols ? '\\n' : ' '\n    return left + join + right\n  })\n}\n\nconst wrapAll = s => {\n  let inCodeBlock = false\n  return s.split('\\n\\n').map(block => {\n    if (inCodeBlock || block.startsWith('```')) {\n      inCodeBlock = !block.endsWith('```')\n      return block\n    }\n\n    if (block.charAt(0) === '*') {\n      return '* ' + block.substr(1).trim().split('\\n* ').map(li => {\n        return wrap(li).replace(/\\n/g, '\\n  ')\n      }).join('\\n* ')\n    } else\n      return wrap(block)\n  }).join('\\n\\n')\n}\n\nmodule.exports = Definition\n"]},"metadata":{},"sourceType":"script"}
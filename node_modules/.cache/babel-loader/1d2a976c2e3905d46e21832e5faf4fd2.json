{"ast":null,"code":"'use strict';\n\nconst url = require('url');\n\nconst fetch = require('minipass-fetch');\n\nconst pkg = require('./package.json');\n\nconst retry = require('promise-retry');\n\nlet ssri;\n\nconst Minipass = require('minipass');\n\nconst MinipassPipeline = require('minipass-pipeline');\n\nconst getAgent = require('./agent');\n\nconst setWarning = require('./warning');\n\nconst configureOptions = require('./utils/configure-options');\n\nconst iterableToObject = require('./utils/iterable-to-object');\n\nconst makePolicy = require('./utils/make-policy');\n\nconst isURL = /^https?:/;\nconst USER_AGENT = `${pkg.name}/${pkg.version} (+https://npm.im/${pkg.name})`;\nconst RETRY_ERRORS = ['ECONNRESET', // remote socket closed on us\n'ECONNREFUSED', // remote host refused to open connection\n'EADDRINUSE', // failed to bind to a local port (proxy?)\n'ETIMEDOUT' // someone in the transaction is WAY TOO SLOW\n// Known codes we do NOT retry on:\n// ENOTFOUND (getaddrinfo failure. Either bad hostname, or offline)\n];\nconst RETRY_TYPES = ['request-timeout']; // https://fetch.spec.whatwg.org/#http-network-or-cache-fetch\n\nmodule.exports = cachingFetch;\n\ncachingFetch.defaults = function (_uri, _opts) {\n  const fetch = this;\n\n  if (typeof _uri === 'object') {\n    _opts = _uri;\n    _uri = null;\n  }\n\n  function defaultedFetch(uri, opts) {\n    const finalOpts = Object.assign({}, _opts || {}, opts || {});\n    return fetch(uri || _uri, finalOpts);\n  }\n\n  defaultedFetch.defaults = fetch.defaults;\n  defaultedFetch.delete = fetch.delete;\n  return defaultedFetch;\n};\n\ncachingFetch.delete = cacheDelete;\n\nfunction cacheDelete(uri, opts) {\n  opts = configureOptions(opts);\n\n  if (opts.cacheManager) {\n    const req = new fetch.Request(uri, {\n      method: opts.method,\n      headers: opts.headers\n    });\n    return opts.cacheManager.delete(req, opts);\n  }\n}\n\nfunction initializeSsri() {\n  if (!ssri) ssri = require('ssri');\n}\n\nfunction cachingFetch(uri, _opts) {\n  const opts = configureOptions(_opts);\n\n  if (opts.integrity) {\n    initializeSsri(); // if verifying integrity, fetch must not decompress\n\n    opts.compress = false;\n  }\n\n  const isCachable = (opts.method === 'GET' || opts.method === 'HEAD') && Boolean(opts.cacheManager) && opts.cache !== 'no-store' && opts.cache !== 'reload';\n\n  if (isCachable) {\n    const req = new fetch.Request(uri, {\n      method: opts.method,\n      headers: opts.headers\n    });\n    return opts.cacheManager.match(req, opts).then(res => {\n      if (res) {\n        const warningCode = (res.headers.get('Warning') || '').match(/^\\d+/);\n\n        if (warningCode && +warningCode >= 100 && +warningCode < 200) {\n          // https://tools.ietf.org/html/rfc7234#section-4.3.4\n          //\n          // If a stored response is selected for update, the cache MUST:\n          //\n          // * delete any Warning header fields in the stored response with\n          //   warn-code 1xx (see Section 5.5);\n          //\n          // * retain any Warning header fields in the stored response with\n          //   warn-code 2xx;\n          //\n          res.headers.delete('Warning');\n        }\n\n        if (opts.cache === 'default' && !isStale(req, res)) return res;\n        if (opts.cache === 'default' || opts.cache === 'no-cache') return conditionalFetch(req, res, opts);\n\n        if (opts.cache === 'force-cache' || opts.cache === 'only-if-cached') {\n          //   112 Disconnected operation\n          // SHOULD be included if the cache is intentionally disconnected from\n          // the rest of the network for a period of time.\n          // (https://tools.ietf.org/html/rfc2616#section-14.46)\n          setWarning(res, 112, 'Disconnected operation');\n          return res;\n        }\n      }\n\n      if (!res && opts.cache === 'only-if-cached') {\n        const errorMsg = `request to ${uri} failed: cache mode is 'only-if-cached' but no cached response available.`;\n        const err = new Error(errorMsg);\n        err.code = 'ENOTCACHED';\n        throw err;\n      } // Missing cache entry, or mode is default (if stale), reload, no-store\n\n\n      return remoteFetch(req.url, opts);\n    });\n  }\n\n  return remoteFetch(uri, opts);\n} // https://tools.ietf.org/html/rfc7234#section-4.2\n\n\nfunction isStale(req, res) {\n  const _req = {\n    url: req.url,\n    method: req.method,\n    headers: iterableToObject(req.headers)\n  };\n  const policy = makePolicy(req, res);\n  const responseTime = res.headers.get('x-local-cache-time') ||\n  /* istanbul ignore next - would be weird to get a 'stale'\n   * response that didn't come from cache with a cache time header */\n  res.headers.get('date') || 0;\n  policy._responseTime = new Date(responseTime);\n  const bool = !policy.satisfiesWithoutRevalidation(_req);\n  const headers = policy.responseHeaders();\n\n  if (headers.warning && /^113\\b/.test(headers.warning)) {\n    // Possible to pick up a rfc7234 warning at this point.\n    // This is kind of a weird place to stick this, should probably go\n    // in cachingFetch.  But by putting it here, we save an extra\n    // CachePolicy object construction.\n    res.headers.append('warning', headers.warning);\n  }\n\n  return bool;\n}\n\nfunction mustRevalidate(res) {\n  return (res.headers.get('cache-control') || '').match(/must-revalidate/i);\n}\n\nfunction conditionalFetch(req, cachedRes, opts) {\n  const _req = {\n    url: req.url,\n    method: req.method,\n    headers: Object.assign({}, opts.headers || {})\n  };\n  const policy = makePolicy(req, cachedRes);\n  opts.headers = policy.revalidationHeaders(_req);\n  return remoteFetch(req.url, opts).then(condRes => {\n    const revalidatedPolicy = policy.revalidatedPolicy(_req, {\n      status: condRes.status,\n      headers: iterableToObject(condRes.headers)\n    });\n\n    if (condRes.status >= 500 && !mustRevalidate(cachedRes)) {\n      //   111 Revalidation failed\n      // MUST be included if a cache returns a stale response because an\n      // attempt to revalidate the response failed, due to an inability to\n      // reach the server.\n      // (https://tools.ietf.org/html/rfc2616#section-14.46)\n      setWarning(cachedRes, 111, 'Revalidation failed');\n      return cachedRes;\n    }\n\n    if (condRes.status === 304) {\n      // 304 Not Modified\n      // Create a synthetic response from the cached body and original req\n      const synthRes = new fetch.Response(cachedRes.body, condRes);\n      return opts.cacheManager.put(req, synthRes, opts).then(newRes => {\n        // Get the list first, because if we delete while iterating,\n        // it'll throw off the count and not make it through all\n        // of them.\n        const newHeaders = revalidatedPolicy.policy.responseHeaders();\n        const toDelete = [...newRes.headers.keys()].filter(k => !newHeaders[k]);\n\n        for (const key of toDelete) newRes.headers.delete(key);\n\n        for (const [key, val] of Object.entries(newHeaders)) newRes.headers.set(key, val);\n\n        return newRes;\n      });\n    }\n\n    return condRes;\n  }).then(res => res).catch(err => {\n    if (mustRevalidate(cachedRes)) throw err;else {\n      //   111 Revalidation failed\n      // MUST be included if a cache returns a stale response because an\n      // attempt to revalidate the response failed, due to an inability to\n      // reach the server.\n      // (https://tools.ietf.org/html/rfc2616#section-14.46)\n      setWarning(cachedRes, 111, 'Revalidation failed'); //   199 Miscellaneous warning\n      // The warning text MAY include arbitrary information to be presented to\n      // a human user, or logged. A system receiving this warning MUST NOT take\n      // any automated action, besides presenting the warning to the user.\n      // (https://tools.ietf.org/html/rfc2616#section-14.46)\n\n      setWarning(cachedRes, 199, `Miscellaneous Warning ${err.code}: ${err.message}`);\n      return cachedRes;\n    }\n  });\n}\n\nfunction remoteFetchHandleIntegrity(res, integrity) {\n  if (res.status !== 200) return res; // Error responses aren't subject to integrity checks.\n\n  const oldBod = res.body;\n  const newBod = ssri.integrityStream({\n    integrity\n  });\n  return new fetch.Response(new MinipassPipeline(oldBod, newBod), res);\n}\n\nfunction remoteFetch(uri, opts) {\n  const agent = getAgent(uri, opts);\n  const headers = opts.headers instanceof fetch.Headers ? opts.headers : new fetch.Headers(opts.headers);\n  if (!headers.get('connection')) headers.set('connection', agent ? 'keep-alive' : 'close');\n  if (!headers.get('user-agent')) headers.set('user-agent', USER_AGENT);\n  const reqOpts = {\n    agent,\n    body: opts.body,\n    compress: opts.compress,\n    follow: opts.follow,\n    headers,\n    method: opts.method,\n    redirect: 'manual',\n    size: opts.size,\n    counter: opts.counter,\n    timeout: opts.timeout,\n    ca: opts.ca,\n    cert: opts.cert,\n    key: opts.key,\n    rejectUnauthorized: opts.strictSSL\n  };\n  return retry((retryHandler, attemptNum) => {\n    const req = new fetch.Request(uri, reqOpts);\n    return fetch(req).then(res => {\n      if (opts.integrity) res = remoteFetchHandleIntegrity(res, opts.integrity);\n      res.headers.set('x-fetch-attempts', attemptNum);\n      const isStream = Minipass.isStream(req.body);\n\n      if (opts.cacheManager) {\n        const isMethodGetHead = req.method === 'GET' || req.method === 'HEAD';\n        const isCachable = opts.cache !== 'no-store' && isMethodGetHead && makePolicy(req, res).storable() && res.status === 200 // No other statuses should be stored!\n        ;\n        if (isCachable) return opts.cacheManager.put(req, res, opts);\n\n        if (!isMethodGetHead) {\n          return opts.cacheManager.delete(req).then(() => {\n            if (res.status >= 500 && req.method !== 'POST' && !isStream) {\n              if (typeof opts.onRetry === 'function') opts.onRetry(res);\n              return retryHandler(res);\n            }\n\n            return res;\n          });\n        }\n      }\n\n      const isRetriable = req.method !== 'POST' && !isStream && (res.status === 408 || // Request Timeout\n      res.status === 420 || // Enhance Your Calm (usually Twitter rate-limit)\n      res.status === 429 || // Too Many Requests (\"standard\" rate-limiting)\n      res.status >= 500 // Assume server errors are momentary hiccups\n      );\n\n      if (isRetriable) {\n        if (typeof opts.onRetry === 'function') opts.onRetry(res);\n        return retryHandler(res);\n      }\n\n      if (!fetch.isRedirect(res.status)) return res;\n      if (opts.redirect === 'manual') return res; // if (!fetch.isRedirect(res.status) || opts.redirect === 'manual') {\n      //   return res\n      // }\n      // handle redirects - matches behavior of fetch: https://github.com/bitinn/node-fetch\n\n      if (opts.redirect === 'error') {\n        const err = new fetch.FetchError(`redirect mode is set to error: ${uri}`, 'no-redirect', {\n          code: 'ENOREDIRECT'\n        });\n        throw err;\n      }\n\n      if (!res.headers.get('location')) {\n        const err = new fetch.FetchError(`redirect location header missing at: ${uri}`, 'no-location', {\n          code: 'EINVALIDREDIRECT'\n        });\n        throw err;\n      }\n\n      if (req.counter >= req.follow) {\n        const err = new fetch.FetchError(`maximum redirect reached at: ${uri}`, 'max-redirect', {\n          code: 'EMAXREDIRECT'\n        });\n        throw err;\n      }\n\n      const resolvedUrlParsed = new url.URL(res.headers.get('location'), req.url);\n      const resolvedUrl = url.format(resolvedUrlParsed);\n      const redirectURL = isURL.test(res.headers.get('location')) ? new url.URL(res.headers.get('location')) : resolvedUrlParsed; // Comment below is used under the following license:\n      // Copyright (c) 2010-2012 Mikeal Rogers\n      // Licensed under the Apache License, Version 2.0 (the \"License\");\n      // you may not use this file except in compliance with the License.\n      // You may obtain a copy of the License at\n      // http://www.apache.org/licenses/LICENSE-2.0\n      // Unless required by applicable law or agreed to in writing,\n      // software distributed under the License is distributed on an \"AS\n      // IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n      // express or implied. See the License for the specific language\n      // governing permissions and limitations under the License.\n      // Remove authorization if changing hostnames (but not if just\n      // changing ports or protocols).  This matches the behavior of request:\n      // https://github.com/request/request/blob/b12a6245/lib/redirect.js#L134-L138\n\n      if (new url.URL(req.url).hostname !== redirectURL.hostname) req.headers.delete('authorization'); // for POST request with 301/302 response, or any request with 303 response,\n      // use GET when following redirect\n\n      if (res.status === 303 || req.method === 'POST' && (res.status === 301 || res.status === 302)) {\n        opts.method = 'GET';\n        opts.body = null;\n        req.headers.delete('content-length');\n      }\n\n      opts.headers = {};\n      req.headers.forEach((value, name) => {\n        opts.headers[name] = value;\n      });\n      opts.counter = ++req.counter;\n      return cachingFetch(resolvedUrl, opts);\n    }).catch(err => {\n      const code = err.code === 'EPROMISERETRY' ? err.retried.code : err.code;\n      const isRetryError = RETRY_ERRORS.indexOf(code) === -1 && RETRY_TYPES.indexOf(err.type) === -1;\n      if (req.method === 'POST' || isRetryError) throw err;\n      if (typeof opts.onRetry === 'function') opts.onRetry(err);\n      return retryHandler(err);\n    });\n  }, opts.retry).catch(err => {\n    if (err.status >= 400 && err.type !== 'system') {\n      // this is an HTTP response \"error\" that we care about\n      return err;\n    }\n\n    throw err;\n  });\n}","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/node_modules/make-fetch-happen/index.js"],"names":["url","require","fetch","pkg","retry","ssri","Minipass","MinipassPipeline","getAgent","setWarning","configureOptions","iterableToObject","makePolicy","isURL","USER_AGENT","name","version","RETRY_ERRORS","RETRY_TYPES","module","exports","cachingFetch","defaults","_uri","_opts","defaultedFetch","uri","opts","finalOpts","Object","assign","delete","cacheDelete","cacheManager","req","Request","method","headers","initializeSsri","integrity","compress","isCachable","Boolean","cache","match","then","res","warningCode","get","isStale","conditionalFetch","errorMsg","err","Error","code","remoteFetch","_req","policy","responseTime","_responseTime","Date","bool","satisfiesWithoutRevalidation","responseHeaders","warning","test","append","mustRevalidate","cachedRes","revalidationHeaders","condRes","revalidatedPolicy","status","synthRes","Response","body","put","newRes","newHeaders","toDelete","keys","filter","k","key","val","entries","set","catch","message","remoteFetchHandleIntegrity","oldBod","newBod","integrityStream","agent","Headers","reqOpts","follow","redirect","size","counter","timeout","ca","cert","rejectUnauthorized","strictSSL","retryHandler","attemptNum","isStream","isMethodGetHead","storable","onRetry","isRetriable","isRedirect","FetchError","resolvedUrlParsed","URL","resolvedUrl","format","redirectURL","hostname","forEach","value","retried","isRetryError","indexOf","type"],"mappings":"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","sourcesContent":["'use strict'\n\nconst url = require('url')\nconst fetch = require('minipass-fetch')\nconst pkg = require('./package.json')\nconst retry = require('promise-retry')\nlet ssri\n\nconst Minipass = require('minipass')\nconst MinipassPipeline = require('minipass-pipeline')\nconst getAgent = require('./agent')\nconst setWarning = require('./warning')\n\nconst configureOptions = require('./utils/configure-options')\nconst iterableToObject = require('./utils/iterable-to-object')\nconst makePolicy = require('./utils/make-policy')\n\nconst isURL = /^https?:/\nconst USER_AGENT = `${pkg.name}/${pkg.version} (+https://npm.im/${pkg.name})`\n\nconst RETRY_ERRORS = [\n  'ECONNRESET', // remote socket closed on us\n  'ECONNREFUSED', // remote host refused to open connection\n  'EADDRINUSE', // failed to bind to a local port (proxy?)\n  'ETIMEDOUT', // someone in the transaction is WAY TOO SLOW\n  // Known codes we do NOT retry on:\n  // ENOTFOUND (getaddrinfo failure. Either bad hostname, or offline)\n]\n\nconst RETRY_TYPES = [\n  'request-timeout',\n]\n\n// https://fetch.spec.whatwg.org/#http-network-or-cache-fetch\nmodule.exports = cachingFetch\ncachingFetch.defaults = function (_uri, _opts) {\n  const fetch = this\n  if (typeof _uri === 'object') {\n    _opts = _uri\n    _uri = null\n  }\n\n  function defaultedFetch (uri, opts) {\n    const finalOpts = Object.assign({}, _opts || {}, opts || {})\n    return fetch(uri || _uri, finalOpts)\n  }\n\n  defaultedFetch.defaults = fetch.defaults\n  defaultedFetch.delete = fetch.delete\n  return defaultedFetch\n}\n\ncachingFetch.delete = cacheDelete\nfunction cacheDelete (uri, opts) {\n  opts = configureOptions(opts)\n  if (opts.cacheManager) {\n    const req = new fetch.Request(uri, {\n      method: opts.method,\n      headers: opts.headers,\n    })\n    return opts.cacheManager.delete(req, opts)\n  }\n}\n\nfunction initializeSsri () {\n  if (!ssri)\n    ssri = require('ssri')\n}\n\nfunction cachingFetch (uri, _opts) {\n  const opts = configureOptions(_opts)\n\n  if (opts.integrity) {\n    initializeSsri()\n    // if verifying integrity, fetch must not decompress\n    opts.compress = false\n  }\n\n  const isCachable = (\n    (\n      opts.method === 'GET' ||\n      opts.method === 'HEAD'\n    ) &&\n      Boolean(opts.cacheManager) &&\n      opts.cache !== 'no-store' &&\n      opts.cache !== 'reload'\n  )\n\n  if (isCachable) {\n    const req = new fetch.Request(uri, {\n      method: opts.method,\n      headers: opts.headers,\n    })\n\n    return opts.cacheManager.match(req, opts).then(res => {\n      if (res) {\n        const warningCode = (res.headers.get('Warning') || '').match(/^\\d+/)\n        if (warningCode && +warningCode >= 100 && +warningCode < 200) {\n          // https://tools.ietf.org/html/rfc7234#section-4.3.4\n          //\n          // If a stored response is selected for update, the cache MUST:\n          //\n          // * delete any Warning header fields in the stored response with\n          //   warn-code 1xx (see Section 5.5);\n          //\n          // * retain any Warning header fields in the stored response with\n          //   warn-code 2xx;\n          //\n          res.headers.delete('Warning')\n        }\n\n        if (opts.cache === 'default' && !isStale(req, res))\n          return res\n\n        if (opts.cache === 'default' || opts.cache === 'no-cache')\n          return conditionalFetch(req, res, opts)\n\n        if (opts.cache === 'force-cache' || opts.cache === 'only-if-cached') {\n          //   112 Disconnected operation\n          // SHOULD be included if the cache is intentionally disconnected from\n          // the rest of the network for a period of time.\n          // (https://tools.ietf.org/html/rfc2616#section-14.46)\n          setWarning(res, 112, 'Disconnected operation')\n          return res\n        }\n      }\n\n      if (!res && opts.cache === 'only-if-cached') {\n        const errorMsg = `request to ${\n          uri\n        } failed: cache mode is 'only-if-cached' but no cached response available.`\n\n        const err = new Error(errorMsg)\n        err.code = 'ENOTCACHED'\n        throw err\n      }\n\n      // Missing cache entry, or mode is default (if stale), reload, no-store\n      return remoteFetch(req.url, opts)\n    })\n  }\n  return remoteFetch(uri, opts)\n}\n\n// https://tools.ietf.org/html/rfc7234#section-4.2\nfunction isStale (req, res) {\n  const _req = {\n    url: req.url,\n    method: req.method,\n    headers: iterableToObject(req.headers),\n  }\n\n  const policy = makePolicy(req, res)\n\n  const responseTime = res.headers.get('x-local-cache-time') ||\n    /* istanbul ignore next - would be weird to get a 'stale'\n     * response that didn't come from cache with a cache time header */\n    (res.headers.get('date') || 0)\n\n  policy._responseTime = new Date(responseTime)\n\n  const bool = !policy.satisfiesWithoutRevalidation(_req)\n  const headers = policy.responseHeaders()\n  if (headers.warning && /^113\\b/.test(headers.warning)) {\n    // Possible to pick up a rfc7234 warning at this point.\n    // This is kind of a weird place to stick this, should probably go\n    // in cachingFetch.  But by putting it here, we save an extra\n    // CachePolicy object construction.\n    res.headers.append('warning', headers.warning)\n  }\n  return bool\n}\n\nfunction mustRevalidate (res) {\n  return (res.headers.get('cache-control') || '').match(/must-revalidate/i)\n}\n\nfunction conditionalFetch (req, cachedRes, opts) {\n  const _req = {\n    url: req.url,\n    method: req.method,\n    headers: Object.assign({}, opts.headers || {}),\n  }\n\n  const policy = makePolicy(req, cachedRes)\n  opts.headers = policy.revalidationHeaders(_req)\n\n  return remoteFetch(req.url, opts)\n    .then(condRes => {\n      const revalidatedPolicy = policy.revalidatedPolicy(_req, {\n        status: condRes.status,\n        headers: iterableToObject(condRes.headers),\n      })\n\n      if (condRes.status >= 500 && !mustRevalidate(cachedRes)) {\n        //   111 Revalidation failed\n        // MUST be included if a cache returns a stale response because an\n        // attempt to revalidate the response failed, due to an inability to\n        // reach the server.\n        // (https://tools.ietf.org/html/rfc2616#section-14.46)\n        setWarning(cachedRes, 111, 'Revalidation failed')\n        return cachedRes\n      }\n\n      if (condRes.status === 304) { // 304 Not Modified\n        // Create a synthetic response from the cached body and original req\n        const synthRes = new fetch.Response(cachedRes.body, condRes)\n        return opts.cacheManager.put(req, synthRes, opts)\n          .then(newRes => {\n            // Get the list first, because if we delete while iterating,\n            // it'll throw off the count and not make it through all\n            // of them.\n            const newHeaders = revalidatedPolicy.policy.responseHeaders()\n            const toDelete = [...newRes.headers.keys()]\n              .filter(k => !newHeaders[k])\n            for (const key of toDelete)\n              newRes.headers.delete(key)\n\n            for (const [key, val] of Object.entries(newHeaders))\n              newRes.headers.set(key, val)\n\n            return newRes\n          })\n      }\n\n      return condRes\n    })\n    .then(res => res)\n    .catch(err => {\n      if (mustRevalidate(cachedRes))\n        throw err\n      else {\n        //   111 Revalidation failed\n        // MUST be included if a cache returns a stale response because an\n        // attempt to revalidate the response failed, due to an inability to\n        // reach the server.\n        // (https://tools.ietf.org/html/rfc2616#section-14.46)\n        setWarning(cachedRes, 111, 'Revalidation failed')\n        //   199 Miscellaneous warning\n        // The warning text MAY include arbitrary information to be presented to\n        // a human user, or logged. A system receiving this warning MUST NOT take\n        // any automated action, besides presenting the warning to the user.\n        // (https://tools.ietf.org/html/rfc2616#section-14.46)\n        setWarning(\n          cachedRes,\n          199,\n          `Miscellaneous Warning ${err.code}: ${err.message}`\n        )\n\n        return cachedRes\n      }\n    })\n}\n\nfunction remoteFetchHandleIntegrity (res, integrity) {\n  if (res.status !== 200)\n    return res // Error responses aren't subject to integrity checks.\n\n  const oldBod = res.body\n  const newBod = ssri.integrityStream({\n    integrity,\n  })\n  return new fetch.Response(new MinipassPipeline(oldBod, newBod), res)\n}\n\nfunction remoteFetch (uri, opts) {\n  const agent = getAgent(uri, opts)\n  const headers = opts.headers instanceof fetch.Headers\n    ? opts.headers\n    : new fetch.Headers(opts.headers)\n  if (!headers.get('connection'))\n    headers.set('connection', agent ? 'keep-alive' : 'close')\n\n  if (!headers.get('user-agent'))\n    headers.set('user-agent', USER_AGENT)\n\n  const reqOpts = {\n    agent,\n    body: opts.body,\n    compress: opts.compress,\n    follow: opts.follow,\n    headers,\n    method: opts.method,\n    redirect: 'manual',\n    size: opts.size,\n    counter: opts.counter,\n    timeout: opts.timeout,\n    ca: opts.ca,\n    cert: opts.cert,\n    key: opts.key,\n    rejectUnauthorized: opts.strictSSL,\n  }\n\n  return retry(\n    (retryHandler, attemptNum) => {\n      const req = new fetch.Request(uri, reqOpts)\n      return fetch(req)\n        .then((res) => {\n          if (opts.integrity)\n            res = remoteFetchHandleIntegrity(res, opts.integrity)\n\n          res.headers.set('x-fetch-attempts', attemptNum)\n\n          const isStream = Minipass.isStream(req.body)\n\n          if (opts.cacheManager) {\n            const isMethodGetHead = (\n              req.method === 'GET' ||\n              req.method === 'HEAD'\n            )\n\n            const isCachable = (\n              opts.cache !== 'no-store' &&\n              isMethodGetHead &&\n              makePolicy(req, res).storable() &&\n              res.status === 200 // No other statuses should be stored!\n            )\n\n            if (isCachable)\n              return opts.cacheManager.put(req, res, opts)\n\n            if (!isMethodGetHead) {\n              return opts.cacheManager.delete(req).then(() => {\n                if (res.status >= 500 && req.method !== 'POST' && !isStream) {\n                  if (typeof opts.onRetry === 'function')\n                    opts.onRetry(res)\n\n                  return retryHandler(res)\n                }\n\n                return res\n              })\n            }\n          }\n\n          const isRetriable = (\n            req.method !== 'POST' &&\n            !isStream &&\n            (\n              res.status === 408 || // Request Timeout\n              res.status === 420 || // Enhance Your Calm (usually Twitter rate-limit)\n              res.status === 429 || // Too Many Requests (\"standard\" rate-limiting)\n              res.status >= 500 // Assume server errors are momentary hiccups\n            )\n          )\n\n          if (isRetriable) {\n            if (typeof opts.onRetry === 'function')\n              opts.onRetry(res)\n\n            return retryHandler(res)\n          }\n\n          if (!fetch.isRedirect(res.status))\n            return res\n\n          if (opts.redirect === 'manual')\n            return res\n\n          // if (!fetch.isRedirect(res.status) || opts.redirect === 'manual') {\n          //   return res\n          // }\n\n          // handle redirects - matches behavior of fetch: https://github.com/bitinn/node-fetch\n          if (opts.redirect === 'error') {\n            const err = new fetch.FetchError(`redirect mode is set to error: ${uri}`, 'no-redirect', { code: 'ENOREDIRECT' })\n            throw err\n          }\n\n          if (!res.headers.get('location')) {\n            const err = new fetch.FetchError(`redirect location header missing at: ${uri}`, 'no-location', { code: 'EINVALIDREDIRECT' })\n            throw err\n          }\n\n          if (req.counter >= req.follow) {\n            const err = new fetch.FetchError(`maximum redirect reached at: ${uri}`, 'max-redirect', { code: 'EMAXREDIRECT' })\n            throw err\n          }\n\n          const resolvedUrlParsed = new url.URL(res.headers.get('location'), req.url)\n          const resolvedUrl = url.format(resolvedUrlParsed)\n          const redirectURL = (isURL.test(res.headers.get('location')))\n            ? new url.URL(res.headers.get('location'))\n            : resolvedUrlParsed\n\n          // Comment below is used under the following license:\n          // Copyright (c) 2010-2012 Mikeal Rogers\n          // Licensed under the Apache License, Version 2.0 (the \"License\");\n          // you may not use this file except in compliance with the License.\n          // You may obtain a copy of the License at\n          // http://www.apache.org/licenses/LICENSE-2.0\n          // Unless required by applicable law or agreed to in writing,\n          // software distributed under the License is distributed on an \"AS\n          // IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n          // express or implied. See the License for the specific language\n          // governing permissions and limitations under the License.\n\n          // Remove authorization if changing hostnames (but not if just\n          // changing ports or protocols).  This matches the behavior of request:\n          // https://github.com/request/request/blob/b12a6245/lib/redirect.js#L134-L138\n          if (new url.URL(req.url).hostname !== redirectURL.hostname)\n            req.headers.delete('authorization')\n\n          // for POST request with 301/302 response, or any request with 303 response,\n          // use GET when following redirect\n          if (\n            res.status === 303 ||\n            (\n              req.method === 'POST' &&\n              (\n                res.status === 301 ||\n                res.status === 302\n              )\n            )\n          ) {\n            opts.method = 'GET'\n            opts.body = null\n            req.headers.delete('content-length')\n          }\n\n          opts.headers = {}\n          req.headers.forEach((value, name) => {\n            opts.headers[name] = value\n          })\n\n          opts.counter = ++req.counter\n          return cachingFetch(resolvedUrl, opts)\n        })\n        .catch(err => {\n          const code = (err.code === 'EPROMISERETRY')\n            ? err.retried.code\n            : err.code\n\n          const isRetryError = (\n            RETRY_ERRORS.indexOf(code) === -1 &&\n            RETRY_TYPES.indexOf(err.type) === -1\n          )\n\n          if (req.method === 'POST' || isRetryError)\n            throw err\n\n          if (typeof opts.onRetry === 'function')\n            opts.onRetry(err)\n\n          return retryHandler(err)\n        })\n    },\n    opts.retry\n  ).catch(err => {\n    if (err.status >= 400 && err.type !== 'system') {\n      // this is an HTTP response \"error\" that we care about\n      return err\n    }\n\n    throw err\n  })\n}\n"]},"metadata":{},"sourceType":"script"}
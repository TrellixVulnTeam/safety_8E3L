{"ast":null,"code":"const {\n  promisify\n} = require('util');\n\nconst read = promisify(require('read'));\n\nconst chalk = require('chalk');\n\nconst mkdirp = require('mkdirp-infer-owner');\n\nconst readPackageJson = require('read-package-json-fast');\n\nconst Arborist = require('@npmcli/arborist');\n\nconst runScript = require('@npmcli/run-script');\n\nconst {\n  resolve,\n  delimiter\n} = require('path');\n\nconst ciDetect = require('@npmcli/ci-detect');\n\nconst crypto = require('crypto');\n\nconst pacote = require('pacote');\n\nconst npa = require('npm-package-arg');\n\nconst fileExists = require('./utils/file-exists.js');\n\nconst PATH = require('./utils/path.js');\n\nconst BaseCommand = require('./base-command.js');\n\nconst getWorkspaces = require('./workspaces/get-workspaces.js'); // it's like this:\n//\n// npm x pkg@version <-- runs the bin named \"pkg\" or the only bin if only 1\n//\n// { name: 'pkg', bin: { pkg: 'pkg.js', foo: 'foo.js' }} <-- run pkg\n// { name: 'pkg', bin: { foo: 'foo.js' }} <-- run foo?\n//\n// npm x -p pkg@version -- foo\n//\n// npm x -p pkg@version -- foo --registry=/dev/null\n//\n// const pkg = npm.config.get('package') || getPackageFrom(args[0])\n// const cmd = getCommand(pkg, args[0])\n// --> npm x -c 'cmd ...args.slice(1)'\n//\n// we've resolved cmd and args, and escaped them properly, and installed the\n// relevant packages.\n//\n// Add the ${npx install prefix}/node_modules/.bin to PATH\n//\n// pkg = readPackageJson('./package.json')\n// pkg.scripts.___npx = ${the -c arg}\n// runScript({ pkg, event: 'npx', ... })\n// process.env.npm_lifecycle_event = 'npx'\n\n\nconst nocolor = {\n  reset: s => s,\n  bold: s => s,\n  dim: s => s,\n  green: s => s\n};\n\nclass Exec extends BaseCommand {\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get description() {\n    return 'Run a command from a local or remote npm package';\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  static get params() {\n    return ['workspace', 'workspaces'];\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  static get name() {\n    return 'exec';\n  }\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n\n\n  static get usage() {\n    return ['-- <pkg>[@<version>] [args...]', '--package=<pkg>[@<version>] -- <cmd> [args...]', '-c \\'<cmd> [args...]\\'', '--package=foo -c \\'<cmd> [args...]\\''];\n  }\n\n  exec(args, cb) {\n    const path = this.npm.localPrefix;\n    const runPath = process.cwd();\n\n    this._exec(args, {\n      path,\n      runPath\n    }).then(() => cb()).catch(cb);\n  }\n\n  execWorkspaces(args, filters, cb) {\n    this._execWorkspaces(args, filters).then(() => cb()).catch(cb);\n  } // When commands go async and we can dump the boilerplate exec methods this\n  // can be named correctly\n\n\n  async _exec(_args, {\n    locationMsg,\n    path,\n    runPath\n  }) {\n    const call = this.npm.config.get('call');\n    const shell = this.npm.config.get('shell'); // dereferenced because we manipulate it later\n\n    const packages = [...this.npm.config.get('package')];\n    if (call && _args.length) throw this.usage;\n    const args = [..._args];\n    const pathArr = [...PATH]; // nothing to maybe install, skip the arborist dance\n\n    if (!call && !args.length && !packages.length) {\n      return await this.run({\n        args,\n        call,\n        locationMsg,\n        shell,\n        path,\n        pathArr,\n        runPath\n      });\n    }\n\n    const needPackageCommandSwap = args.length && !packages.length; // if there's an argument and no package has been explicitly asked for\n    // check the local and global bin paths for a binary named the same as\n    // the argument and run it if it exists, otherwise fall through to\n    // the behavior of treating the single argument as a package name\n\n    if (needPackageCommandSwap) {\n      let binExists = false;\n\n      if (await fileExists(`${this.npm.localBin}/${args[0]}`)) {\n        pathArr.unshift(this.npm.localBin);\n        binExists = true;\n      } else if (await fileExists(`${this.npm.globalBin}/${args[0]}`)) {\n        pathArr.unshift(this.npm.globalBin);\n        binExists = true;\n      }\n\n      if (binExists) {\n        return await this.run({\n          args,\n          call,\n          locationMsg,\n          path,\n          pathArr,\n          runPath,\n          shell\n        });\n      }\n\n      packages.push(args[0]);\n    } // If we do `npm exec foo`, and have a `foo` locally, then we'll\n    // always use that, so we don't really need to fetch the manifest.\n    // So: run npa on each packages entry, and if it is a name with a\n    // rawSpec==='', then try to readPackageJson at\n    // node_modules/${name}/package.json, and only pacote fetch if\n    // that fails.\n\n\n    const manis = await Promise.all(packages.map(async p => {\n      const spec = npa(p, path);\n\n      if (spec.type === 'tag' && spec.rawSpec === '') {\n        // fall through to the pacote.manifest() approach\n        try {\n          const pj = resolve(path, 'node_modules', spec.name);\n          return await readPackageJson(pj);\n        } catch (er) {}\n      } // Force preferOnline to true so we are making sure to pull in the latest\n      // This is especially useful if the user didn't give us a version, and\n      // they expect to be running @latest\n\n\n      return await pacote.manifest(p, { ...this.npm.flatOptions,\n        preferOnline: true\n      });\n    }));\n    if (needPackageCommandSwap) args[0] = this.getBinFromManifest(manis[0]); // figure out whether we need to install stuff, or if local is fine\n\n    const localArb = new Arborist({ ...this.npm.flatOptions,\n      path\n    });\n    const tree = await localArb.loadActual(); // do we have all the packages in manifest list?\n\n    const needInstall = manis.some(mani => this.manifestMissing(tree, mani));\n\n    if (needInstall) {\n      const installDir = this.cacheInstallDir(packages);\n      await mkdirp(installDir);\n      const arb = new Arborist({ ...this.npm.flatOptions,\n        log: this.npm.log,\n        path: installDir\n      });\n      const tree = await arb.loadActual(); // at this point, we have to ensure that we get the exact same\n      // version, because it's something that has only ever been installed\n      // by npm exec in the cache install directory\n\n      const add = manis.filter(mani => this.manifestMissing(tree, { ...mani,\n        _from: `${mani.name}@${mani.version}`\n      })).map(mani => mani._from).sort((a, b) => a.localeCompare(b)); // no need to install if already present\n\n      if (add.length) {\n        if (!this.npm.config.get('yes')) {\n          // set -n to always say no\n          if (this.npm.config.get('yes') === false) throw new Error('canceled');\n\n          if (!process.stdin.isTTY || ciDetect()) {\n            this.npm.log.warn('exec', `The following package${add.length === 1 ? ' was' : 's were'} not found and will be installed: ${add.map(pkg => pkg.replace(/@$/, '')).join(', ')}`);\n          } else {\n            const addList = add.map(a => `  ${a.replace(/@$/, '')}`).join('\\n') + '\\n';\n            const prompt = `Need to install the following packages:\\n${addList}Ok to proceed? `;\n            const confirm = await read({\n              prompt,\n              default: 'y'\n            });\n            if (confirm.trim().toLowerCase().charAt(0) !== 'y') throw new Error('canceled');\n          }\n        }\n\n        await arb.reify({ ...this.npm.flatOptions,\n          log: this.npm.log,\n          add\n        });\n      }\n\n      pathArr.unshift(resolve(installDir, 'node_modules/.bin'));\n    }\n\n    return await this.run({\n      args,\n      call,\n      locationMsg,\n      path,\n      pathArr,\n      runPath,\n      shell\n    });\n  }\n\n  async run({\n    args,\n    call,\n    locationMsg,\n    path,\n    pathArr,\n    runPath,\n    shell\n  }) {\n    // turn list of args into command string\n    const script = call || args.shift() || shell; // do the fakey runScript dance\n    // still should work if no package.json in cwd\n\n    const realPkg = await readPackageJson(`${path}/package.json`).catch(() => ({}));\n    const pkg = { ...realPkg,\n      scripts: { ...(realPkg.scripts || {}),\n        npx: script\n      }\n    };\n    this.npm.log.disableProgress();\n\n    try {\n      if (script === shell) {\n        if (process.stdin.isTTY) {\n          if (ciDetect()) return this.npm.log.warn('exec', 'Interactive mode disabled in CI environment');\n          const color = this.npm.config.get('color');\n          const colorize = color ? chalk : nocolor;\n          locationMsg = locationMsg || ` at location:\\n${colorize.dim(runPath)}`;\n          this.npm.output(`${colorize.reset('\\nEntering npm script environment')}${colorize.reset(locationMsg)}${colorize.bold('\\nType \\'exit\\' or ^D when finished\\n')}`);\n        }\n      }\n\n      return await runScript({ ...this.npm.flatOptions,\n        pkg,\n        banner: false,\n        // we always run in cwd, not --prefix\n        path: runPath,\n        stdioString: true,\n        event: 'npx',\n        args,\n        env: {\n          PATH: pathArr.join(delimiter)\n        },\n        stdio: 'inherit'\n      });\n    } finally {\n      this.npm.log.enableProgress();\n    }\n  }\n\n  manifestMissing(tree, mani) {\n    // if the tree doesn't have a child by that name/version, return true\n    // true means we need to install it\n    const child = tree.children.get(mani.name); // if no child, we have to load it\n\n    if (!child) return true; // if no version/tag specified, allow whatever's there\n\n    if (mani._from === `${mani.name}@`) return false; // otherwise the version has to match what we WOULD get\n\n    return child.version !== mani.version;\n  }\n\n  getBinFromManifest(mani) {\n    // if we have a bin matching (unscoped portion of) packagename, use that\n    // otherwise if there's 1 bin or all bin value is the same (alias), use\n    // that, otherwise fail\n    const bin = mani.bin || {};\n    if (new Set(Object.values(bin)).size === 1) return Object.keys(bin)[0]; // XXX probably a util to parse this better?\n\n    const name = mani.name.replace(/^@[^/]+\\//, '');\n    if (bin[name]) return name; // XXX need better error message\n\n    throw Object.assign(new Error('could not determine executable to run'), {\n      pkgid: mani._id\n    });\n  }\n\n  cacheInstallDir(packages) {\n    // only packages not found in ${prefix}/node_modules\n    return resolve(this.npm.config.get('cache'), '_npx', this.getHash(packages));\n  }\n\n  getHash(packages) {\n    return crypto.createHash('sha512').update(packages.sort((a, b) => a.localeCompare(b)).join('\\n')).digest('hex').slice(0, 16);\n  }\n\n  async _execWorkspaces(args, filters) {\n    const workspaces = await getWorkspaces(filters, {\n      path: this.npm.localPrefix\n    });\n\n    const getLocationMsg = async path => {\n      const color = this.npm.config.get('color');\n      const colorize = color ? chalk : nocolor;\n      const {\n        _id\n      } = await readPackageJson(`${path}/package.json`);\n      return ` in workspace ${colorize.green(_id)} at location:\\n${colorize.dim(path)}`;\n    };\n\n    for (const workspacePath of workspaces.values()) {\n      const locationMsg = await getLocationMsg(workspacePath);\n      await this._exec(args, {\n        locationMsg,\n        path: workspacePath,\n        runPath: workspacePath\n      });\n    }\n  }\n\n}\n\nmodule.exports = Exec;","map":{"version":3,"sources":["/Users/kaelen/nsc-mds/node_modules/npm/lib/exec.js"],"names":["promisify","require","read","chalk","mkdirp","readPackageJson","Arborist","runScript","resolve","delimiter","ciDetect","crypto","pacote","npa","fileExists","PATH","BaseCommand","getWorkspaces","nocolor","reset","s","bold","dim","green","Exec","description","params","name","usage","exec","args","cb","path","npm","localPrefix","runPath","process","cwd","_exec","then","catch","execWorkspaces","filters","_execWorkspaces","_args","locationMsg","call","config","get","shell","packages","length","pathArr","run","needPackageCommandSwap","binExists","localBin","unshift","globalBin","push","manis","Promise","all","map","p","spec","type","rawSpec","pj","er","manifest","flatOptions","preferOnline","getBinFromManifest","localArb","tree","loadActual","needInstall","some","mani","manifestMissing","installDir","cacheInstallDir","arb","log","add","filter","_from","version","sort","a","b","localeCompare","Error","stdin","isTTY","warn","pkg","replace","join","addList","prompt","confirm","default","trim","toLowerCase","charAt","reify","script","shift","realPkg","scripts","npx","disableProgress","color","colorize","output","banner","stdioString","event","env","stdio","enableProgress","child","children","bin","Set","Object","values","size","keys","assign","pkgid","_id","getHash","createHash","update","digest","slice","workspaces","getLocationMsg","workspacePath","module","exports"],"mappings":"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","sourcesContent":["const { promisify } = require('util')\nconst read = promisify(require('read'))\nconst chalk = require('chalk')\nconst mkdirp = require('mkdirp-infer-owner')\nconst readPackageJson = require('read-package-json-fast')\nconst Arborist = require('@npmcli/arborist')\nconst runScript = require('@npmcli/run-script')\nconst { resolve, delimiter } = require('path')\nconst ciDetect = require('@npmcli/ci-detect')\nconst crypto = require('crypto')\nconst pacote = require('pacote')\nconst npa = require('npm-package-arg')\nconst fileExists = require('./utils/file-exists.js')\nconst PATH = require('./utils/path.js')\nconst BaseCommand = require('./base-command.js')\nconst getWorkspaces = require('./workspaces/get-workspaces.js')\n\n// it's like this:\n//\n// npm x pkg@version <-- runs the bin named \"pkg\" or the only bin if only 1\n//\n// { name: 'pkg', bin: { pkg: 'pkg.js', foo: 'foo.js' }} <-- run pkg\n// { name: 'pkg', bin: { foo: 'foo.js' }} <-- run foo?\n//\n// npm x -p pkg@version -- foo\n//\n// npm x -p pkg@version -- foo --registry=/dev/null\n//\n// const pkg = npm.config.get('package') || getPackageFrom(args[0])\n// const cmd = getCommand(pkg, args[0])\n// --> npm x -c 'cmd ...args.slice(1)'\n//\n// we've resolved cmd and args, and escaped them properly, and installed the\n// relevant packages.\n//\n// Add the ${npx install prefix}/node_modules/.bin to PATH\n//\n// pkg = readPackageJson('./package.json')\n// pkg.scripts.___npx = ${the -c arg}\n// runScript({ pkg, event: 'npx', ... })\n// process.env.npm_lifecycle_event = 'npx'\n\nconst nocolor = {\n  reset: s => s,\n  bold: s => s,\n  dim: s => s,\n  green: s => s,\n}\n\nclass Exec extends BaseCommand {\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get description () {\n    return 'Run a command from a local or remote npm package'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get params () {\n    return ['workspace', 'workspaces']\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get name () {\n    return 'exec'\n  }\n\n  /* istanbul ignore next - see test/lib/load-all-commands.js */\n  static get usage () {\n    return [\n      '-- <pkg>[@<version>] [args...]',\n      '--package=<pkg>[@<version>] -- <cmd> [args...]',\n      '-c \\'<cmd> [args...]\\'',\n      '--package=foo -c \\'<cmd> [args...]\\'',\n    ]\n  }\n\n  exec (args, cb) {\n    const path = this.npm.localPrefix\n    const runPath = process.cwd()\n    this._exec(args, { path, runPath }).then(() => cb()).catch(cb)\n  }\n\n  execWorkspaces (args, filters, cb) {\n    this._execWorkspaces(args, filters).then(() => cb()).catch(cb)\n  }\n\n  // When commands go async and we can dump the boilerplate exec methods this\n  // can be named correctly\n  async _exec (_args, { locationMsg, path, runPath }) {\n    const call = this.npm.config.get('call')\n    const shell = this.npm.config.get('shell')\n    // dereferenced because we manipulate it later\n    const packages = [...this.npm.config.get('package')]\n\n    if (call && _args.length)\n      throw this.usage\n\n    const args = [..._args]\n    const pathArr = [...PATH]\n\n    // nothing to maybe install, skip the arborist dance\n    if (!call && !args.length && !packages.length) {\n      return await this.run({\n        args,\n        call,\n        locationMsg,\n        shell,\n        path,\n        pathArr,\n        runPath,\n      })\n    }\n\n    const needPackageCommandSwap = args.length && !packages.length\n    // if there's an argument and no package has been explicitly asked for\n    // check the local and global bin paths for a binary named the same as\n    // the argument and run it if it exists, otherwise fall through to\n    // the behavior of treating the single argument as a package name\n    if (needPackageCommandSwap) {\n      let binExists = false\n      if (await fileExists(`${this.npm.localBin}/${args[0]}`)) {\n        pathArr.unshift(this.npm.localBin)\n        binExists = true\n      } else if (await fileExists(`${this.npm.globalBin}/${args[0]}`)) {\n        pathArr.unshift(this.npm.globalBin)\n        binExists = true\n      }\n\n      if (binExists) {\n        return await this.run({\n          args,\n          call,\n          locationMsg,\n          path,\n          pathArr,\n          runPath,\n          shell,\n        })\n      }\n\n      packages.push(args[0])\n    }\n\n    // If we do `npm exec foo`, and have a `foo` locally, then we'll\n    // always use that, so we don't really need to fetch the manifest.\n    // So: run npa on each packages entry, and if it is a name with a\n    // rawSpec==='', then try to readPackageJson at\n    // node_modules/${name}/package.json, and only pacote fetch if\n    // that fails.\n    const manis = await Promise.all(packages.map(async p => {\n      const spec = npa(p, path)\n      if (spec.type === 'tag' && spec.rawSpec === '') {\n        // fall through to the pacote.manifest() approach\n        try {\n          const pj = resolve(path, 'node_modules', spec.name)\n          return await readPackageJson(pj)\n        } catch (er) {}\n      }\n      // Force preferOnline to true so we are making sure to pull in the latest\n      // This is especially useful if the user didn't give us a version, and\n      // they expect to be running @latest\n      return await pacote.manifest(p, {\n        ...this.npm.flatOptions,\n        preferOnline: true,\n      })\n    }))\n\n    if (needPackageCommandSwap)\n      args[0] = this.getBinFromManifest(manis[0])\n\n    // figure out whether we need to install stuff, or if local is fine\n    const localArb = new Arborist({\n      ...this.npm.flatOptions,\n      path,\n    })\n    const tree = await localArb.loadActual()\n\n    // do we have all the packages in manifest list?\n    const needInstall = manis.some(mani => this.manifestMissing(tree, mani))\n\n    if (needInstall) {\n      const installDir = this.cacheInstallDir(packages)\n      await mkdirp(installDir)\n      const arb = new Arborist({\n        ...this.npm.flatOptions,\n        log: this.npm.log,\n        path: installDir,\n      })\n      const tree = await arb.loadActual()\n\n      // at this point, we have to ensure that we get the exact same\n      // version, because it's something that has only ever been installed\n      // by npm exec in the cache install directory\n      const add = manis.filter(mani => this.manifestMissing(tree, {\n        ...mani,\n        _from: `${mani.name}@${mani.version}`,\n      }))\n        .map(mani => mani._from)\n        .sort((a, b) => a.localeCompare(b))\n\n      // no need to install if already present\n      if (add.length) {\n        if (!this.npm.config.get('yes')) {\n          // set -n to always say no\n          if (this.npm.config.get('yes') === false)\n            throw new Error('canceled')\n\n          if (!process.stdin.isTTY || ciDetect()) {\n            this.npm.log.warn('exec', `The following package${\n            add.length === 1 ? ' was' : 's were'\n          } not found and will be installed: ${\n            add.map((pkg) => pkg.replace(/@$/, '')).join(', ')\n          }`)\n          } else {\n            const addList = add.map(a => `  ${a.replace(/@$/, '')}`)\n              .join('\\n') + '\\n'\n            const prompt = `Need to install the following packages:\\n${\n            addList\n          }Ok to proceed? `\n            const confirm = await read({ prompt, default: 'y' })\n            if (confirm.trim().toLowerCase().charAt(0) !== 'y')\n              throw new Error('canceled')\n          }\n        }\n        await arb.reify({\n          ...this.npm.flatOptions,\n          log: this.npm.log,\n          add,\n        })\n      }\n      pathArr.unshift(resolve(installDir, 'node_modules/.bin'))\n    }\n\n    return await this.run({\n      args,\n      call,\n      locationMsg,\n      path,\n      pathArr,\n      runPath,\n      shell,\n    })\n  }\n\n  async run ({ args, call, locationMsg, path, pathArr, runPath, shell }) {\n    // turn list of args into command string\n    const script = call || args.shift() || shell\n\n    // do the fakey runScript dance\n    // still should work if no package.json in cwd\n    const realPkg = await readPackageJson(`${path}/package.json`)\n      .catch(() => ({}))\n    const pkg = {\n      ...realPkg,\n      scripts: {\n        ...(realPkg.scripts || {}),\n        npx: script,\n      },\n    }\n\n    this.npm.log.disableProgress()\n    try {\n      if (script === shell) {\n        if (process.stdin.isTTY) {\n          if (ciDetect())\n            return this.npm.log.warn('exec', 'Interactive mode disabled in CI environment')\n\n          const color = this.npm.config.get('color')\n          const colorize = color ? chalk : nocolor\n\n          locationMsg = locationMsg || ` at location:\\n${colorize.dim(runPath)}`\n\n          this.npm.output(`${\n            colorize.reset('\\nEntering npm script environment')\n          }${\n            colorize.reset(locationMsg)\n          }${\n            colorize.bold('\\nType \\'exit\\' or ^D when finished\\n')\n          }`)\n        }\n      }\n      return await runScript({\n        ...this.npm.flatOptions,\n        pkg,\n        banner: false,\n        // we always run in cwd, not --prefix\n        path: runPath,\n        stdioString: true,\n        event: 'npx',\n        args,\n        env: {\n          PATH: pathArr.join(delimiter),\n        },\n        stdio: 'inherit',\n      })\n    } finally {\n      this.npm.log.enableProgress()\n    }\n  }\n\n  manifestMissing (tree, mani) {\n    // if the tree doesn't have a child by that name/version, return true\n    // true means we need to install it\n    const child = tree.children.get(mani.name)\n    // if no child, we have to load it\n    if (!child)\n      return true\n\n    // if no version/tag specified, allow whatever's there\n    if (mani._from === `${mani.name}@`)\n      return false\n\n    // otherwise the version has to match what we WOULD get\n    return child.version !== mani.version\n  }\n\n  getBinFromManifest (mani) {\n    // if we have a bin matching (unscoped portion of) packagename, use that\n    // otherwise if there's 1 bin or all bin value is the same (alias), use\n    // that, otherwise fail\n    const bin = mani.bin || {}\n    if (new Set(Object.values(bin)).size === 1)\n      return Object.keys(bin)[0]\n\n    // XXX probably a util to parse this better?\n    const name = mani.name.replace(/^@[^/]+\\//, '')\n    if (bin[name])\n      return name\n\n    // XXX need better error message\n    throw Object.assign(new Error('could not determine executable to run'), {\n      pkgid: mani._id,\n    })\n  }\n\n  cacheInstallDir (packages) {\n    // only packages not found in ${prefix}/node_modules\n    return resolve(this.npm.config.get('cache'), '_npx', this.getHash(packages))\n  }\n\n  getHash (packages) {\n    return crypto.createHash('sha512')\n      .update(packages.sort((a, b) => a.localeCompare(b)).join('\\n'))\n      .digest('hex')\n      .slice(0, 16)\n  }\n\n  async _execWorkspaces (args, filters) {\n    const workspaces =\n      await getWorkspaces(filters, { path: this.npm.localPrefix })\n    const getLocationMsg = async path => {\n      const color = this.npm.config.get('color')\n      const colorize = color ? chalk : nocolor\n      const { _id } = await readPackageJson(`${path}/package.json`)\n      return ` in workspace ${colorize.green(_id)} at location:\\n${colorize.dim(path)}`\n    }\n\n    for (const workspacePath of workspaces.values()) {\n      const locationMsg = await getLocationMsg(workspacePath)\n      await this._exec(args, {\n        locationMsg,\n        path: workspacePath,\n        runPath: workspacePath,\n      })\n    }\n  }\n}\nmodule.exports = Exec\n"]},"metadata":{},"sourceType":"script"}